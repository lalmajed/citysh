<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Route Segmentation Viewer</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: -apple-system, sans-serif; background: #f5f5f5; padding: 20px; }
        h1 { color: #1565c0; margin-bottom: 5px; }
        .subtitle { color: #666; margin-bottom: 20px; }
        .container { max-width: 1600px; margin: 0 auto; }
        .stat-row { display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap; }
        .stat { flex: 1; min-width: 120px; background: white; padding: 15px; border-radius: 8px; text-align: center; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .stat-value { font-size: 1.5rem; font-weight: bold; color: #1565c0; }
        .stat-value.green { color: #2e7d32; }
        .stat-value.orange { color: #f57c00; }
        .stat-value.red { color: #c62828; }
        .stat-label { color: #666; font-size: 0.75rem; }
        .grid { display: grid; grid-template-columns: 380px 1fr; gap: 15px; }
        .panel { background: white; border-radius: 10px; padding: 15px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); margin-bottom: 15px; }
        .panel h2 { color: #1565c0; font-size: 0.9rem; margin-bottom: 10px; border-bottom: 2px solid #1565c0; padding-bottom: 8px; }
        select, input { width: 100%; padding: 10px; font-size: 0.9rem; border: 2px solid #ddd; border-radius: 6px; margin-bottom: 10px; }
        .btn { width: 100%; padding: 12px; background: #1565c0; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; margin-bottom: 10px; }
        .btn:hover { background: #0d47a1; }
        .btn-sm { padding: 8px 15px; font-size: 0.8rem; width: auto; margin: 3px; }
        .btn-green { background: #2e7d32; }
        .btn-purple { background: #7b1fa2; }
        #map { height: 600px; border-radius: 10px; }
        .trip-item { padding: 10px; margin: 5px 0; border-radius: 6px; cursor: pointer; border-left: 4px solid #ddd; background: #f9f9f9; }
        .trip-item:hover { background: #e3f2fd; }
        .trip-item.normal { border-left-color: #4caf50; }
        .trip-item.slow { border-left-color: #ff9800; }
        .trip-item.break { border-left-color: #f44336; }
        .trip-item.selected { background: #bbdefb; }
        .trip-header { display: flex; justify-content: space-between; font-weight: 500; }
        .trip-details { font-size: 0.8rem; color: #666; margin-top: 5px; }
        .trip-ratio { font-weight: bold; padding: 2px 6px; border-radius: 3px; font-size: 0.75rem; }
        .trip-ratio.normal { background: #c8e6c9; color: #2e7d32; }
        .trip-ratio.slow { background: #ffe0b2; color: #e65100; }
        .trip-ratio.break { background: #ffcdd2; color: #c62828; }
        .trips-list { max-height: 400px; overflow-y: auto; }
        .no-data { text-align: center; padding: 30px; color: #999; }
        .time-inputs { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .input-group { margin-bottom: 10px; }
        .input-group label { display: block; font-size: 0.8rem; color: #666; margin-bottom: 4px; }
        .legend { display: flex; gap: 15px; margin-bottom: 15px; flex-wrap: wrap; }
        .legend-item { display: flex; align-items: center; gap: 5px; font-size: 0.8rem; }
        .legend-color { width: 16px; height: 16px; border-radius: 3px; }
        .config-section { background: #e8f5e9; padding: 10px; border-radius: 6px; margin-bottom: 10px; }
        .config-section h3 { font-size: 0.85rem; color: #2e7d32; margin-bottom: 8px; }
        .path-info { background: #fff3e0; padding: 15px; border-radius: 8px; margin-top: 10px; }
        .path-info h3 { color: #e65100; margin-bottom: 10px; }
        .path-item { padding: 8px; background: white; border-radius: 4px; margin: 5px 0; }
        .waypoint-item { padding: 8px 12px; margin: 3px 0; border-radius: 4px; background: #f5f5f5; font-size: 0.85rem; display: flex; justify-content: space-between; align-items: center; }
        .waypoint-item:hover { background: #e3f2fd; cursor: pointer; }
        .waypoint-idx { font-weight: bold; color: #1565c0; min-width: 30px; }
        .waypoint-coords { color: #666; font-family: monospace; font-size: 0.75rem; }
        .file-drop-zone { border: 2px dashed #ccc; border-radius: 8px; padding: 20px; text-align: center; transition: all 0.3s; margin-bottom: 10px; }
        .file-drop-zone:hover, .file-drop-zone.dragover { border-color: #1565c0; background: #e3f2fd; }
        .route-color-picker { display: flex; align-items: center; gap: 10px; margin-bottom: 10px; }
        .route-color-picker input[type="color"] { width: 50px; height: 35px; border: none; cursor: pointer; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Route Segmentation Viewer</h1>
        <p class="subtitle">Upload JSON to display and analyze routes on the map</p>
        
        <div class="stat-row">
            <div class="stat"><div class="stat-value" id="statPoints">0</div><div class="stat-label">Route Points</div></div>
            <div class="stat"><div class="stat-value" id="statSegments">0</div><div class="stat-label">Segments</div></div>
            <div class="stat"><div class="stat-value" id="statDistance">0</div><div class="stat-label">Total Distance (km)</div></div>
            <div class="stat"><div class="stat-value green" id="statVehicles">0</div><div class="stat-label">Vehicles</div></div>
        </div>
        
        <div class="grid">
            <div class="sidebar">
                <div class="panel">
                    <h2>Load Route Data</h2>
                    <div class="file-drop-zone" id="dropZone">
                        <p>Drag and drop JSON file here</p>
                        <p style="color:#999;font-size:0.8rem;margin-top:5px;">or click to browse</p>
                    </div>
                    <input type="file" id="routeFile" accept=".json,.geojson" style="display:none;">
                    <div style="font-size:0.75rem;color:#666;margin-bottom:10px;">
                        Supported formats:<br>
                        - Array of {lat, lon/lng} points<br>
                        - GeoJSON (LineString, MultiLineString, FeatureCollection)<br>
                        - {route: [...points]}<br>
                        - {coordinates: [...points]}<br>
                        - Trips with camera_prev, camera_next
                    </div>
                    <button class="btn btn-sm btn-purple" onclick="loadSampleRoute()">Load Sample Route</button>
                </div>
                
                <div class="panel">
                    <h2>Route Display Options</h2>
                    <div class="route-color-picker">
                        <label>Route Color:</label>
                        <input type="color" id="routeColor" value="#1565c0" onchange="updateRouteStyle()">
                    </div>
                    <div class="input-group">
                        <label>Line Width</label>
                        <input type="range" id="lineWidth" min="2" max="10" value="4" onchange="updateRouteStyle()">
                    </div>
                    <label style="font-size:0.85rem;display:flex;align-items:center;gap:8px;margin-bottom:10px;">
                        <input type="checkbox" id="showMarkers" checked onchange="toggleMarkers()"> Show waypoint markers
                    </label>
                    <label style="font-size:0.85rem;display:flex;align-items:center;gap:8px;margin-bottom:10px;">
                        <input type="checkbox" id="showStartEnd" checked onchange="toggleStartEnd()"> Highlight start/end
                    </label>
                </div>
                
                <div class="panel">
                    <h2>Select Vehicle</h2>
                    <select id="vehicleSel" onchange="onVehicleChange()">
                        <option value="all">-- All Vehicles --</option>
                    </select>
                </div>
                
                <div class="panel">
                    <h2>Map Controls</h2>
                    <button class="btn btn-sm btn-green" onclick="fitMapToRoute()">Fit to Route</button>
                    <button class="btn btn-sm" onclick="clearRoute()">Clear Route</button>
                    <button class="btn btn-sm btn-purple" onclick="exportRouteAsGeoJSON()">Export as GeoJSON</button>
                </div>
            </div>
            
            <div class="main">
                <div class="panel">
                    <div class="legend">
                        <div class="legend-item"><div class="legend-color" style="background:#4caf50;"></div> Start Point</div>
                        <div class="legend-item"><div class="legend-color" style="background:#f44336;"></div> End Point</div>
                        <div class="legend-item"><div class="legend-color" style="background:#1565c0;"></div> Route Path</div>
                        <div class="legend-item"><div class="legend-color" style="background:#ff9800;border-radius:50%;"></div> Waypoints</div>
                    </div>
                    <div id="map"></div>
                </div>
                
                <div class="panel">
                    <h2>Route Points</h2>
                    <div class="trips-list" id="waypointsList">
                        <div class="no-data">Upload a JSON file to display route points</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
// ============================================
// GLOBAL VARIABLES
// ============================================
let map;
let routePolyline = null;
let waypointMarkers = [];
let startMarker = null;
let endMarker = null;
let currentRoutePoints = [];
let allLoadedData = null;

// ============================================
// INITIALIZE MAP
// ============================================
function initMap() {
    map = new google.maps.Map(document.getElementById('map'), {
        center: { lat: 24.7136, lng: 46.6753 }, // Default to Riyadh
        zoom: 11,
        mapTypeControl: true,
        streetViewControl: false
    });
    
    setupDragDrop();
    console.log('Map initialized');
}

// ============================================
// DRAG & DROP HANDLING
// ============================================
function setupDragDrop() {
    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('routeFile');
    
    dropZone.addEventListener('click', () => fileInput.click());
    
    dropZone.addEventListener('dragover', (e) => {
        e.preventDefault();
        dropZone.classList.add('dragover');
    });
    
    dropZone.addEventListener('dragleave', () => {
        dropZone.classList.remove('dragover');
    });
    
    dropZone.addEventListener('drop', (e) => {
        e.preventDefault();
        dropZone.classList.remove('dragover');
        const file = e.dataTransfer.files[0];
        if (file) loadFile(file);
    });
    
    fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) loadFile(file);
    });
}

// ============================================
// FILE LOADING
// ============================================
function loadFile(file) {
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const data = JSON.parse(e.target.result);
            allLoadedData = data;
            processAndDisplayRoute(data);
        } catch (err) {
            alert('Error parsing JSON file: ' + err.message);
            console.error(err);
        }
    };
    reader.readAsText(file);
}

// ============================================
// ROUTE DATA PROCESSING
// ============================================
function processAndDisplayRoute(data) {
    let points = [];
    let vehicles = [];
    
    // Try to extract route points from various JSON formats
    points = extractRoutePoints(data);
    
    if (points.length === 0) {
        alert('Could not find route coordinates in the uploaded file. Please check the format.');
        return;
    }
    
    // Extract vehicles if present
    if (Array.isArray(data)) {
        vehicles = [...new Set(data.map(d => d.vehicle_id).filter(Boolean))];
    } else if (data.trips) {
        vehicles = [...new Set(data.trips.map(t => t.vehicle_id).filter(Boolean))];
    } else if (data.vehicle_id) {
        vehicles = [data.vehicle_id];
    }
    
    // Populate vehicle dropdown
    populateVehicleDropdown(vehicles);
    
    // Store and display route
    currentRoutePoints = points;
    displayRoute(points);
    updateStats(points, vehicles);
    renderWaypointsList(points);
    
    console.log(`Loaded ${points.length} route points`);
}

function extractRoutePoints(data) {
    let points = [];
    
    // Format 1: Direct array of coordinates
    if (Array.isArray(data)) {
        // Check if it's an array of [lng, lat] or [lat, lng] pairs
        if (data.length > 0 && Array.isArray(data[0]) && data[0].length >= 2) {
            // Assume [lng, lat] format (GeoJSON standard)
            points = data.map(coord => ({
                lat: coord[1],
                lng: coord[0]
            }));
        }
        // Check if it's an array of {lat, lon/lng} objects
        else if (data.length > 0 && typeof data[0] === 'object') {
            // Could be trips data or coordinate objects
            if (data[0].lat !== undefined) {
                points = data.map(p => ({
                    lat: parseFloat(p.lat),
                    lng: parseFloat(p.lon || p.lng || p.longitude)
                }));
            }
            // Trips format with camera_prev, camera_next
            else if (data[0].camera_prev) {
                points = extractPointsFromTrips(data);
            }
        }
    }
    // Format 2: GeoJSON
    else if (data.type) {
        points = extractPointsFromGeoJSON(data);
    }
    // Format 3: Object with route/coordinates/path property
    else if (data.route || data.coordinates || data.path || data.points || data.waypoints) {
        const routeData = data.route || data.coordinates || data.path || data.points || data.waypoints;
        return extractRoutePoints(routeData);
    }
    // Format 4: Object with trips array
    else if (data.trips && Array.isArray(data.trips)) {
        points = extractPointsFromTrips(data.trips);
    }
    // Format 5: Object with geometry property
    else if (data.geometry) {
        points = extractPointsFromGeoJSON(data.geometry);
    }
    
    // Filter out invalid points
    points = points.filter(p => 
        p && 
        typeof p.lat === 'number' && !isNaN(p.lat) &&
        typeof p.lng === 'number' && !isNaN(p.lng) &&
        p.lat >= -90 && p.lat <= 90 &&
        p.lng >= -180 && p.lng <= 180
    );
    
    return points;
}

function extractPointsFromGeoJSON(geojson) {
    let points = [];
    
    if (geojson.type === 'FeatureCollection') {
        geojson.features.forEach(feature => {
            points = points.concat(extractPointsFromGeoJSON(feature));
        });
    }
    else if (geojson.type === 'Feature') {
        points = extractPointsFromGeoJSON(geojson.geometry);
    }
    else if (geojson.type === 'LineString') {
        points = geojson.coordinates.map(coord => ({
            lat: coord[1],
            lng: coord[0]
        }));
    }
    else if (geojson.type === 'MultiLineString') {
        geojson.coordinates.forEach(line => {
            line.forEach(coord => {
                points.push({ lat: coord[1], lng: coord[0] });
            });
        });
    }
    else if (geojson.type === 'Point') {
        points.push({
            lat: geojson.coordinates[1],
            lng: geojson.coordinates[0]
        });
    }
    else if (geojson.type === 'MultiPoint') {
        points = geojson.coordinates.map(coord => ({
            lat: coord[1],
            lng: coord[0]
        }));
    }
    else if (geojson.type === 'Polygon') {
        // Use the outer ring
        points = geojson.coordinates[0].map(coord => ({
            lat: coord[1],
            lng: coord[0]
        }));
    }
    
    return points;
}

function extractPointsFromTrips(trips) {
    const points = [];
    const siteCoords = {};
    
    // First, try to get coordinates from site lookup or embedded in trips
    trips.forEach(trip => {
        if (trip.lat_prev !== undefined && trip.lon_prev !== undefined) {
            siteCoords[trip.camera_prev] = { lat: trip.lat_prev, lng: trip.lon_prev };
        }
        if (trip.lat_next !== undefined && trip.lon_next !== undefined) {
            siteCoords[trip.camera_next] = { lat: trip.lat_next, lng: trip.lon_next };
        }
        if (trip.from_lat !== undefined && trip.from_lon !== undefined) {
            points.push({ lat: trip.from_lat, lng: trip.from_lon || trip.from_lng });
        }
        if (trip.to_lat !== undefined && trip.to_lon !== undefined) {
            points.push({ lat: trip.to_lat, lng: trip.to_lon || trip.to_lng });
        }
    });
    
    // If we have site coordinates, build route from trips
    if (Object.keys(siteCoords).length > 0) {
        // Sort trips by timestamp if available
        const sortedTrips = [...trips].sort((a, b) => {
            const ta = new Date(a.timestamp_prev || a.timestamp || 0);
            const tb = new Date(b.timestamp_prev || b.timestamp || 0);
            return ta - tb;
        });
        
        sortedTrips.forEach((trip, idx) => {
            const prevCoord = siteCoords[trip.camera_prev];
            const nextCoord = siteCoords[trip.camera_next];
            
            if (idx === 0 && prevCoord) {
                points.push(prevCoord);
            }
            if (nextCoord) {
                points.push(nextCoord);
            }
        });
    }
    
    return points;
}

// ============================================
// ROUTE DISPLAY
// ============================================
function displayRoute(points) {
    clearRoute();
    
    if (points.length === 0) return;
    
    const routeColor = document.getElementById('routeColor').value;
    const lineWidth = parseInt(document.getElementById('lineWidth').value);
    
    // Draw polyline
    routePolyline = new google.maps.Polyline({
        path: points,
        strokeColor: routeColor,
        strokeOpacity: 0.9,
        strokeWeight: lineWidth,
        map: map
    });
    
    // Add waypoint markers if enabled
    if (document.getElementById('showMarkers').checked) {
        addWaypointMarkers(points);
    }
    
    // Add start/end markers if enabled
    if (document.getElementById('showStartEnd').checked) {
        addStartEndMarkers(points);
    }
    
    // Fit map to route
    fitMapToRoute();
}

function addWaypointMarkers(points) {
    waypointMarkers.forEach(m => m.setMap(null));
    waypointMarkers = [];
    
    // Limit markers for performance (show every Nth point if too many)
    const maxMarkers = 100;
    const step = Math.max(1, Math.floor(points.length / maxMarkers));
    
    points.forEach((point, idx) => {
        if (idx % step !== 0 && idx !== 0 && idx !== points.length - 1) return;
        
        const marker = new google.maps.Marker({
            position: point,
            map: map,
            icon: {
                path: google.maps.SymbolPath.CIRCLE,
                scale: 5,
                fillColor: '#ff9800',
                fillOpacity: 0.8,
                strokeColor: '#fff',
                strokeWeight: 1
            },
            title: `Point ${idx + 1}: ${point.lat.toFixed(6)}, ${point.lng.toFixed(6)}`,
            zIndex: 10
        });
        
        marker.addListener('click', () => {
            highlightWaypoint(idx);
        });
        
        waypointMarkers.push(marker);
    });
}

function addStartEndMarkers(points) {
    if (startMarker) startMarker.setMap(null);
    if (endMarker) endMarker.setMap(null);
    
    if (points.length === 0) return;
    
    // Start marker (green)
    startMarker = new google.maps.Marker({
        position: points[0],
        map: map,
        icon: 'http://maps.google.com/mapfiles/ms/icons/green-dot.png',
        title: 'Start: ' + points[0].lat.toFixed(6) + ', ' + points[0].lng.toFixed(6),
        zIndex: 100
    });
    
    // End marker (red)
    if (points.length > 1) {
        const lastPoint = points[points.length - 1];
        endMarker = new google.maps.Marker({
            position: lastPoint,
            map: map,
            icon: 'http://maps.google.com/mapfiles/ms/icons/red-dot.png',
            title: 'End: ' + lastPoint.lat.toFixed(6) + ', ' + lastPoint.lng.toFixed(6),
            zIndex: 100
        });
    }
}

function clearRoute() {
    if (routePolyline) {
        routePolyline.setMap(null);
        routePolyline = null;
    }
    waypointMarkers.forEach(m => m.setMap(null));
    waypointMarkers = [];
    if (startMarker) {
        startMarker.setMap(null);
        startMarker = null;
    }
    if (endMarker) {
        endMarker.setMap(null);
        endMarker = null;
    }
    currentRoutePoints = [];
    document.getElementById('waypointsList').innerHTML = '<div class="no-data">Upload a JSON file to display route points</div>';
    updateStats([], []);
}

function fitMapToRoute() {
    if (currentRoutePoints.length === 0) return;
    
    const bounds = new google.maps.LatLngBounds();
    currentRoutePoints.forEach(p => bounds.extend(p));
    map.fitBounds(bounds, 50);
}

// ============================================
// UI UPDATES
// ============================================
function updateStats(points, vehicles) {
    document.getElementById('statPoints').textContent = points.length;
    document.getElementById('statSegments').textContent = Math.max(0, points.length - 1);
    document.getElementById('statVehicles').textContent = vehicles.length;
    
    // Calculate total distance
    let totalDistance = 0;
    for (let i = 1; i < points.length; i++) {
        totalDistance += haversine(points[i-1].lat, points[i-1].lng, points[i].lat, points[i].lng);
    }
    document.getElementById('statDistance').textContent = totalDistance.toFixed(2);
}

function renderWaypointsList(points) {
    const list = document.getElementById('waypointsList');
    
    if (points.length === 0) {
        list.innerHTML = '<div class="no-data">No waypoints to display</div>';
        return;
    }
    
    let html = '';
    points.forEach((p, idx) => {
        html += `
        <div class="waypoint-item" onclick="zoomToWaypoint(${idx})" data-idx="${idx}">
            <span class="waypoint-idx">${idx + 1}</span>
            <span class="waypoint-coords">${p.lat.toFixed(6)}, ${p.lng.toFixed(6)}</span>
        </div>`;
    });
    
    list.innerHTML = html;
}

function highlightWaypoint(idx) {
    // Remove previous selection
    document.querySelectorAll('.waypoint-item').forEach(el => el.style.background = '#f5f5f5');
    
    // Highlight selected
    const el = document.querySelector(`.waypoint-item[data-idx="${idx}"]`);
    if (el) {
        el.style.background = '#bbdefb';
        el.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
}

function zoomToWaypoint(idx) {
    if (idx >= 0 && idx < currentRoutePoints.length) {
        map.setCenter(currentRoutePoints[idx]);
        map.setZoom(16);
        highlightWaypoint(idx);
    }
}

function populateVehicleDropdown(vehicles) {
    const sel = document.getElementById('vehicleSel');
    sel.innerHTML = '<option value="all">-- All Vehicles --</option>';
    vehicles.forEach(v => {
        sel.innerHTML += `<option value="${v}">${v}</option>`;
    });
}

function onVehicleChange() {
    const vehicleId = document.getElementById('vehicleSel').value;
    if (!allLoadedData || vehicleId === 'all') {
        if (allLoadedData) {
            processAndDisplayRoute(allLoadedData);
        }
        return;
    }
    
    // Filter data by vehicle
    let filteredData;
    if (Array.isArray(allLoadedData)) {
        filteredData = allLoadedData.filter(d => d.vehicle_id === vehicleId);
    } else if (allLoadedData.trips) {
        filteredData = { ...allLoadedData, trips: allLoadedData.trips.filter(t => t.vehicle_id === vehicleId) };
    } else {
        filteredData = allLoadedData;
    }
    
    const points = extractRoutePoints(filteredData);
    currentRoutePoints = points;
    displayRoute(points);
    updateStats(points, [vehicleId]);
    renderWaypointsList(points);
}

// ============================================
// STYLE UPDATES
// ============================================
function updateRouteStyle() {
    if (routePolyline) {
        const routeColor = document.getElementById('routeColor').value;
        const lineWidth = parseInt(document.getElementById('lineWidth').value);
        routePolyline.setOptions({
            strokeColor: routeColor,
            strokeWeight: lineWidth
        });
    }
}

function toggleMarkers() {
    const show = document.getElementById('showMarkers').checked;
    if (show && currentRoutePoints.length > 0) {
        addWaypointMarkers(currentRoutePoints);
    } else {
        waypointMarkers.forEach(m => m.setMap(null));
        waypointMarkers = [];
    }
}

function toggleStartEnd() {
    const show = document.getElementById('showStartEnd').checked;
    if (show && currentRoutePoints.length > 0) {
        addStartEndMarkers(currentRoutePoints);
    } else {
        if (startMarker) startMarker.setMap(null);
        if (endMarker) endMarker.setMap(null);
        startMarker = null;
        endMarker = null;
    }
}

// ============================================
// UTILITIES
// ============================================
function haversine(lat1, lon1, lat2, lon2) {
    const R = 6371; // km
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a = Math.sin(dLat/2) ** 2 + Math.cos(lat1 * Math.PI/180) * Math.cos(lat2 * Math.PI/180) * Math.sin(dLon/2) ** 2;
    return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}

function loadSampleRoute() {
    // Sample route in Riyadh
    const sampleData = [
        { lat: 24.7136, lng: 46.6753 },
        { lat: 24.7200, lng: 46.6800 },
        { lat: 24.7250, lng: 46.6900 },
        { lat: 24.7300, lng: 46.7000 },
        { lat: 24.7400, lng: 46.7100 },
        { lat: 24.7500, lng: 46.7150 },
        { lat: 24.7600, lng: 46.7200 },
        { lat: 24.7700, lng: 46.7300 },
        { lat: 24.7800, lng: 46.7400 },
        { lat: 24.7900, lng: 46.7500 }
    ];
    
    allLoadedData = sampleData;
    processAndDisplayRoute(sampleData);
}

function exportRouteAsGeoJSON() {
    if (currentRoutePoints.length === 0) {
        alert('No route to export');
        return;
    }
    
    const geojson = {
        type: 'Feature',
        properties: {
            name: 'Exported Route',
            points: currentRoutePoints.length
        },
        geometry: {
            type: 'LineString',
            coordinates: currentRoutePoints.map(p => [p.lng, p.lat])
        }
    };
    
    const blob = new Blob([JSON.stringify(geojson, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'route.geojson';
    a.click();
    URL.revokeObjectURL(url);
}

// Initialize when Google Maps loads
window.initMap = initMap;
    </script>
    <script src="https://cdn.jsdelivr.net/gh/somanchiu/Keyless-Google-Maps-API@v7.1/mapsJavaScriptAPI.js" async defer></script>
</body>
</html>
