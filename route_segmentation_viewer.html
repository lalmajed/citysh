<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Route Segmentation Viewer</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f5f5f5; padding: 20px; }
        h1 { color: #4285f4; margin-bottom: 5px; }
        .subtitle { color: #666; margin-bottom: 20px; }
        .container { max-width: 1400px; margin: 0 auto; }
        .stat-row { display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap; }
        .stat { flex: 1; min-width: 100px; background: white; padding: 15px; border-radius: 8px; text-align: center; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .stat-value { font-size: 1.5rem; font-weight: bold; color: #4285f4; }
        .stat-value.green { color: #34a853; }
        .stat-value.yellow { color: #fbbc05; }
        .stat-value.red { color: #ea4335; }
        .stat-label { color: #666; font-size: 0.75rem; }
        .grid { display: grid; grid-template-columns: 350px 1fr; gap: 15px; }
        .panel { background: white; border-radius: 10px; padding: 15px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); margin-bottom: 15px; }
        .panel h2 { color: #4285f4; font-size: 0.9rem; margin-bottom: 10px; border-bottom: 2px solid #4285f4; padding-bottom: 8px; }
        select, input[type="date"], input[type="time"] { width: 100%; padding: 10px; font-size: 0.9rem; border: 2px solid #ddd; border-radius: 6px; margin-bottom: 10px; }
        .btn { width: 100%; padding: 12px; background: #4285f4; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; margin-bottom: 10px; }
        .btn:hover { background: #3367d6; }
        .btn:disabled { background: #ccc; cursor: not-allowed; }
        #map { height: 500px; border-radius: 10px; }
        .trip-list { max-height: 400px; overflow-y: auto; }
        .trip-item { padding: 10px; margin: 5px 0; border-radius: 6px; cursor: pointer; border-left: 4px solid #4285f4; background: #f8f9fa; transition: all 0.2s; }
        .trip-item:hover { background: #e3f2fd; }
        .trip-item.selected { background: #bbdefb; border-left-color: #1565c0; }
        .trip-item.green { border-left-color: #34a853; }
        .trip-item.yellow { border-left-color: #fbbc05; }
        .trip-item.red { border-left-color: #ea4335; }
        .trip-header { display: flex; justify-content: space-between; font-weight: 600; }
        .trip-route { color: #333; }
        .trip-time { color: #666; font-size: 0.85rem; }
        .trip-meta { display: flex; gap: 10px; font-size: 0.75rem; color: #666; margin-top: 5px; }
        .path-badge { display: inline-block; padding: 2px 8px; border-radius: 10px; font-size: 0.7rem; color: white; background: #4285f4; }
        .detail-panel { background: #e8f5e9; padding: 15px; border-radius: 8px; display: none; }
        .detail-panel.visible { display: block; }
        .detail-row { display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #c8e6c9; }
        .detail-row:last-child { border-bottom: none; }
        .detail-label { color: #666; }
        .detail-value { font-weight: 600; color: #333; }
        .detail-value.green { color: #34a853; }
        .detail-value.yellow { color: #fbbc05; }
        .detail-value.red { color: #ea4335; }
        .legend { display: flex; gap: 15px; margin-bottom: 15px; flex-wrap: wrap; }
        .legend-item { display: flex; align-items: center; gap: 5px; font-size: 0.8rem; }
        .legend-color { width: 20px; height: 4px; border-radius: 2px; }
        .legend-color.green { background: #34a853; }
        .legend-color.yellow { background: #fbbc05; }
        .legend-color.red { background: #ea4335; }
        .time-inputs { display: flex; gap: 10px; }
        .time-inputs > div { flex: 1; }
        .time-inputs label { font-size: 0.75rem; color: #666; display: block; margin-bottom: 4px; }
        .no-data { text-align: center; padding: 30px; color: #999; }
        .loading { text-align: center; padding: 20px; color: #666; }
        .break-reason { background: #ffebee; color: #c62828; padding: 4px 8px; border-radius: 4px; font-size: 0.75rem; margin-top: 5px; display: inline-block; }
        .normal-band { background: #e8f5e9; padding: 10px; border-radius: 6px; margin-bottom: 10px; font-size: 0.8rem; }
        
        /* Timeline styles */
        .timeline-container { max-height: 300px; overflow-y: auto; padding: 10px 5px; }
        .timeline { position: relative; padding-left: 20px; }
        .timeline::before { content: ''; position: absolute; left: 8px; top: 0; bottom: 0; width: 2px; background: #e0e0e0; }
        .timeline-item { position: relative; padding: 8px 0 8px 15px; font-size: 0.75rem; }
        .timeline-item::before { content: ''; position: absolute; left: -16px; top: 12px; width: 10px; height: 10px; border-radius: 50%; background: #4285f4; border: 2px solid #fff; box-shadow: 0 0 0 2px #4285f4; }
        .timeline-item.break::before { background: #ea4335; box-shadow: 0 0 0 2px #ea4335; }
        .timeline-item.slow::before { background: #fbbc05; box-shadow: 0 0 0 2px #fbbc05; }
        .timeline-item.path-start::before { background: #1565C0; box-shadow: 0 0 0 3px #1565C0; width: 12px; height: 12px; left: -17px; }
        .timeline-item.path-end::before { background: #1565C0; box-shadow: 0 0 0 2px #1565C0; border-radius: 2px; }
        .timeline-time { color: #666; font-size: 0.7rem; }
        .timeline-site { font-weight: 600; color: #333; }
        .timeline-info { color: #666; font-size: 0.7rem; margin-top: 2px; }
        .timeline-break { background: #ffebee; color: #c62828; padding: 3px 6px; border-radius: 3px; font-size: 0.65rem; margin-top: 3px; display: inline-block; }
        .timeline-path-label { background: #e3f2fd; color: #1565C0; padding: 2px 6px; border-radius: 3px; font-size: 0.65rem; font-weight: bold; margin-left: 5px; }
        .normal-band-inputs { display: flex; gap: 10px; }
        .normal-band-inputs input { width: 70px; padding: 5px; text-align: center; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Route Segmentation Viewer</h1>
        <p class="subtitle">Visualize vehicle trips with path segmentation (temporal + spatial checks)</p>
        
        <div class="stat-row">
            <div class="stat"><div class="stat-value" id="statVehicles">10</div><div class="stat-label">Vehicles</div></div>
            <div class="stat"><div class="stat-value" id="statTrips">0</div><div class="stat-label">Trips in Route</div></div>
            <div class="stat"><div class="stat-value green" id="statPaths">0</div><div class="stat-label">Paths Detected</div></div>
            <div class="stat"><div class="stat-value yellow" id="statSlow">0</div><div class="stat-label">Slow Segments</div></div>
            <div class="stat"><div class="stat-value red" id="statBreaks">0</div><div class="stat-label">Path Breaks</div></div>
        </div>
        <div style="text-align:center;font-size:0.8rem;margin-top:5px;color:#666;">
            Break Types: <span id="statBreakdown"><span style="color:#ff9800;">[T]0</span> <span style="color:#9c27b0;">[S]0</span> <span style="color:#c62828;">[Both]0</span></span>
        </div>
        
        <!-- Active Filter Display -->
        <div id="activeFilter" class="panel" style="display:none; background: #e3f2fd; padding: 10px 15px;">
            <strong>Active Filter:</strong> <span id="filterInfo">-</span>
        </div>
        
        <div class="grid">
            <div class="sidebar">
                <div class="panel">
                    <h2>Controls</h2>
                    <label style="font-size:0.8rem;color:#666;">Vehicle</label>
                    <select id="vehicleSel" onchange="showVehicleInfo()">
                        <option value="">-- Select Vehicle --</option>
                    </select>
                    <div id="vehicleInfo" style="display:none;margin-top:8px;padding:8px;background:#e3f2fd;border-radius:4px;font-size:0.75rem;"></div>
                    
                    <div class="time-inputs">
                        <div>
                            <label>Start Date</label>
                            <input type="date" id="startDate">
                        </div>
                        <div>
                            <label>End Date</label>
                            <input type="date" id="endDate">
                        </div>
                    </div>
                    
                    <div class="time-inputs">
                        <div>
                            <label>Start Time</label>
                            <input type="time" id="startTime" value="00:00">
                        </div>
                        <div>
                            <label>End Time</label>
                            <input type="time" id="endTime" value="23:59">
                        </div>
                    </div>
                    
                    <button class="btn" onclick="showRoute()">Show Route</button>
                    <button class="btn" onclick="showAllTrips()" style="background:#34a853;">Show All Trips (No Filter)</button>
                    
                    <div style="margin-top:15px;padding-top:15px;border-top:1px solid #e0e0e0;">
                        <label style="font-size:0.8rem;color:#666;">Filter by Path</label>
                        <select id="pathFilter" onchange="filterByPath()">
                            <option value="all">All Paths</option>
                        </select>
                        <p style="font-size:0.7rem;color:#666;margin-top:5px;">
                            Select a path to view it in isolation on the map
                        </p>
                    </div>
                </div>
                
                <div class="panel">
                    <h2>Expected Times (Google Matrix)</h2>
                    <div style="background:#fff3e0;padding:10px;border-radius:6px;margin-bottom:10px;font-size:0.8rem;">
                        <div style="margin-bottom:8px;">
                            <strong>Status:</strong> <span id="expectedTimesStatus" style="color:#e65100;">Not loaded</span>
                        </div>
                        <div style="margin-bottom:8px;">
                            <strong>Source:</strong> <span id="expectedTimesSource">-</span>
                        </div>
                        <div style="margin-bottom:8px;">
                            <strong>Time Entries:</strong> <span id="expectedTimesCount">0</span>
                        </div>
                        <div>
                            <strong>Routes with Waypoints:</strong> <span id="expectedWaypointsCount">0</span>
                        </div>
                    </div>
                    <input type="file" id="matrixUpload" accept=".json" onchange="uploadGoogleMatrix(this)" style="display:none;">
                    <button class="btn" onclick="document.getElementById('matrixUpload').click()" style="background:#ff9800;">
                        Upload Google Matrix JSON
                    </button>
                    <p style="font-size:0.7rem;color:#666;margin-top:5px;">
                        JSON: { "time_min": {...}, "distance_km": {...}, "waypoints": {...}, "sites": [...] }
                    </p>
                    <div style="margin-top:10px;padding-top:10px;border-top:1px solid #ddd;">
                        <label style="font-size:0.75rem;color:#666;">Check Route in Matrix:</label>
                        <div style="display:flex;gap:5px;margin-top:5px;">
                            <input type="text" id="checkRouteFrom" placeholder="From (e.g. RUHSM001)" style="flex:1;padding:4px;font-size:0.75rem;">
                            <input type="text" id="checkRouteTo" placeholder="To (e.g. RUHSM002)" style="flex:1;padding:4px;font-size:0.75rem;">
                            <button onclick="checkRouteInMatrix()" style="padding:4px 8px;font-size:0.75rem;cursor:pointer;">Check</button>
                        </div>
                        <div id="checkRouteResult" style="margin-top:5px;font-size:0.75rem;color:#666;"></div>
                    </div>
                </div>
                
                <div class="panel">
                    <h2>Segmentation Parameters</h2>
                    <div class="normal-band">
                        <p style="margin-bottom:8px;font-weight:bold;">Temporal Check</p>
                        <p style="margin-bottom:8px;font-size:0.75rem;">R = observed_time / expected_time</p>
                        <div class="normal-band-inputs">
                            <div>
                                <label style="font-size:0.75rem;">r_min</label>
                                <input type="number" id="rMin" value="0.5" step="0.1" min="0">
                            </div>
                            <div>
                                <label style="font-size:0.75rem;">r_max</label>
                                <input type="number" id="rMax" value="2.0" step="0.1" min="0">
                            </div>
                        </div>
                        <p style="margin-top:5px;font-size:0.7rem;color:#666;">
                            temporal_ok = r_min &le; R &le; r_max
                        </p>
                    </div>
                    <div class="normal-band" style="margin-top:10px;">
                        <p style="margin-bottom:8px;font-weight:bold;">Spatial Check (uses Google Matrix)</p>
                        <p style="margin-bottom:8px;font-size:0.75rem;">Is current site (camera_next) reachable from path_start?</p>
                        <div class="normal-band-inputs">
                            <div style="flex:1;">
                                <label style="font-size:0.75rem;">Epsilon (meters)</label>
                                <input type="number" id="epsilonMeters" value="500" step="50" min="0" style="width:100%;">
                            </div>
                        </div>
                        <p style="margin-top:5px;font-size:0.7rem;color:#666;">
                            Checks if route exists in matrix: path_start -> current_site
                        </p>
                    </div>
                    <div style="background:#ffebee;padding:8px;border-radius:4px;margin-top:10px;font-size:0.7rem;color:#c62828;">
                        <strong>Rule:</strong> Path continues only if temporal_ok AND spatial_ok.<br>
                        Spatial failure always breaks path, even if time is normal.
                    </div>
                </div>
                
                <div class="panel">
                    <h2>Legend</h2>
                    <div class="legend" style="flex-direction: column; gap: 8px;">
                        <div style="font-weight: 600; margin-bottom: 5px;">Trip Lines:</div>
                        <div class="legend-item"><div class="legend-color green"></div> Normal (same path)</div>
                        <div class="legend-item"><div class="legend-color yellow"></div> Slow (temporal warning)</div>
                        <div class="legend-item"><div class="legend-color red"></div> Path Break</div>
                        <div style="font-weight: 600; margin: 10px 0 5px 0;">Sites (Markers):</div>
                        <div class="legend-item"><div style="width:12px;height:12px;border-radius:50%;background:#4285f4;border:2px solid #fff;"></div> Normal site</div>
                        <div class="legend-item"><div style="width:14px;height:14px;border-radius:50%;background:#ff9800;border:2px solid #e65100;"></div> TEMPORAL FAIL ([T])</div>
                        <div class="legend-item"><div style="width:14px;height:14px;border-radius:50%;background:#9c27b0;border:2px solid #6a1b9a;"></div> SPATIAL FAIL ([S])</div>
                        <div class="legend-item"><div style="width:16px;height:16px;border-radius:50%;background:#ea4335;border:2px solid #b71c1c;"></div> BOTH FAILED</div>
                        <div class="legend-item"><div style="width:13px;height:13px;border-radius:50%;background:#fbbc05;border:2px solid #f57f17;"></div> SLOW</div>
                        <div style="font-weight: 600; margin: 10px 0 5px 0;">Path Origin/Destination:</div>
                        <div class="legend-item"><div style="width:0;height:0;border-left:12px solid #1565C0;border-top:6px solid transparent;border-bottom:6px solid transparent;"></div> <span style="background:#1565C0;color:#fff;padding:1px 4px;border-radius:2px;font-size:0.7rem;margin-left:4px;">O#</span> Path Origin</div>
                        <div class="legend-item"><div style="width:12px;height:12px;background:#1565C0;"></div> <span style="background:#1565C0;color:#fff;padding:1px 4px;border-radius:2px;font-size:0.7rem;margin-left:4px;">D#</span> Path Destination</div>
                        <div style="font-weight: 600; margin: 10px 0 5px 0;">Corridor (click trip to see):</div>
                        <div class="legend-item"><div style="width:20px;height:4px;background:repeating-linear-gradient(90deg,#2196F3 0,#2196F3 5px,transparent 5px,transparent 10px);"></div> Expected corridor (Google Matrix)</div>
                        <div class="legend-item"><div style="width:12px;height:12px;border-radius:50%;background:#2196F3;border:2px solid #0D47A1;"></div> Corridor waypoint</div>
                        <div class="legend-item"><div style="width:20px;height:3px;background:#F44336;"></div> Distance to corridor (if failed)</div>
                    </div>
                    <div style="margin-top:10px;padding:8px;background:#e8f5e9;border-radius:4px;font-size:0.7rem;color:#2e7d32;">
                        <strong>Spatial Check:</strong> Current site must be reachable from path start via Google Matrix route.<br>
                        <strong>Note:</strong> Intermediate observed sites are NOT checked - only reachability of current site matters.
                    </div>
                </div>
                
                <div class="panel">
                    <h2>Trip List (click for details)</h2>
                    <div class="trip-list" id="tripList">
                        <div class="no-data">Select vehicle and click "Show Route"</div>
                    </div>
                </div>
                
                <div class="panel">
                    <h2>Path Timeline</h2>
                    <div id="pathTimeline" class="timeline-container">
                        <div class="no-data">Load a route to see timeline</div>
                    </div>
                </div>
            </div>
            
            <div class="main">
                <div class="panel">
                    <div id="map"></div>
                </div>
                
                <div class="panel detail-panel" id="detailPanel">
                    <h2>Trip Details</h2>
                    <div id="tripDetails"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
// ============ EMBEDDED DATA ============
const TRIPS = [{"plate": "640UXS", "camera_prev": "RUHSM033", "camera_next": "RUHSM033", "t_prev": "2025-08-06T09:56:08.789000", "t_next": "2025-08-06T09:56:08.789000", "obs_time_seconds": 0}, {"plate": "7733RZR", "camera_prev": "RUHSM228", "camera_next": "RUHSM228", "t_prev": "2025-07-29T17:29:15.488000", "t_next": "2025-07-30T21:58:10.011000", "obs_time_seconds": 102535}, {"plate": "7733RZR", "camera_prev": "RUHSM228", "camera_next": "RUHSM228", "t_prev": "2025-07-30T21:58:10.011000", "t_next": "2025-07-31T17:59:19.216000", "obs_time_seconds": 72069}, {"plate": "7733RZR", "camera_prev": "RUHSM228", "camera_next": "RUHSM002", "t_prev": "2025-07-31T17:59:19.216000", "t_next": "2025-08-02T20:43:18.215000", "obs_time_seconds": 182639}, {"plate": "7733RZR", "camera_prev": "RUHSM002", "camera_next": "RUHSM001", "t_prev": "2025-08-02T20:43:18.215000", "t_next": "2025-08-02T23:48:23.711000", "obs_time_seconds": 11105}, {"plate": "7733RZR", "camera_prev": "RUHSM001", "camera_next": "RUHSM002", "t_prev": "2025-08-02T23:48:23.711000", "t_next": "2025-08-03T00:07:03.674000", "obs_time_seconds": 1120}, {"plate": "7733RZR", "camera_prev": "RUHSM002", "camera_next": "RUHSM001", "t_prev": "2025-08-03T00:07:03.674000", "t_next": "2025-08-03T18:12:03.458000", "obs_time_seconds": 65100}, {"plate": "7733RZR", "camera_prev": "RUHSM001", "camera_next": "RUHSM002", "t_prev": "2025-08-03T18:12:03.458000", "t_next": "2025-08-04T17:32:02.179000", "obs_time_seconds": 83999}, {"plate": "7733RZR", "camera_prev": "RUHSM002", "camera_next": "RUHSM001", "t_prev": "2025-08-04T17:32:02.179000", "t_next": "2025-08-04T19:54:16.869000", "obs_time_seconds": 8534}, {"plate": "7733RZR", "camera_prev": "RUHSM001", "camera_next": "RUHSM002", "t_prev": "2025-08-04T19:54:16.869000", "t_next": "2025-08-04T20:07:52.142000", "obs_time_seconds": 816}, {"plate": "7733RZR", "camera_prev": "RUHSM002", "camera_next": "RUHSM002", "t_prev": "2025-08-04T20:07:52.142000", "t_next": "2025-08-04T20:07:52.245000", "obs_time_seconds": 0}, {"plate": "7733RZR", "camera_prev": "RUHSM002", "camera_next": "RUHSM002", "t_prev": "2025-08-04T20:07:52.245000", "t_next": "2025-08-05T00:01:58.624000", "obs_time_seconds": 14046}, {"plate": "7733RZR", "camera_prev": "RUHSM002", "camera_next": "RUHSM002", "t_prev": "2025-08-05T00:01:58.624000", "t_next": "2025-08-05T00:01:59.091000", "obs_time_seconds": 1}, {"plate": "7733RZR", "camera_prev": "RUHSM002", "camera_next": "RUHSM274", "t_prev": "2025-08-05T00:01:59.091000", "t_next": "2025-08-05T00:21:04.926000", "obs_time_seconds": 1145}, {"plate": "7733RZR", "camera_prev": "RUHSM274", "camera_next": "RUHSM001", "t_prev": "2025-08-05T00:21:04.926000", "t_next": "2025-08-05T19:38:25.322000", "obs_time_seconds": 69441}, {"plate": "7733RZR", "camera_prev": "RUHSM001", "camera_next": "RUHSM002", "t_prev": "2025-08-05T19:38:25.322000", "t_next": "2025-08-05T19:51:44.305000", "obs_time_seconds": 799}, {"plate": "7733RZR", "camera_prev": "RUHSM002", "camera_next": "RUHSM191", "t_prev": "2025-08-05T19:51:44.305000", "t_next": "2025-08-07T18:16:09.702000", "obs_time_seconds": 167065}, {"plate": "7733RZR", "camera_prev": "RUHSM191", "camera_next": "RUHSM191", "t_prev": "2025-08-07T18:16:09.702000", "t_next": "2025-08-07T18:16:09.702000", "obs_time_seconds": 0}, {"plate": "7733RZR", "camera_prev": "RUHSM191", "camera_next": "RUHSM191", "t_prev": "2025-08-07T18:16:09.702000", "t_next": "2025-08-07T18:16:11.903000", "obs_time_seconds": 2}, {"plate": "7733RZR", "camera_prev": "RUHSM191", "camera_next": "RUHSM191", "t_prev": "2025-08-07T18:16:11.903000", "t_next": "2025-08-07T18:16:11.903000", "obs_time_seconds": 0}, {"plate": "7733RZR", "camera_prev": "RUHSM191", "camera_next": "RUHSM191", "t_prev": "2025-08-07T18:16:11.903000", "t_next": "2025-08-07T18:16:12.769000", "obs_time_seconds": 1}, {"plate": "7733RZR", "camera_prev": "RUHSM191", "camera_next": "RUHSM191", "t_prev": "2025-08-07T18:16:12.769000", "t_next": "2025-08-07T18:16:12.769000", "obs_time_seconds": 0}, {"plate": "7733RZR", "camera_prev": "RUHSM191", "camera_next": "RUHSM191", "t_prev": "2025-08-07T18:16:12.769000", "t_next": "2025-08-07T18:16:14.569000", "obs_time_seconds": 2}, {"plate": "7733RZR", "camera_prev": "RUHSM191", "camera_next": "RUHSM191", "t_prev": "2025-08-07T18:16:14.569000", "t_next": "2025-08-07T18:16:14.569000", "obs_time_seconds": 0}, {"plate": "7733RZR", "camera_prev": "RUHSM191", "camera_next": "RUHSM192", "t_prev": "2025-08-07T18:16:14.569000", "t_next": "2025-08-07T18:19:23.376000", "obs_time_seconds": 189}, {"plate": "7733RZR", "camera_prev": "RUHSM192", "camera_next": "RUHSM192", "t_prev": "2025-08-07T18:19:23.376000", "t_next": "2025-08-07T18:19:23.376000", "obs_time_seconds": 0}, {"plate": "7733RZR", "camera_prev": "RUHSM192", "camera_next": "RUHSM003", "t_prev": "2025-08-07T18:19:23.376000", "t_next": "2025-08-07T21:51:13.883000", "obs_time_seconds": 12710}, {"plate": "7733RZR", "camera_prev": "RUHSM003", "camera_next": "RUHSM003", "t_prev": "2025-08-07T21:51:13.883000", "t_next": "2025-08-07T21:51:13.883000", "obs_time_seconds": 0}, {"plate": "7733RZR", "camera_prev": "RUHSM003", "camera_next": "RUHSM196", "t_prev": "2025-08-07T21:51:13.883000", "t_next": "2025-08-07T22:11:13.436000", "obs_time_seconds": 1200}, {"plate": "7733RZR", "camera_prev": "RUHSM196", "camera_next": "RUHSM196", "t_prev": "2025-08-07T22:11:13.436000", "t_next": "2025-08-07T22:11:13.436000", "obs_time_seconds": 0}, {"plate": "7733RZR", "camera_prev": "RUHSM196", "camera_next": "RUHSM002", "t_prev": "2025-08-07T22:11:13.436000", "t_next": "2025-08-08T14:09:05.640000", "obs_time_seconds": 57472}, {"plate": "7733RZR", "camera_prev": "RUHSM002", "camera_next": "RUHSM001", "t_prev": "2025-08-08T14:09:05.640000", "t_next": "2025-08-08T21:39:57.942000", "obs_time_seconds": 27052}, {"plate": "7733RZR", "camera_prev": "RUHSM001", "camera_next": "RUHSM002", "t_prev": "2025-08-08T21:39:57.942000", "t_next": "2025-08-09T00:21:16.437000", "obs_time_seconds": 9679}, {"plate": "7733RZR", "camera_prev": "RUHSM002", "camera_next": "RUHSM340", "t_prev": "2025-08-09T00:21:16.437000", "t_next": "2025-08-10T03:16:47.591000", "obs_time_seconds": 96931}, {"plate": "7733RZR", "camera_prev": "RUHSM340", "camera_next": "RUHSM340", "t_prev": "2025-08-10T03:16:47.591000", "t_next": "2025-08-10T03:16:47.591000", "obs_time_seconds": 0}, {"plate": "222VBJ", "camera_prev": "RUHSM002", "camera_next": "RUHSM350", "t_prev": "2025-08-04T17:03:33.465000", "t_next": "2025-08-05T16:41:47.584000", "obs_time_seconds": 85094}, {"plate": "222VBJ", "camera_prev": "RUHSM350", "camera_next": "RUHSM015", "t_prev": "2025-08-05T16:41:47.584000", "t_next": "2025-08-11T08:15:41.456000", "obs_time_seconds": 488034}, {"plate": "7281UEJ", "camera_prev": "RUHTE333", "camera_next": "RUHTE333", "t_prev": "2025-08-07T17:14:32.453000", "t_next": "2025-08-07T17:14:32.453000", "obs_time_seconds": 0}, {"plate": "7281UEJ", "camera_prev": "RUHTE333", "camera_next": "RUHSM281", "t_prev": "2025-08-07T17:14:32.453000", "t_next": "2025-08-16T17:37:42.656000", "obs_time_seconds": 778990}, {"plate": "3981XLJ", "camera_prev": "RUHSM201", "camera_next": "RUHSM201", "t_prev": "2025-08-05T16:30:03.459000", "t_next": "2025-08-05T16:30:03.459000", "obs_time_seconds": 0}, {"plate": "6948XKB", "camera_prev": "RUHSM381", "camera_next": "RUHSM381", "t_prev": "2025-08-10T10:01:01.425000", "t_next": "2025-08-13T10:32:04.814000", "obs_time_seconds": 261063}, {"plate": "6948XKB", "camera_prev": "RUHSM381", "camera_next": "RUHSM381", "t_prev": "2025-08-13T10:32:04.814000", "t_next": "2025-08-19T08:28:47.791000", "obs_time_seconds": 511003}, {"plate": "9258BDA", "camera_prev": "RUHSM241", "camera_next": "RUHSM241", "t_prev": "2025-08-05T12:23:03.208000", "t_next": "2025-08-05T12:23:03.208000", "obs_time_seconds": 0}, {"plate": "9258BDA", "camera_prev": "RUHSM241", "camera_next": "RUHSM054", "t_prev": "2025-08-05T12:23:03.208000", "t_next": "2025-08-13T20:43:18.167000", "obs_time_seconds": 721215}, {"plate": "5614DJB", "camera_prev": "RUHSM033", "camera_next": "RUHSM208", "t_prev": "2025-08-01T15:02:12.127000", "t_next": "2025-08-16T12:07:00.971000", "obs_time_seconds": 1285488}, {"plate": "6800KKR", "camera_prev": "RUHSM359", "camera_next": "RUHSM359", "t_prev": "2025-07-29T16:16:22.402000", "t_next": "2025-07-29T16:16:23.310000", "obs_time_seconds": 1}, {"plate": "6800KKR", "camera_prev": "RUHSM359", "camera_next": "RUHSM025", "t_prev": "2025-07-29T16:16:23.310000", "t_next": "2025-07-31T08:09:43.947000", "obs_time_seconds": 143600}, {"plate": "6800KKR", "camera_prev": "RUHSM025", "camera_next": "RUHSM025", "t_prev": "2025-07-31T08:09:43.947000", "t_next": "2025-07-31T08:09:44.348000", "obs_time_seconds": 1}, {"plate": "6800KKR", "camera_prev": "RUHSM025", "camera_next": "RUHSM102", "t_prev": "2025-07-31T08:09:44.348000", "t_next": "2025-07-31T18:49:13.160000", "obs_time_seconds": 38369}, {"plate": "6800KKR", "camera_prev": "RUHSM102", "camera_next": "RUHSM033", "t_prev": "2025-07-31T18:49:13.160000", "t_next": "2025-07-31T20:28:04.083000", "obs_time_seconds": 5931}, {"plate": "6800KKR", "camera_prev": "RUHSM033", "camera_next": "RUHSM033", "t_prev": "2025-07-31T20:28:04.083000", "t_next": "2025-07-31T20:28:04.945000", "obs_time_seconds": 0}, {"plate": "6800KKR", "camera_prev": "RUHSM033", "camera_next": "RUHSM025", "t_prev": "2025-07-31T20:28:04.945000", "t_next": "2025-08-02T17:40:15.311000", "obs_time_seconds": 162731}, {"plate": "6800KKR", "camera_prev": "RUHSM025", "camera_next": "RUHSM025", "t_prev": "2025-08-02T17:40:15.311000", "t_next": "2025-08-02T17:40:15.311000", "obs_time_seconds": 0}, {"plate": "6800KKR", "camera_prev": "RUHSM025", "camera_next": "RUHSM025", "t_prev": "2025-08-02T17:40:15.311000", "t_next": "2025-08-03T08:06:50.088000", "obs_time_seconds": 51995}, {"plate": "6800KKR", "camera_prev": "RUHSM025", "camera_next": "RUHSM023", "t_prev": "2025-08-03T08:06:50.088000", "t_next": "2025-08-03T16:51:37.206000", "obs_time_seconds": 31487}, {"plate": "6800KKR", "camera_prev": "RUHSM023", "camera_next": "RUHSM025", "t_prev": "2025-08-03T16:51:37.206000", "t_next": "2025-08-04T08:12:32.149000", "obs_time_seconds": 55255}, {"plate": "6800KKR", "camera_prev": "RUHSM025", "camera_next": "RUHSM052", "t_prev": "2025-08-04T08:12:32.149000", "t_next": "2025-08-04T17:00:05.251000", "obs_time_seconds": 31653}, {"plate": "6800KKR", "camera_prev": "RUHSM052", "camera_next": "RUHSM052", "t_prev": "2025-08-04T17:00:05.251000", "t_next": "2025-08-04T17:00:05.918000", "obs_time_seconds": 0}, {"plate": "6800KKR", "camera_prev": "RUHSM052", "camera_next": "RUHSM359", "t_prev": "2025-08-04T17:00:05.918000", "t_next": "2025-08-04T17:18:04.917000", "obs_time_seconds": 1079}, {"plate": "6800KKR", "camera_prev": "RUHSM359", "camera_next": "RUHSM359", "t_prev": "2025-08-04T17:18:04.917000", "t_next": "2025-08-04T17:18:04.917000", "obs_time_seconds": 0}, {"plate": "6800KKR", "camera_prev": "RUHSM359", "camera_next": "RUHSM359", "t_prev": "2025-08-04T17:18:04.917000", "t_next": "2025-08-04T17:18:05.484000", "obs_time_seconds": 1}, {"plate": "6800KKR", "camera_prev": "RUHSM359", "camera_next": "RUHSM359", "t_prev": "2025-08-04T17:18:05.484000", "t_next": "2025-08-04T17:18:05.484000", "obs_time_seconds": 0}, {"plate": "6800KKR", "camera_prev": "RUHSM359", "camera_next": "RUHSM191", "t_prev": "2025-08-04T17:18:05.484000", "t_next": "2025-08-06T16:11:09.963000", "obs_time_seconds": 168784}, {"plate": "6800KKR", "camera_prev": "RUHSM191", "camera_next": "RUHSM191", "t_prev": "2025-08-06T16:11:09.963000", "t_next": "2025-08-06T16:11:09.963000", "obs_time_seconds": 0}, {"plate": "6800KKR", "camera_prev": "RUHSM191", "camera_next": "RUHSM191", "t_prev": "2025-08-06T16:11:09.963000", "t_next": "2025-08-06T16:11:11.095000", "obs_time_seconds": 2}, {"plate": "6800KKR", "camera_prev": "RUHSM191", "camera_next": "RUHSM191", "t_prev": "2025-08-06T16:11:11.095000", "t_next": "2025-08-06T16:11:11.095000", "obs_time_seconds": 0}, {"plate": "6800KKR", "camera_prev": "RUHSM191", "camera_next": "RUHSM192", "t_prev": "2025-08-06T16:11:11.095000", "t_next": "2025-08-06T16:13:30.721000", "obs_time_seconds": 139}, {"plate": "6800KKR", "camera_prev": "RUHSM192", "camera_next": "RUHSM192", "t_prev": "2025-08-06T16:13:30.721000", "t_next": "2025-08-06T16:13:30.721000", "obs_time_seconds": 0}, {"plate": "6800KKR", "camera_prev": "RUHSM192", "camera_next": "RUHSM429", "t_prev": "2025-08-06T16:13:30.721000", "t_next": "2025-08-06T16:23:58.770000", "obs_time_seconds": 628}, {"plate": "6800KKR", "camera_prev": "RUHSM429", "camera_next": "RUHSM429", "t_prev": "2025-08-06T16:23:58.770000", "t_next": "2025-08-06T16:23:58.770000", "obs_time_seconds": 0}, {"plate": "6800KKR", "camera_prev": "RUHSM429", "camera_next": "RUHSM025", "t_prev": "2025-08-06T16:23:58.770000", "t_next": "2025-08-07T08:04:33.380000", "obs_time_seconds": 56435}, {"plate": "6800KKR", "camera_prev": "RUHSM025", "camera_next": "RUHSM032", "t_prev": "2025-08-07T08:04:33.380000", "t_next": "2025-08-07T08:10:47.319000", "obs_time_seconds": 374}, {"plate": "6800KKR", "camera_prev": "RUHSM032", "camera_next": "RUHSM052", "t_prev": "2025-08-07T08:10:47.319000", "t_next": "2025-08-07T13:49:28.839000", "obs_time_seconds": 20321}, {"plate": "6800KKR", "camera_prev": "RUHSM052", "camera_next": "RUHSM033", "t_prev": "2025-08-07T13:49:28.839000", "t_next": "2025-08-07T14:43:33.320000", "obs_time_seconds": 3245}, {"plate": "6800KKR", "camera_prev": "RUHSM033", "camera_next": "RUHSM033", "t_prev": "2025-08-07T14:43:33.320000", "t_next": "2025-08-07T14:43:33.320000", "obs_time_seconds": 0}, {"plate": "590EJ", "camera_prev": "RUHTE309", "camera_next": "RUHSM053", "t_prev": "2025-08-06T06:18:49.633000", "t_next": "2025-08-09T03:26:13.988000", "obs_time_seconds": 248844}, {"plate": "590EJ", "camera_prev": "RUHSM053", "camera_next": "RUHSM059", "t_prev": "2025-08-09T03:26:13.988000", "t_next": "2025-08-11T08:46:01.769000", "obs_time_seconds": 191988}, {"plate": "590EJ", "camera_prev": "RUHSM059", "camera_next": "RUHSM456", "t_prev": "2025-08-11T08:46:01.769000", "t_next": "2025-08-19T16:40:39.256000", "obs_time_seconds": 719678}];

const VEHICLES = ["222VBJ", "3981XLJ", "5614DJB", "590EJ", "640UXS", "6800KKR", "6948XKB", "7281UEJ", "7733RZR", "9258BDA"];

// Sites with coordinates (from google_matrix)
const SITES = {"RUHSM001":{"lat":24.7403322023658,"lon":46.6273981332779,"dir":"S"},"RUHSM002":{"lat":24.740427194217,"lon":46.6274785995483,"dir":"N"},"RUHSM003":{"lat":24.7546965432207,"lon":46.6325774788857,"dir":"E"},"RUHSM007":{"lat":24.6726265911391,"lon":46.656776368618,"dir":"S"},"RUHSM009":{"lat":24.7209740445557,"lon":46.6058734059334,"dir":"N"},"RUHSM012":{"lat":24.6483701639916,"lon":46.7946767807007,"dir":"N"},"RUHSM015":{"lat":24.5439855825558,"lon":46.872533261776,"dir":"S"},"RUHSM018":{"lat":24.8287062928303,"lon":46.6193702816963,"dir":"E"},"RUHSM019":{"lat":24.8178075375809,"lon":46.6184422373772,"dir":"S"},"RUHSM022":{"lat":24.670488879256,"lon":46.6602820158005,"dir":"N"},"RUHSM023":{"lat":24.780546768419,"lon":46.7285308241844,"dir":"N"},"RUHSM024":{"lat":24.6799116099266,"lon":46.6544723510742,"dir":"S"},"RUHSM025":{"lat":24.7649189230075,"lon":46.6561299562454,"dir":"W"},"RUHSM026":{"lat":24.7731896590511,"lon":46.7319613695145,"dir":"S"},"RUHSM027":{"lat":24.6750541016666,"lon":46.6531071066856,"dir":"E"},"RUHSM029":{"lat":24.9694129976553,"lon":46.7820569872856,"dir":"N"},"RUHSM030":{"lat":25.0012034832327,"lon":46.7709928750992,"dir":"S"},"RUHSM032":{"lat":24.7120199687664,"lon":46.6719147562981,"dir":"S"},"RUHSM033":{"lat":24.7897540511277,"lon":46.7158091068268,"dir":"E"},"RUHSM034":{"lat":24.6755122958506,"lon":46.6905936598778,"dir":"N"},"RUHSM035":{"lat":24.6203516108267,"lon":46.5742367506027,"dir":"E"},"RUHSM038":{"lat":24.6846274081011,"lon":46.7023712396622,"dir":"W"},"RUHSM042":{"lat":24.740704875449,"lon":46.5987414121628,"dir":"W"},"RUHSM044":{"lat":24.8400178982926,"lon":46.6072306036949,"dir":"S"},"RUHSM045":{"lat":24.6261962301252,"lon":46.7836314439774,"dir":"W"},"RUHSM046":{"lat":24.5856708282881,"lon":46.6952633857727,"dir":"E"},"RUHSM049":{"lat":24.8066959557292,"lon":46.7554226517677,"dir":"W"},"RUHSM051":{"lat":24.5581848394885,"lon":46.6767024993897,"dir":"E"},"RUHSM052":{"lat":24.7243240497979,"lon":46.6658690571785,"dir":"N"},"RUHSM053":{"lat":24.6729043824091,"lon":46.6916853189468,"dir":"S"},"RUHSM054":{"lat":24.6123632798959,"lon":46.7067539691925,"dir":"S"},"RUHSM055":{"lat":24.6110781730948,"lon":46.707022190094,"dir":"N"},"RUHSM057":{"lat":24.6656945509571,"lon":46.6192603111267,"dir":"E"},"RUHSM059":{"lat":24.831956030886,"lon":46.8484577536583,"dir":"S"},"RUHSM060":{"lat":24.8321897210297,"lon":46.7234346270561,"dir":"S"},"RUHSM062":{"lat":24.7980377711983,"lon":46.569601893425,"dir":"W"},"RUHSM069":{"lat":24.56560566558,"lon":46.6250592470169,"dir":"E"},"RUHSM070":{"lat":24.6942463632656,"lon":46.5634649991989,"dir":"S"},"RUHSM071":{"lat":24.6711544395348,"lon":46.6223931312561,"dir":"N"},"RUHSM072":{"lat":24.6707963331305,"lon":46.6222590208054,"dir":"S"},"RUHSM073":{"lat":24.6870447823229,"lon":46.6315904259682,"dir":"W"},"RUHSM074":{"lat":24.6869545710959,"lon":46.6317647695541,"dir":"E"},"RUHSM077":{"lat":24.8111586340332,"lon":46.7348715662956,"dir":"N"},"RUHSM078":{"lat":24.8110612436613,"lon":46.7346113920212,"dir":"S"},"RUHSM079":{"lat":24.5588531422709,"lon":46.6225674748421,"dir":"E"},"RUHSM080":{"lat":24.5589824415937,"lon":46.622556746006,"dir":"W"},"RUHSM093":{"lat":24.8325232108086,"lon":46.8203857541084,"dir":"W"},"RUHSM095":{"lat":24.7800816178938,"lon":46.8530228734016,"dir":"E"},"RUHSM096":{"lat":24.5348626583046,"lon":46.6983264684677,"dir":"N"},"RUHSM097":{"lat":24.598323749187,"lon":46.7443531751633,"dir":"S"},"RUHSM098":{"lat":24.8195992645787,"lon":46.8459257483482,"dir":"N"},"RUHSM100":{"lat":24.5686573528817,"lon":46.8897798657417,"dir":"S"},"RUHSM102":{"lat":24.7352066774981,"lon":46.6819301247597,"dir":"E"},"RUHSM106":{"lat":24.7087793016666,"lon":46.7659583687782,"dir":"N"},"RUHSM110":{"lat":24.8409306555311,"lon":46.5533074736595,"dir":"S"},"RUHSM111":{"lat":24.8410231157739,"lon":46.5536212921143,"dir":"N"},"RUHSM112":{"lat":24.5972800762424,"lon":46.6084000468254,"dir":"W"},"RUHSM113":{"lat":24.5971435038554,"lon":46.6084751486778,"dir":"E"},"RUHSM114":{"lat":24.5475208005664,"lon":46.7195722460747,"dir":"W"},"RUHSM116":{"lat":24.9070265631544,"lon":46.9199708104134,"dir":"W"},"RUHSM117":{"lat":24.5381879590055,"lon":46.6897889971733,"dir":"S"},"RUHSM118":{"lat":24.5382806827733,"lon":46.6898936033249,"dir":"N"},"RUHSM121":{"lat":24.6462394879027,"lon":46.6858944296837,"dir":"E"},"RUHSM122":{"lat":24.7958463762615,"lon":46.7296761274338,"dir":"W"},"RUHSM125":{"lat":24.771906272745,"lon":46.732605099678,"dir":"S"},"RUHSM128":{"lat":24.6981526522312,"lon":46.6789072751999,"dir":"S"},"RUHSM129":{"lat":24.6876372637067,"lon":46.7106726765633,"dir":"E"},"RUHSM130":{"lat":24.6636397195435,"lon":46.7306765913963,"dir":"W"},"RUHSM131":{"lat":24.6634934669944,"lon":46.7308187484741,"dir":"E"},"RUHSM136":{"lat":24.620424801656,"lon":46.5808054804802,"dir":"N"},"RUHSM140":{"lat":24.8769760481679,"lon":46.8059206008911,"dir":"S"},"RUHSM141":{"lat":24.8769687507318,"lon":46.8060520291329,"dir":"N"},"RUHSM142":{"lat":24.5674108328895,"lon":46.655505001545,"dir":"W"},"RUHSM144":{"lat":24.5638614614901,"lon":46.717287003994,"dir":"E"},"RUHSM145":{"lat":24.5687663130558,"lon":46.8898630142212,"dir":"W"},"RUHSM147":{"lat":24.6038597752923,"lon":46.6194561123848,"dir":"E"},"RUHSM148":{"lat":24.6040012164286,"lon":46.6193461418152,"dir":"W"},"RUHSM152":{"lat":24.6854562001529,"lon":46.6520261764526,"dir":"S"},"RUHSM153":{"lat":24.6855219810628,"lon":46.6522246599197,"dir":"N"},"RUHSM156":{"lat":24.7259342868167,"lon":46.7802920937538,"dir":"E"},"RUHSM157":{"lat":24.6409759484262,"lon":46.8291538953781,"dir":"E"},"RUHSM160":{"lat":24.6086054881289,"lon":46.7729669809341,"dir":"N"},"RUHSM161":{"lat":24.6336106991616,"lon":46.8119421601295,"dir":"E"},"RUHSM164":{"lat":24.5796291806517,"lon":46.5517866611481,"dir":"E"},"RUHSM165":{"lat":24.5797877232525,"lon":46.5518108010292,"dir":"W"},"RUHSM168":{"lat":24.5844927893916,"lon":46.7547172307968,"dir":"E"},"RUHSM169":{"lat":24.5982237727608,"lon":46.6173076629639,"dir":"N"},"RUHSM170":{"lat":24.5981359902433,"lon":46.6171762347221,"dir":"S"},"RUHSM173":{"lat":24.7946969705971,"lon":46.6560655832291,"dir":"N"},"RUHSM174":{"lat":24.5079388888788,"lon":46.9285324215889,"dir":"S"},"RUHSM175":{"lat":24.5081024122122,"lon":46.9286692142487,"dir":"N"},"RUHSM178":{"lat":25.0159432570743,"lon":46.7664411664009,"dir":"N"},"RUHSM179":{"lat":25.0158897994536,"lon":46.7662614583969,"dir":"S"},"RUHSM180":{"lat":24.66748117972,"lon":46.7952159047127,"dir":"W"},"RUHSM181":{"lat":24.6672764432188,"lon":46.7952185869217,"dir":"E"},"RUHSM182":{"lat":24.6433261861909,"lon":46.8339711427689,"dir":"S"},"RUHSM187":{"lat":24.642784983054,"lon":46.7355394363403,"dir":"N"},"RUHSM188":{"lat":24.6011674755442,"lon":46.6398543119431,"dir":"N"},"RUHSM189":{"lat":24.6013016369983,"lon":46.6397336125374,"dir":"S"},"RUHSM190":{"lat":24.6326745415304,"lon":46.5654820203781,"dir":"W"},"RUHSM191":{"lat":24.8129651971553,"lon":46.6760292649269,"dir":"S"},"RUHSM192":{"lat":24.8127826050202,"lon":46.6761177778244,"dir":"N"},"RUHSM195":{"lat":24.7299152397197,"lon":46.8647655844688,"dir":"S"},"RUHSM196":{"lat":24.7999978581173,"lon":46.6526859998703,"dir":"E"},"RUHSM198":{"lat":24.7694781484828,"lon":46.6684493422508,"dir":"S"},"RUHSM201":{"lat":24.615255335399,"lon":46.7573323845863,"dir":"S"},"RUHSM207":{"lat":24.7444197548951,"lon":46.6082498431206,"dir":"E"},"RUHSM208":{"lat":24.823774152058,"lon":46.7285388708115,"dir":"N"},"RUHSM209":{"lat":24.8236621627272,"lon":46.7282545566559,"dir":"S"},"RUHSM210":{"lat":24.7432407032976,"lon":46.8001833558083,"dir":"S"},"RUHSM211":{"lat":24.7433162129597,"lon":46.8002933263779,"dir":"N"},"RUHSM212":{"lat":24.6725825464765,"lon":46.8299263715744,"dir":"N"},"RUHSM213":{"lat":24.6725337944213,"lon":46.8298190832138,"dir":"S"},"RUHSM216":{"lat":24.5872366876198,"lon":46.5884765982628,"dir":"W"},"RUHSM217":{"lat":24.5871147808519,"lon":46.5885651111603,"dir":"E"},"RUHSM218":{"lat":24.7088894173431,"lon":46.8437933921814,"dir":"W"},"RUHSM221":{"lat":24.6402519488123,"lon":46.75511687994,"dir":"E"},"RUHSM224":{"lat":24.7455602489784,"lon":46.8242803215981,"dir":"N"},"RUHSM225":{"lat":24.7454847342479,"lon":46.8241676688194,"dir":"S"},"RUHSM226":{"lat":24.7641928838335,"lon":46.8337565660477,"dir":"N"},"RUHSM227":{"lat":24.764122238671,"lon":46.8336492776871,"dir":"S"},"RUHSM228":{"lat":24.7395185293973,"lon":46.5959626436234,"dir":"W"},"RUHSM232":{"lat":24.4701528666928,"lon":46.612468957901,"dir":"E"},"RUHSM233":{"lat":24.5476209553064,"lon":46.6873374581337,"dir":"E"},"RUHSM234":{"lat":24.5477331800292,"lon":46.6874313354492,"dir":"W"},"RUHSM235":{"lat":24.6672178504822,"lon":46.7845594882965,"dir":"W"},"RUHSM238":{"lat":24.4949618404793,"lon":46.9437834620476,"dir":"S"},"RUHSM239":{"lat":24.4951033915724,"lon":46.9439175724983,"dir":"N"},"RUHSM240":{"lat":24.6486919902838,"lon":46.7140683531761,"dir":"S"},"RUHSM241":{"lat":24.6487358708835,"lon":46.7141970992088,"dir":"N"},"RUHSM242":{"lat":24.5620708697593,"lon":46.5307635068893,"dir":"S"},"RUHSM243":{"lat":24.5622074829673,"lon":46.5307849645615,"dir":"N"},"RUHSM244":{"lat":24.5925682421353,"lon":46.5811836719513,"dir":"N"},"RUHSM245":{"lat":24.592451165573,"lon":46.5809771418572,"dir":"S"},"RUHSM246":{"lat":24.5606828008027,"lon":46.5485760569573,"dir":"S"},"RUHSM247":{"lat":24.5608462580163,"lon":46.5485733747482,"dir":"N"},"RUHSM248":{"lat":24.5591532055241,"lon":46.5682715177536,"dir":"S"},"RUHSM249":{"lat":24.5593190901152,"lon":46.5683010220528,"dir":"N"},"RUHSM250":{"lat":24.7962287009035,"lon":46.7782375216484,"dir":"E"},"RUHSM251":{"lat":24.7963431075156,"lon":46.778157055378,"dir":"W"},"RUHSM252":{"lat":24.6506762784333,"lon":46.7848706245422,"dir":"W"},"RUHSM253":{"lat":24.6505348901065,"lon":46.7849349975586,"dir":"E"},"RUHSM254":{"lat":24.6017820953835,"lon":46.6995683312416,"dir":"E"},"RUHSM255":{"lat":24.6019428426154,"lon":46.6995227336884,"dir":"W"},"RUHSM257":{"lat":24.5417677210066,"lon":46.6960680484772,"dir":"N"},"RUHSM258":{"lat":24.5416505969815,"lon":46.6959768533707,"dir":"S"},"RUHSM260":{"lat":24.6184495728811,"lon":46.5350738167763,"dir":"W"},"RUHSM261":{"lat":24.8220580564739,"lon":46.8324986100197,"dir":"W"},"RUHSM262":{"lat":24.7625659273025,"lon":46.8108746409416,"dir":"N"},"RUHSM263":{"lat":24.7625074578522,"lon":46.810756623745,"dir":"S"},"RUHSM265":{"lat":24.6282468000288,"lon":46.5544849634171,"dir":"S"},"RUHSM266":{"lat":24.621812214839,"lon":46.5321287512779,"dir":"S"},"RUHSM267":{"lat":24.8855940582138,"lon":46.7199504375458,"dir":"N"},"RUHSM268":{"lat":24.5686427243791,"lon":46.5279042720795,"dir":"S"},"RUHSM269":{"lat":24.56878873,"lon":46.52792484,"dir":"N"},"RUHSM270":{"lat":24.6423900305582,"lon":46.7355823516846,"dir":"S"},"RUHSM271":{"lat":24.7657883617786,"lon":46.7543041706085,"dir":"E"},"RUHSM274":{"lat":24.8155925940606,"lon":46.6353213787079,"dir":"E"},"RUHSM275":{"lat":24.8347697001099,"lon":46.7905327677727,"dir":"N"},"RUHSM276":{"lat":24.8346966545502,"lon":46.7903396487236,"dir":"S"},"RUHSM278":{"lat":24.6766160926836,"lon":46.8499436974526,"dir":"N"},"RUHSM279":{"lat":24.6765527121673,"lon":46.8497881293297,"dir":"S"},"RUHSM280":{"lat":24.8184475122469,"lon":46.8023881316185,"dir":"N"},"RUHSM281":{"lat":24.8183549901527,"lon":46.8022164702416,"dir":"S"},"RUHSM286":{"lat":24.6720829180904,"lon":46.5581783652306,"dir":"S"},"RUHSM287":{"lat":24.6433213464037,"lon":46.5461325645447,"dir":"W"},"RUHSM290":{"lat":24.6155723237174,"lon":46.7154604196549,"dir":"N"},"RUHSM291":{"lat":24.6155430622212,"lon":46.7153263092041,"dir":"S"},"RUHSM292":{"lat":24.6999315543658,"lon":46.7230913043022,"dir":"N"},"RUHSM296":{"lat":24.7779751316449,"lon":46.7809116840363,"dir":"W"},"RUHSM304":{"lat":24.7020076530006,"lon":46.6487458348274,"dir":"E"},"RUHSM305":{"lat":24.8371752096259,"lon":46.6561380028725,"dir":"S"},"RUHSM306":{"lat":24.7059527461551,"lon":46.6575327515602,"dir":"W"},"RUHSM308":{"lat":24.6226168155053,"lon":46.5494531393051,"dir":"W"},"RUHSM312":{"lat":25.0212345764591,"lon":46.6135954856873,"dir":"E"},"RUHSM313":{"lat":25.0214120108395,"lon":46.6135391592979,"dir":"W"},"RUHSM315":{"lat":24.5423701171962,"lon":46.7042890191078,"dir":"S"},"RUHSM316":{"lat":24.5422652060434,"lon":46.7044472694397,"dir":"N"},"RUHSM325":{"lat":24.5786754649118,"lon":46.741595864296,"dir":"E"},"RUHSM326":{"lat":24.5788146164014,"lon":46.7415341734886,"dir":"W"},"RUHSM336":{"lat":24.9067906009768,"lon":46.977547109127,"dir":"W"},"RUHSM337":{"lat":24.9066907889091,"lon":46.9776409864426,"dir":"E"},"RUHSM340":{"lat":24.9288681103428,"lon":46.7166620492935,"dir":"S"},"RUHSM345":{"lat":24.6962883540936,"lon":46.8563032150269,"dir":"S"},"RUHSM350":{"lat":24.7642247877842,"lon":46.6931256651878,"dir":"N"},"RUHSM358":{"lat":24.7884113106178,"lon":46.6334706544876,"dir":"N"},"RUHSM359":{"lat":24.7553980581506,"lon":46.6502237319946,"dir":"N"},"RUHSM360":{"lat":24.5945431171705,"lon":46.7034012079239,"dir":"S"},"RUHSM368":{"lat":24.6352978544649,"lon":46.6226264834404,"dir":"W"},"RUHSM369":{"lat":24.6351466822632,"lon":46.6227042675018,"dir":"E"},"RUHSM380":{"lat":24.841429643951,"lon":46.8063712120056,"dir":"N"},"RUHSM381":{"lat":24.8413541914201,"lon":46.8061780929566,"dir":"S"},"RUHSM396":{"lat":24.3294130168959,"lon":46.8735444545746,"dir":"S"},"RUHSM397":{"lat":24.3294912044514,"lon":46.8738126754761,"dir":"N"},"RUHSM432":{"lat":24.8907017220214,"lon":46.8079134821892,"dir":"N"},"RUHSM433":{"lat":24.8907309072334,"lon":46.8077713251114,"dir":"S"},"RUHSM451":{"lat":24.6446348177146,"lon":46.6930103302002,"dir":"S"},"RUHSM452":{"lat":24.6443911519871,"lon":46.6931363940239,"dir":"N"},"RUHSM455":{"lat":24.5519562952254,"lon":46.6132870316506,"dir":"E"},"RUHSM456":{"lat":24.5520953694537,"lon":46.6132897138596,"dir":"W"},"RUHSM458":{"lat":24.8195554339359,"lon":46.7520859837532,"dir":"N"},"RUHSM459":{"lat":24.5847343246958,"lon":46.6552877426148,"dir":"E"},"RUHSM460":{"lat":24.5848514020341,"lon":46.6554942727089,"dir":"W"},"RUHSM467":{"lat":24.6270665833972,"lon":46.5201660990715,"dir":"W"},"RUHSM468":{"lat":24.6266960872229,"lon":46.5199971199036,"dir":"E"},"RUHSM525":{"lat":25.012863802906,"lon":46.6809833049774,"dir":"S"},"RUHSM526":{"lat":25.0128613773877,"lon":46.6811040043831,"dir":"N"},"RUHSM530":{"lat":24.6072056361663,"lon":46.660198867321,"dir":"N"},"RUHSM531":{"lat":24.6073153598916,"lon":46.6601157188416,"dir":"S"},"RUHSM540":{"lat":24.625494022299,"lon":46.6844916343689,"dir":"W"},"RUHSM541":{"lat":24.6253794264026,"lon":46.6844862699509,"dir":"E"},"RUHSM542":{"lat":24.9065182947864,"lon":46.6434082388878,"dir":"W"},"RUHSM543":{"lat":24.9064526219956,"lon":46.6431882977486,"dir":"E"},"RUHSM546":{"lat":24.7902436855305,"lon":46.8545919656754,"dir":"W"},"RUHSM547":{"lat":24.7901097595178,"lon":46.8544578552246,"dir":"E"},"RUHSM555":{"lat":24.8721018851866,"lon":46.6604670882225,"dir":"N"},"RUHSM556":{"lat":24.8720069697679,"lon":46.6602981090546,"dir":"S"},"RUHSM559":{"lat":24.5441977464061,"lon":46.8807810544968,"dir":"E"},"RUHSM560":{"lat":24.5442490050968,"lon":46.8806630373001,"dir":"W"},"RUHSM576":{"lat":24.856359089514,"lon":46.7374357581139,"dir":"N"},"RUHSM577":{"lat":24.8563639531407,"lon":46.7373177409172,"dir":"S"},"RUHTE304":{"lat":24.5842414097686,"lon":46.7537328600884,"dir":"W"},"RUHTE305":{"lat":24.5903877908723,"lon":46.7684072256088,"dir":"E"},"RUHTE306":{"lat":24.5905317003463,"lon":46.7683106660843,"dir":"W"},"RUHTE309":{"lat":24.6524997358911,"lon":46.837058365345,"dir":"S"},"RUHTE311":{"lat":24.6064936135113,"lon":46.7306846380234,"dir":"N"},"RUHTE312":{"lat":24.7251035336184,"lon":46.846419274807,"dir":"S"},"RUHTE313":{"lat":24.7251863658135,"lon":46.8465641140938,"dir":"N"},"RUHTE315":{"lat":24.6141750770559,"lon":46.8200236558914,"dir":"S"},"RUHTE316":{"lat":24.6142896999613,"lon":46.8201014399529,"dir":"N"},"RUHTE317":{"lat":24.6667255799159,"lon":46.5599271655083,"dir":"N"},"RUHTE318":{"lat":24.8014076405187,"lon":46.7830601334572,"dir":"N"},"RUHTE319":{"lat":24.8013516499019,"lon":46.7829152941704,"dir":"S"},"RUHTE320":{"lat":24.5822390462004,"lon":46.800848543644,"dir":"E"},"RUHTE321":{"lat":24.5821049042435,"lon":46.8009102344513,"dir":"W"},"RUHTE325":{"lat":24.8405124734256,"lon":46.6326740384102,"dir":"S"},"RUHTE326":{"lat":24.84056807361,"lon":46.632821559906,"dir":"N"},"RUHTE327":{"lat":25.0019957881179,"lon":46.5249887108803,"dir":"S"},"RUHTE329":{"lat":24.7977018282743,"lon":46.6402861475945,"dir":"E"},"RUHTE330":{"lat":24.7980061369433,"lon":46.6402700543404,"dir":"W"},"RUHTE331":{"lat":24.5881342040044,"lon":46.6691654920578,"dir":"W"},"RUHTE332":{"lat":24.6438528149027,"lon":46.5914431214333,"dir":"W"},"RUHTE333":{"lat":24.643733326556,"lon":46.5916550159454,"dir":"E"},"RUHTE334":{"lat":24.6315966143575,"lon":46.8755158782005,"dir":"N"},"RUHTE335":{"lat":24.6308021511539,"lon":46.8756607174873,"dir":"S"},"RUHTE336":{"lat":24.9054087603904,"lon":46.5742716193199,"dir":"N"},"RUHTE337":{"lat":24.9053406696483,"lon":46.5741160511971,"dir":"S"},"RUHSM429":{"lat":24.7897,"lon":46.6761,"dir":"E"}};

// Expected times will be loaded from external file or use fallback estimates
let EXPECTED_TIMES = {};
let EXPECTED_WAYPOINTS = {}; // Store waypoints: "SITE_A_SITE_B" -> [siteId1, siteId2, ...]
let EXPECTED_DISTANCES = {}; // Store distances: "SITE_A_SITE_B" -> km
let expectedTimesLoaded = false;

// ============ MAP VARIABLES ============
let map, markers = [], polylines = [];
let currentRoute = [];
let directionsService = null;
let corridorPolyline = null;  // For displaying expected corridor from Google Matrix
let corridorMarkers = [];     // Waypoint markers on the corridor

// ============ INITIALIZATION ============
function initMap() {
    map = new google.maps.Map(document.getElementById('map'), {
        center: { lat: 24.7136, lng: 46.6753 },
        zoom: 10,
        styles: [
            { featureType: 'poi', stylers: [{ visibility: 'off' }] },
            { featureType: 'transit', stylers: [{ visibility: 'off' }] }
        ]
    });
    
    // Initialize DirectionsService for road-snapped routes
    directionsService = new google.maps.DirectionsService();
    
    // Populate vehicle dropdown
    const sel = document.getElementById('vehicleSel');
    VEHICLES.forEach(v => {
        const opt = document.createElement('option');
        opt.value = v;
        opt.textContent = v;
        sel.appendChild(opt);
    });
    
    // Set default dates (from first to last trip date)
    const allDates = TRIPS.map(t => t.t_prev.split('T')[0]).sort();
    const firstDate = allDates[0];
    const lastDate = allDates[allDates.length - 1];
    document.getElementById('startDate').value = firstDate;
    document.getElementById('endDate').value = lastDate;
    
    // Load expected times
    loadExpectedTimes();
    
    console.log('Map initialized with', TRIPS.length, 'trips and', Object.keys(SITES).length, 'sites');
}

// Load expected times from google_matrix file
async function loadExpectedTimes() {
    updateExpectedTimesUI('Loading...', 'Auto-loading google_matrix (2).json', 0, '#2196f3');
    
    try {
        // URL encode the filename (spaces and parentheses)
        const response = await fetch(encodeURI('google_matrix (2).json'));
        if (!response.ok) {
            throw new Error('HTTP ' + response.status);
        }
        const data = await response.json();
        
        console.log('Google Matrix loaded, sites:', data.sites?.length, 'time_min keys:', Object.keys(data.time_min || {}).length);
        processGoogleMatrix(data, 'google_matrix (2).json (auto-loaded)');
        
    } catch (e) {
        console.warn('Could not load google_matrix, using distance-based estimates:', e);
        expectedTimesLoaded = false;
        updateExpectedTimesUI('Not loaded - using distance estimates', 'None (upload a file)', 0, '#e65100');
    }
}

// Process Google Matrix data
function processGoogleMatrix(data, sourceName) {
    EXPECTED_TIMES = {}; // Reset
    EXPECTED_WAYPOINTS = {}; // Reset
    EXPECTED_DISTANCES = {}; // Reset
    
    // Build site_id to index mapping
    const siteIdToIdx = {};
    const sites = data.sites || [];
    sites.forEach((s, i) => siteIdToIdx[s.site_id] = i);
    
    // Also build index to site_id mapping
    const idxToSiteId = {};
    sites.forEach((s, i) => idxToSiteId[i] = s.site_id);
    
    // Convert index-based keys to site_id based - TIME
    const timeMin = data.time_min || {};
    let convertedCount = 0;
    for (const key in timeMin) {
        const parts = key.split('_');
        if (parts.length === 2) {
            const i = parseInt(parts[0]);
            const j = parseInt(parts[1]);
            if (i < sites.length && j < sites.length && sites[i] && sites[j]) {
                const siteKey = sites[i].site_id + '_' + sites[j].site_id;
                EXPECTED_TIMES[siteKey] = timeMin[key];
                convertedCount++;
                // Debug: log first few conversions
                if (convertedCount <= 3) {
                    console.log('Converted time:', key, '->', siteKey, '=', timeMin[key], 'min');
                }
            }
        }
    }
    console.log('Total time entries converted:', convertedCount);
    
    // Convert index-based keys to site_id based - DISTANCE
    const distKm = data.distance_km || {};
    for (const key in distKm) {
        const parts = key.split('_');
        if (parts.length === 2) {
            const i = parseInt(parts[0]);
            const j = parseInt(parts[1]);
            if (i < sites.length && j < sites.length) {
                const siteKey = sites[i].site_id + '_' + sites[j].site_id;
                EXPECTED_DISTANCES[siteKey] = distKm[key];
            }
        }
    }
    
    // Convert waypoints - they are stored as arrays of site indices
    const waypoints = data.waypoints || {};
    let wpCount = 0;
    for (const key in waypoints) {
        const parts = key.split('_');
        if (parts.length === 2) {
            const i = parseInt(parts[0]);
            const j = parseInt(parts[1]);
            if (i < sites.length && j < sites.length) {
                const siteKey = sites[i].site_id + '_' + sites[j].site_id;
                // Convert waypoint indices to site IDs
                const wpIndices = waypoints[key] || [];
                if (wpIndices.length > 0) {
                    EXPECTED_WAYPOINTS[siteKey] = wpIndices.map(idx => idxToSiteId[idx]).filter(Boolean);
                    wpCount++;
                }
            }
        }
    }
    
    expectedTimesLoaded = true;
    const count = Object.keys(EXPECTED_TIMES).length;
    const distCount = Object.keys(EXPECTED_DISTANCES).length;
    console.log('Loaded', count, 'expected times,', distCount, 'distances,', wpCount, 'routes with waypoints from', sourceName);
    
    updateExpectedTimesUI('Loaded', sourceName, count, '#4caf50', wpCount);
}

// Check if a specific route exists in the matrix
function checkRouteInMatrix() {
    const from = document.getElementById('checkRouteFrom').value.trim().toUpperCase();
    const to = document.getElementById('checkRouteTo').value.trim().toUpperCase();
    const resultDiv = document.getElementById('checkRouteResult');
    
    if (!from || !to) {
        resultDiv.innerHTML = '<span style="color:#f44336;">Enter both From and To site IDs</span>';
        return;
    }
    
    const key = from + '_' + to;
    const time = EXPECTED_TIMES[key];
    const dist = EXPECTED_DISTANCES[key];
    const waypoints = EXPECTED_WAYPOINTS[key];
    
    let html = '';
    if (time !== undefined) {
        html += `<div style="color:#4caf50;"><strong>${key}</strong>: ${time.toFixed(2)} min`;
        if (dist) html += `, ${dist.toFixed(2)} km`;
        html += '</div>';
        if (waypoints && waypoints.length > 0) {
            html += `<div style="color:#1565c0;font-size:0.7rem;">Waypoints: ${waypoints.join('  ')}</div>`;
        }
    } else {
        html += `<span style="color:#f44336;"><strong>${key}</strong>: NOT FOUND in matrix</span>`;
        // Check if sites exist
        const fromExists = SITES[from];
        const toExists = SITES[to];
        if (!fromExists) html += `<div style="color:#ff9800;font-size:0.7rem;">Site ${from} not in SITES</div>`;
        if (!toExists) html += `<div style="color:#ff9800;font-size:0.7rem;">Site ${to} not in SITES</div>`;
        
        // Show total entries for debugging
        html += `<div style="color:#666;font-size:0.7rem;">Total EXPECTED_TIMES entries: ${Object.keys(EXPECTED_TIMES).length}</div>`;
    }
    
    resultDiv.innerHTML = html;
}

// Upload Google Matrix JSON
function uploadGoogleMatrix(input) {
    const file = input.files[0];
    if (!file) return;
    
    updateExpectedTimesUI('Reading file...', file.name, 0, '#2196f3');
    
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const data = JSON.parse(e.target.result);
            
            // Validate structure
            if (!data.time_min) {
                alert('Invalid file: missing "time_min" field');
                updateExpectedTimesUI('Error - invalid file', file.name, 0, '#f44336');
                return;
            }
            if (!data.sites || !Array.isArray(data.sites)) {
                alert('Invalid file: missing or invalid "sites" array');
                updateExpectedTimesUI('Error - invalid file', file.name, 0, '#f44336');
                return;
            }
            
            processGoogleMatrix(data, file.name + ' (uploaded)');
            alert('Loaded ' + Object.keys(EXPECTED_TIMES).length + ' expected times from ' + file.name);
            
        } catch (err) {
            alert('Error parsing JSON: ' + err.message);
            updateExpectedTimesUI('Error - ' + err.message, file.name, 0, '#f44336');
        }
    };
    reader.readAsText(file);
    input.value = '';
}

// Update Expected Times UI
function updateExpectedTimesUI(status, source, count, color, wpCount = 0) {
    const statusEl = document.getElementById('expectedTimesStatus');
    const sourceEl = document.getElementById('expectedTimesSource');
    const countEl = document.getElementById('expectedTimesCount');
    const wpCountEl = document.getElementById('expectedWaypointsCount');
    
    if (statusEl) {
        statusEl.textContent = status;
        statusEl.style.color = color;
    }
    if (sourceEl) sourceEl.textContent = source;
    if (countEl) countEl.textContent = count.toLocaleString();
    if (wpCountEl) wpCountEl.textContent = wpCount.toLocaleString();
}

// Get expected time between two sites (minutes)
function getExpectedTime(siteA, siteB) {
    if (siteA === siteB) return 0;
    
    const key = siteA + '_' + siteB;
    if (EXPECTED_TIMES[key] !== undefined) {
        return EXPECTED_TIMES[key];
    }
    
    // Fallback: estimate based on distance (avg 40 km/h in city)
    const a = SITES[siteA];
    const b = SITES[siteB];
    if (!a || !b) return null;
    
    const dist = haversineDistance(a.lat, a.lon, b.lat, b.lon);
    return (dist / 40) * 60; // minutes assuming 40 km/h
}

// Haversine distance in km
function haversineDistance(lat1, lon1, lat2, lon2) {
    const R = 6371;
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
              Math.sin(dLon/2) * Math.sin(dLon/2);
    return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}

// Show vehicle info when selected
function showVehicleInfo() {
    const vehicle = document.getElementById('vehicleSel').value;
    const infoDiv = document.getElementById('vehicleInfo');
    
    if (!vehicle) {
        infoDiv.style.display = 'none';
        return;
    }
    
    // Get all trips for this vehicle
    const vehicleTrips = TRIPS.filter(t => t.plate === vehicle);
    
    if (vehicleTrips.length === 0) {
        infoDiv.style.display = 'block';
        infoDiv.innerHTML = '<span style="color:#f44336;">No trips found for this vehicle</span>';
        return;
    }
    
    // Get unique dates and count trips per date
    const dateMap = {};
    vehicleTrips.forEach(t => {
        const date = t.t_prev.split('T')[0];
        if (!dateMap[date]) {
            dateMap[date] = { count: 0, trips: [] };
        }
        dateMap[date].count++;
        dateMap[date].trips.push(t);
    });
    
    const dates = Object.keys(dateMap).sort();
    const firstDate = dates[0];
    const lastDate = dates[dates.length - 1];
    
    // Build date list with trip counts
    let dateListHtml = '<div style="max-height:100px;overflow-y:auto;margin-top:5px;">';
    dates.forEach(date => {
        const info = dateMap[date];
        const isSelected = date >= document.getElementById('startDate').value && 
                          date <= document.getElementById('endDate').value;
        dateListHtml += `<div style="display:flex;justify-content:space-between;padding:2px 4px;${isSelected ? 'background:#bbdefb;' : ''}">
            <span>${date}</span>
            <span style="color:#1565c0;font-weight:bold;">${info.count} trips</span>
        </div>`;
    });
    dateListHtml += '</div>';
    
    infoDiv.style.display = 'block';
    infoDiv.innerHTML = `
        <div style="margin-bottom:5px;">
            <strong>${vehicle}</strong>: <span style="color:#4caf50;">${vehicleTrips.length} total trips</span>
        </div>
        <div style="margin-bottom:5px;">
            <strong>Date range:</strong> ${firstDate} to ${lastDate}
        </div>
        <div style="font-size:0.7rem;color:#666;">Available dates (click to set):</div>
        ${dateListHtml}
        <div style="margin-top:5px;">
            <button onclick="setDateRange('${firstDate}', '${lastDate}')" style="font-size:0.7rem;padding:3px 8px;cursor:pointer;background:#1565c0;color:#fff;border:none;border-radius:3px;">
                Set Full Range (${firstDate} to ${lastDate})
            </button>
        </div>
    `;
    
    // Make dates clickable
    setTimeout(() => {
        const dateItems = infoDiv.querySelectorAll('div[style*="display:flex"]');
        dateItems.forEach(item => {
            item.style.cursor = 'pointer';
            item.addEventListener('click', () => {
                const date = item.querySelector('span').textContent;
                setDateRange(date, date);
            });
            item.addEventListener('mouseover', () => item.style.background = '#e3f2fd');
            item.addEventListener('mouseout', () => {
                const date = item.querySelector('span').textContent;
                const isSelected = date >= document.getElementById('startDate').value && 
                                  date <= document.getElementById('endDate').value;
                item.style.background = isSelected ? '#bbdefb' : '';
            });
        });
    }, 0);
}

// Set date range from vehicle info
function setDateRange(startDate, endDate) {
    document.getElementById('startDate').value = startDate;
    document.getElementById('endDate').value = endDate;
    showVehicleInfo(); // Refresh to highlight selected dates
}

// ============ ROUTE FILTERING ============
function filterTrips(vehicle, startDate, endDate, startTime, endTime) {
    console.log('Filtering trips:', { vehicle, startDate, endDate, startTime, endTime });
    console.log('Total TRIPS:', TRIPS.length);
    
    const filtered = TRIPS.filter(trip => {
        // Filter by vehicle
        if (vehicle && trip.plate !== vehicle) return false;
        
        // Get trip start and end datetime
        const tripStart = new Date(trip.t_prev);
        const tripEnd = new Date(trip.t_next);
        
        // Filter by date and time range
        if (startDate && endDate) {
            // Build the filter window
            // Window starts at: startDate + startTime (or 00:00 if no startTime)
            // Window ends at: endDate + endTime (or 23:59 if no endTime)
            const filterStart = new Date(startDate + 'T' + (startTime || '00:00') + ':00');
            const filterEnd = new Date(endDate + 'T' + (endTime || '23:59') + ':59');
            
            // Trip must START within the filter window
            if (tripStart < filterStart || tripStart > filterEnd) {
                return false;
            }
            
            // Trip must also END within the filter window
            // This ensures we only see trips that complete within the selected timeframe
            if (tripEnd > filterEnd) {
                return false;
            }
        }
        
        return true;
    });
    
    console.log('Filtered trips:', filtered.length);
    
    // Sort by trip start time
    return filtered.sort((a, b) => new Date(a.t_prev) - new Date(b.t_prev));
}

// ============ PATH SEGMENTATION ============

// Build the corridor (list of site coordinates) from pathStart to destination using Google Matrix waypoints
function buildCorridor(pathStartSite, destSite) {
    const corridor = [];
    
    // Add path start site
    const startData = SITES[pathStartSite];
    if (startData) {
        corridor.push({ siteId: pathStartSite, lat: startData.lat, lon: startData.lon });
    }
    
    // Add waypoints from Google Matrix (if available)
    const routeKey = pathStartSite + '_' + destSite;
    const waypoints = EXPECTED_WAYPOINTS[routeKey] || [];
    
    for (const wpSite of waypoints) {
        const wpData = SITES[wpSite];
        if (wpData) {
            corridor.push({ siteId: wpSite, lat: wpData.lat, lon: wpData.lon });
        }
    }
    
    // Add destination site
    const destData = SITES[destSite];
    if (destData) {
        corridor.push({ siteId: destSite, lat: destData.lat, lon: destData.lon });
    }
    
    return corridor;
}

// Calculate minimum distance from a point to a corridor (polyline of sites) in meters
function distanceToCorridor(lat, lon, corridor) {
    if (!corridor || corridor.length === 0) return Infinity;
    
    let minDist = Infinity;
    
    // Check distance to each segment of the corridor
    for (let i = 0; i < corridor.length - 1; i++) {
        const p1 = corridor[i];
        const p2 = corridor[i + 1];
        
        // Get distance from point to line segment
        const dist = distanceToSegment(lat, lon, p1.lat, p1.lon, p2.lat, p2.lon);
        if (dist < minDist) minDist = dist;
    }
    
    // Also check distance to each waypoint directly
    for (const wp of corridor) {
        const dist = haversineDistance(lat, lon, wp.lat, wp.lon) * 1000; // km to meters
        if (dist < minDist) minDist = dist;
    }
    
    return minDist;
}

// Distance from point to line segment (in meters)
function distanceToSegment(lat, lon, lat1, lon1, lat2, lon2) {
    // Vector from p1 to p2
    const dx = lat2 - lat1;
    const dy = lon2 - lon1;
    
    // If segment is a point
    if (dx === 0 && dy === 0) {
        return haversineDistance(lat, lon, lat1, lon1) * 1000; // Convert to meters
    }
    
    // Calculate projection parameter t
    const t = Math.max(0, Math.min(1, ((lat - lat1) * dx + (lon - lon1) * dy) / (dx * dx + dy * dy)));
    
    // Find closest point on segment
    const closestLat = lat1 + t * dx;
    const closestLon = lon1 + t * dy;
    
    // Return distance in meters
    return haversineDistance(lat, lon, closestLat, closestLon) * 1000;
}

// Check spatial continuity using precomputed Google Matrix waypoints
// Checks if the CURRENT site (camera_next) lies on/near the corridor from pathStart to that site
// NOTE: Intermediate observed sites (camera_prev) are NOT checked - only the current destination matters
function checkSpatialContinuity(pathStartSite, currentSite, epsilonMeters) {
    // If current site = path start, always OK (path just started)
    if (pathStartSite === currentSite) {
        return { spatialOk: true, distanceToRoute: 0, corridorSites: [pathStartSite], reason: 'Same as path start' };
    }
    
    // Get site coordinates
    const startData = SITES[pathStartSite];
    const currentData = SITES[currentSite];
    
    if (!startData || !currentData) {
        return { 
            spatialOk: false, 
            distanceToRoute: null, 
            corridorSites: [], 
            reason: 'Site coordinates not found' 
        };
    }
    
    // Build the expected corridor from pathStart to currentSite
    const corridor = buildCorridor(pathStartSite, currentSite);
    
    // Check if corridor exists in the matrix
    const routeKey = pathStartSite + '_' + currentSite;
    const hasMatrixEntry = EXPECTED_TIMES[routeKey] !== undefined;
    
    if (corridor.length < 2) {
        // Can't build corridor - no matrix data
        // Fall back to direct distance check
        const directDist = haversineDistance(startData.lat, startData.lon, currentData.lat, currentData.lon) * 1000;
        return { 
            spatialOk: false, 
            distanceToRoute: directDist, 
            corridorSites: [pathStartSite, currentSite], 
            reason: 'No route in matrix from ' + pathStartSite + ' to ' + currentSite
        };
    }
    
    // Corridor exists - current site is reachable from path start via Google routes
    // The current site IS the destination of the corridor, so it's on the corridor by definition
    // But we verify the corridor endpoint matches the current site location
    const corridorEnd = corridor[corridor.length - 1];
    const distToCorridorEnd = haversineDistance(currentData.lat, currentData.lon, corridorEnd.lat, corridorEnd.lon) * 1000;
    
    if (distToCorridorEnd <= epsilonMeters) {
        return { 
            spatialOk: true, 
            distanceToRoute: distToCorridorEnd, 
            corridorSites: corridor.map(c => c.siteId), 
            reason: hasMatrixEntry 
                ? 'Route exists in matrix (' + corridor.length + ' sites in corridor)'
                : 'Direct route (no waypoints)'
        };
    } else {
        // This shouldn't normally happen unless there's coordinate mismatch
        return {
            spatialOk: false,
            distanceToRoute: distToCorridorEnd,
            corridorSites: corridor.map(c => c.siteId),
            reason: 'Coordinate mismatch: site ' + Math.round(distToCorridorEnd) + 'm from corridor endpoint'
        };
    }
}

// Segmentation using precomputed Google Matrix data (no API calls)
function segmentRoute(trips) {
    const rMin = parseFloat(document.getElementById('rMin').value) || 0.5;
    const rMax = parseFloat(document.getElementById('rMax').value) || 2.0;
    const epsilonMeters = parseFloat(document.getElementById('epsilonMeters').value) || 500;
    
    let pathId = 1;
    let pathStartTime = null;
    let pathStartSite = null;
    
    const segmented = [];
    
    for (let idx = 0; idx < trips.length; idx++) {
        const trip = trips[idx];
        const obsTimeMin = trip.obs_time_seconds / 60;
        const expectedTime = getExpectedTime(trip.camera_prev, trip.camera_next);
        
        // Calculate ratio R
        let R = null;
        let R_method = null; // Track how R was calculated
        let temporalOk = true;
        let spatialOk = true;
        let spatialDistance = null;
        let spatialCorridor = [];
        let spatialReason = '';
        let status = 'normal';
        let breakReason = null;
        
        if (idx === 0) {
            // First trip starts a new path
            pathStartTime = new Date(trip.t_prev);
            pathStartSite = trip.camera_prev;
            
            // Calculate R for first trip using hop-by-hop
            if (expectedTime && expectedTime > 0) {
                R = obsTimeMin / expectedTime;
                R_method = 'hop';
                temporalOk = (R >= rMin && R <= rMax);
            }
        } else {
            // TEMPORAL CHECK
            // R = (t_current - t_path_start) / expected_time(path_start  current_site)
            const currentTime = new Date(trip.t_next);
            const elapsedMin = (currentTime - pathStartTime) / 60000;
            const expectedFromStart = getExpectedTime(pathStartSite, trip.camera_next);
            
            if (expectedFromStart && expectedFromStart > 0) {
                // Use path-based R (from path start to current site)
                R = elapsedMin / expectedFromStart;
                R_method = 'path';
                temporalOk = (R >= rMin && R <= rMax);
            } else if (expectedTime && expectedTime > 0) {
                // Fallback to hop-by-hop if no matrix entry for full path
                R = obsTimeMin / expectedTime;
                R_method = 'hop';
                temporalOk = (R >= rMin && R <= rMax);
            } else {
                // No expected time available - cannot calculate R
                // Use distance-based fallback estimate
                const prevSite = SITES[trip.camera_prev];
                const nextSite = SITES[trip.camera_next];
                if (prevSite && nextSite) {
                    const dist = haversineDistance(prevSite.lat, prevSite.lon, nextSite.lat, nextSite.lon);
                    const estimatedMin = (dist / 40) * 60; // 40 km/h average
                    if (estimatedMin > 0) {
                        R = obsTimeMin / estimatedMin;
                        R_method = 'dist-est';
                        temporalOk = (R >= rMin && R <= rMax);
                    }
                }
            }
            
            // SPATIAL CHECK using Google Matrix waypoints
            // Check if CURRENT site (camera_next) is reachable from pathStartSite via plausible road corridor
            // NOTE: We do NOT check camera_prev - intermediate sites are irrelevant to spatial continuity
            const spatialResult = checkSpatialContinuity(pathStartSite, trip.camera_next, epsilonMeters);
            spatialOk = spatialResult.spatialOk;
            spatialDistance = spatialResult.distanceToRoute;
            spatialCorridor = spatialResult.corridorSites || [];
            spatialReason = spatialResult.reason || '';
            
            // Build break reason
            if (!spatialOk && !temporalOk) {
                breakReason = 'BOTH FAILED - Temporal: R=' + (R ? R.toFixed(2) : 'N/A') + 
                              ' (' + (R_method || 'no-calc') + ') outside [' + rMin + ',' + rMax + '] | Spatial: ' + spatialReason;
            } else if (!spatialOk) {
                breakReason = 'SPATIAL FAIL - Site ' + trip.camera_next + ' not reachable from path start ' + pathStartSite + 
                              ' | ' + spatialReason;
            } else if (!temporalOk) {
                breakReason = 'TEMPORAL FAIL - R=' + (R ? R.toFixed(2) : 'N/A') + 
                              ' (' + (R_method || 'no-calc') + ') outside [' + rMin + ',' + rMax + ']';
            }
        }
        
        // Determine status - BOTH must be true to continue path
        if (!temporalOk || !spatialOk) {
            status = 'break';
            pathId++;
            // New path starts at camera_next (where vehicle is after this trip)
            pathStartTime = new Date(trip.t_next);
            pathStartSite = trip.camera_next;
        } else if (R !== null && R > rMax * 0.8) {
            status = 'slow';
        }
        
        // Store the pathStartSite that was used for this trip's spatial check
        const tripPathStart = idx === 0 ? trip.camera_prev : (segmented.length > 0 ? segmented[segmented.length - 1].pathStartSite : trip.camera_prev);
        
        segmented.push({
            ...trip,
            pathId,
            pathStartSite: status === 'break' ? trip.camera_next : (idx === 0 ? trip.camera_prev : tripPathStart),
            corridorStart: idx === 0 ? trip.camera_prev : tripPathStart,  // The start site used for spatial check
            R,
            R_method,  // 'path', 'hop', or 'dist-est'
            temporalOk,
            spatialOk,
            spatialDistance,
            spatialCorridor,
            expectedTimeMin: expectedTime,
            obsTimeMin,
            status,
            breakReason
        });
    }
    
    return segmented;
}

// ============ VISUALIZATION ============
function clearMap() {
    markers.forEach(m => m.setMap(null));
    polylines.forEach(p => p.setMap(null));
    markers = [];
    polylines = [];
    clearCorridor();
}

// Get road-snapped route between two points
async function getSnappedRoute(origin, destination) {
    return new Promise((resolve) => {
        if (!directionsService) {
            resolve(null);
            return;
        }
        
        directionsService.route({
            origin: origin,
            destination: destination,
            travelMode: google.maps.TravelMode.DRIVING
        }, (result, status) => {
            if (status === 'OK' && result.routes[0]) {
                resolve(result.routes[0].overview_path);
            } else {
                resolve(null);
            }
        });
    });
}

// Add origin and destination markers for each path
function addPathMarkers(trips) {
    if (trips.length === 0) return;
    
    // Group trips by pathId
    const pathGroups = {};
    trips.forEach(trip => {
        if (!pathGroups[trip.pathId]) {
            pathGroups[trip.pathId] = [];
        }
        pathGroups[trip.pathId].push(trip);
    });
    
    // Color palette for different paths
    const pathColors = [
        '#1565C0', '#2E7D32', '#6A1B9A', '#C62828', '#EF6C00', 
        '#00838F', '#AD1457', '#4527A0', '#283593', '#00695C'
    ];
    
    Object.keys(pathGroups).forEach((pathId, pathIndex) => {
        const pathTrips = pathGroups[pathId];
        if (pathTrips.length === 0) return;
        
        const color = pathColors[pathIndex % pathColors.length];
        
        // Origin: first trip's camera_prev
        const firstTrip = pathTrips[0];
        const originSite = SITES[firstTrip.camera_prev];
        
        // Destination: last trip's camera_next
        const lastTrip = pathTrips[pathTrips.length - 1];
        const destSite = SITES[lastTrip.camera_next];
        
        // Add ORIGIN marker (flag pointing right)
        if (originSite) {
            const originMarker = new google.maps.Marker({
                position: { lat: originSite.lat, lng: originSite.lon },
                map: map,
                icon: {
                    path: 'M 0,0 L 0,-20 L 15,-15 L 0,-10 Z',  // Flag shape
                    fillColor: color,
                    fillOpacity: 1,
                    strokeColor: '#FFFFFF',
                    strokeWeight: 2,
                    scale: 1.2,
                    anchor: new google.maps.Point(0, 0)
                },
                title: `Path ${pathId} ORIGIN: ${firstTrip.camera_prev}\nStart time: ${new Date(firstTrip.t_prev).toLocaleString()}`,
                zIndex: 200,
                label: {
                    text: 'O' + pathId,
                    color: '#FFFFFF',
                    fontWeight: 'bold',
                    fontSize: '10px'
                }
            });
            markers.push(originMarker);
        }
        
        // Add DESTINATION marker (square/diamond)
        if (destSite) {
            const destMarker = new google.maps.Marker({
                position: { lat: destSite.lat, lng: destSite.lon },
                map: map,
                icon: {
                    path: 'M -8,-8 L 8,-8 L 8,8 L -8,8 Z',  // Square shape
                    fillColor: color,
                    fillOpacity: 1,
                    strokeColor: '#FFFFFF',
                    strokeWeight: 2,
                    scale: 1,
                    anchor: new google.maps.Point(0, 0)
                },
                title: `Path ${pathId} DESTINATION: ${lastTrip.camera_next}\nEnd time: ${new Date(lastTrip.t_next).toLocaleString()}`,
                zIndex: 200,
                label: {
                    text: 'D' + pathId,
                    color: '#FFFFFF',
                    fontWeight: 'bold',
                    fontSize: '10px'
                }
            });
            markers.push(destMarker);
        }
    });
}

async function visualizeRoute(trips) {
    clearMap();
    
    if (trips.length === 0) return;
    
    const bounds = new google.maps.LatLngBounds();
    const colorMap = { normal: '#34a853', slow: '#fbbc05', break: '#ea4335' };
    
    // Build site status map - track which sites have issues
    const siteStatus = {}; // siteId -> { temporal: bool, spatial: bool, breakReason: string }
    
    trips.forEach(trip => {
        // Initialize sites
        if (!siteStatus[trip.camera_prev]) {
            siteStatus[trip.camera_prev] = { temporal: true, spatial: true, reasons: [] };
        }
        if (!siteStatus[trip.camera_next]) {
            siteStatus[trip.camera_next] = { temporal: true, spatial: true, reasons: [] };
        }
        
        // Flag the destination site if there was a break
        if (trip.status === 'break') {
            if (!trip.temporalOk) {
                siteStatus[trip.camera_next].temporal = false;
                siteStatus[trip.camera_next].reasons.push('[TEMPORAL] R=' + (trip.R ? trip.R.toFixed(2) : 'N/A'));
            }
            if (!trip.spatialOk) {
                siteStatus[trip.camera_next].spatial = false;
                siteStatus[trip.camera_next].reasons.push('[SPATIAL] too far');
            }
        }
        // Flag slow sites too
        if (trip.status === 'slow') {
            siteStatus[trip.camera_next].reasons.push('[SLOW] R=' + (trip.R ? trip.R.toFixed(2) : 'N/A'));
        }
    });
    
    // Add site markers with status colors
    const visitedSites = new Set();
    trips.forEach(trip => {
        visitedSites.add(trip.camera_prev);
        visitedSites.add(trip.camera_next);
    });
    
    visitedSites.forEach(siteId => {
        const site = SITES[siteId];
        if (!site) return;
        
        const status = siteStatus[siteId] || { temporal: true, spatial: true, reasons: [] };
        
        // Determine marker color based on status
        let fillColor = '#4285f4'; // Blue = normal
        let strokeColor = '#fff';
        let scale = 8;
        let zIndex = 1;
        
        if (!status.temporal && !status.spatial) {
            fillColor = '#ea4335'; // Red = both failed
            strokeColor = '#b71c1c';
            scale = 12;
            zIndex = 100;
        } else if (!status.temporal) {
            fillColor = '#ff9800'; // Orange = temporal failed
            strokeColor = '#e65100';
            scale = 11;
            zIndex = 90;
        } else if (!status.spatial) {
            fillColor = '#9c27b0'; // Purple = spatial failed
            strokeColor = '#6a1b9a';
            scale = 11;
            zIndex = 90;
        } else if (status.reasons.length > 0 && status.reasons.some(r => r.includes('Slow'))) {
            fillColor = '#fbbc05'; // Yellow = slow
            strokeColor = '#f57f17';
            scale = 9;
            zIndex = 50;
        }
        
        // Build tooltip
        let title = siteId + ' (' + site.dir + ')';
        if (status.reasons.length > 0) {
            title += '\n' + status.reasons.join('\n');
        }
        
        const marker = new google.maps.Marker({
            position: { lat: site.lat, lng: site.lon },
            map: map,
            title: title,
            zIndex: zIndex,
            icon: {
                path: google.maps.SymbolPath.CIRCLE,
                scale: scale,
                fillColor: fillColor,
                fillOpacity: 1,
                strokeColor: strokeColor,
                strokeWeight: 2
            }
        });
        
        // Add click listener to show site info
        marker.addListener('click', () => showSiteInfo(siteId, status));
        
        markers.push(marker);
        bounds.extend(marker.getPosition());
    });
    
    // Add path origin/destination markers
    addPathMarkers(trips);
    
    // Show loading message
    document.getElementById('tripList').innerHTML = '<div class="loading">Loading road-snapped routes...</div>';
    
    // Add trip lines with road snapping
    const uniqueTrips = trips.filter((trip, idx) => {
        if (trip.camera_prev === trip.camera_next) return false;
        const prevSite = SITES[trip.camera_prev];
        const nextSite = SITES[trip.camera_next];
        return prevSite && nextSite;
    });
    
    // Process trips - snap to roads
    for (let i = 0; i < uniqueTrips.length; i++) {
        const trip = uniqueTrips[i];
        const tripIdx = trips.indexOf(trip);
        const prevSite = SITES[trip.camera_prev];
        const nextSite = SITES[trip.camera_next];
        
        const origin = { lat: prevSite.lat, lng: prevSite.lon };
        const destination = { lat: nextSite.lat, lng: nextSite.lon };
        
        // Try to get snapped route
        const snappedPath = await getSnappedRoute(origin, destination);
        
        let path;
        if (snappedPath && snappedPath.length > 0) {
            // Use snapped road path
            path = snappedPath;
        } else {
            // Fallback to straight line
            path = [origin, destination];
        }
        
        const line = new google.maps.Polyline({
            path: path,
            geodesic: true,
            strokeColor: colorMap[trip.status] || colorMap.normal,
            strokeOpacity: 0.85,
            strokeWeight: trip.status === 'break' ? 5 : 4,
            map: map
        });
        
        // Add click listener
        line.addListener('click', () => selectTrip(tripIdx));
        polylines.push(line);
        
        // Small delay to avoid rate limiting
        if (i < uniqueTrips.length - 1) {
            await new Promise(r => setTimeout(r, 100));
        }
    }
    
    map.fitBounds(bounds, 50);
    
    // Update trip list after routes are loaded
    renderTripList(trips);
}

// ============ UI UPDATES ============
function updateStats(trips) {
    document.getElementById('statTrips').textContent = trips.length;
    
    const paths = new Set(trips.map(t => t.pathId));
    document.getElementById('statPaths').textContent = paths.size;
    
    const slow = trips.filter(t => t.status === 'slow').length;
    document.getElementById('statSlow').textContent = slow;
    
    const breaks = trips.filter(t => t.status === 'break').length;
    document.getElementById('statBreaks').textContent = breaks;
    
    // Breakdown of breaks
    const temporalBreaks = trips.filter(t => t.status === 'break' && !t.temporalOk).length;
    const spatialBreaks = trips.filter(t => t.status === 'break' && !t.spatialOk).length;
    const bothBreaks = trips.filter(t => t.status === 'break' && !t.temporalOk && !t.spatialOk).length;
    
    document.getElementById('statBreakdown').innerHTML = 
        `<span style="color:#ff9800;" title="Temporal failures">[T]${temporalBreaks}</span> ` +
        `<span style="color:#9c27b0;" title="Spatial failures">[S]${spatialBreaks}</span> ` +
        `<span style="color:#c62828;" title="Both failed">[Both]${bothBreaks}</span>`;
    
    // Populate path filter dropdown
    updatePathFilter(trips);
}

// Update the path filter dropdown with available paths
function updatePathFilter(trips) {
    const pathFilter = document.getElementById('pathFilter');
    const currentValue = pathFilter.value;
    
    // Get unique paths with their info
    const pathInfo = {};
    trips.forEach(trip => {
        if (!pathInfo[trip.pathId]) {
            pathInfo[trip.pathId] = {
                id: trip.pathId,
                tripCount: 0,
                startSite: trip.camera_prev,
                endSite: trip.camera_next,
                startTime: trip.t_prev
            };
        }
        pathInfo[trip.pathId].tripCount++;
        pathInfo[trip.pathId].endSite = trip.camera_next;
    });
    
    // Build options
    let html = '<option value="all">All Paths (' + Object.keys(pathInfo).length + ')</option>';
    
    Object.keys(pathInfo).sort((a, b) => parseInt(a) - parseInt(b)).forEach(pathId => {
        const info = pathInfo[pathId];
        const time = new Date(info.startTime).toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
        html += `<option value="${pathId}">Path ${pathId}: ${info.startSite}  ${info.endSite} (${info.tripCount} trips, ${time})</option>`;
    });
    
    pathFilter.innerHTML = html;
    
    // Restore selection if still valid
    if (currentValue && pathInfo[currentValue]) {
        pathFilter.value = currentValue;
    }
}

// Filter visualization by selected path
async function filterByPath() {
    const pathFilter = document.getElementById('pathFilter');
    const selectedPath = pathFilter.value;
    
    if (!currentRoute || currentRoute.length === 0) {
        alert('Please load a route first');
        return;
    }
    
    if (selectedPath === 'all') {
        // Show all trips
        await visualizeRoute(currentRoute);
    } else {
        // Filter to selected path only
        const pathTrips = currentRoute.filter(t => t.pathId === parseInt(selectedPath));
        
        if (pathTrips.length === 0) {
            alert('No trips found for Path ' + selectedPath);
            return;
        }
        
        // Visualize only this path
        await visualizeSinglePath(pathTrips, parseInt(selectedPath));
    }
}

// Visualize a single path with enhanced detail
async function visualizeSinglePath(trips, pathId) {
    clearMap();
    
    if (trips.length === 0) return;
    
    const bounds = new google.maps.LatLngBounds();
    const colorMap = { normal: '#34a853', slow: '#fbbc05', break: '#ea4335' };
    
    // Get path color
    const pathColors = [
        '#1565C0', '#2E7D32', '#6A1B9A', '#C62828', '#EF6C00', 
        '#00838F', '#AD1457', '#4527A0', '#283593', '#00695C'
    ];
    const pathColor = pathColors[(pathId - 1) % pathColors.length];
    
    // Collect all sites in this path
    const pathSites = new Set();
    trips.forEach(trip => {
        pathSites.add(trip.camera_prev);
        pathSites.add(trip.camera_next);
    });
    
    // Add site markers
    pathSites.forEach(siteId => {
        const site = SITES[siteId];
        if (!site) return;
        
        const marker = new google.maps.Marker({
            position: { lat: site.lat, lng: site.lon },
            map: map,
            title: siteId + ' (' + site.dir + ')',
            icon: {
                path: google.maps.SymbolPath.CIRCLE,
                scale: 10,
                fillColor: '#4285f4',
                fillOpacity: 1,
                strokeColor: '#fff',
                strokeWeight: 2
            },
            zIndex: 10
        });
        
        marker.addListener('click', () => showSiteInfo(siteId, { temporal: true, spatial: true, reasons: [] }));
        markers.push(marker);
        bounds.extend(marker.getPosition());
    });
    
    // Add ORIGIN marker
    const firstTrip = trips[0];
    const originSite = SITES[firstTrip.camera_prev];
    if (originSite) {
        const originMarker = new google.maps.Marker({
            position: { lat: originSite.lat, lng: originSite.lon },
            map: map,
            icon: {
                path: 'M 0,0 L 0,-25 L 20,-18 L 0,-11 Z',
                fillColor: pathColor,
                fillOpacity: 1,
                strokeColor: '#FFFFFF',
                strokeWeight: 2,
                scale: 1.5,
                anchor: new google.maps.Point(0, 0)
            },
            title: `PATH ${pathId} ORIGIN\nSite: ${firstTrip.camera_prev}\nStart: ${new Date(firstTrip.t_prev).toLocaleString()}`,
            zIndex: 300,
            label: {
                text: 'O' + pathId,
                color: '#FFFFFF',
                fontWeight: 'bold',
                fontSize: '11px'
            }
        });
        markers.push(originMarker);
    }
    
    // Add DESTINATION marker
    const lastTrip = trips[trips.length - 1];
    const destSite = SITES[lastTrip.camera_next];
    if (destSite) {
        const destMarker = new google.maps.Marker({
            position: { lat: destSite.lat, lng: destSite.lon },
            map: map,
            icon: {
                path: 'M -10,-10 L 10,-10 L 10,10 L -10,10 Z',
                fillColor: pathColor,
                fillOpacity: 1,
                strokeColor: '#FFFFFF',
                strokeWeight: 2,
                scale: 1.2,
                anchor: new google.maps.Point(0, 0)
            },
            title: `PATH ${pathId} DESTINATION\nSite: ${lastTrip.camera_next}\nEnd: ${new Date(lastTrip.t_next).toLocaleString()}`,
            zIndex: 300,
            label: {
                text: 'D' + pathId,
                color: '#FFFFFF',
                fontWeight: 'bold',
                fontSize: '11px'
            }
        });
        markers.push(destMarker);
    }
    
    // Show loading message
    document.getElementById('tripList').innerHTML = '<div class="loading">Loading Path ' + pathId + ' routes...</div>';
    
    // Add trip lines with road snapping
    for (let i = 0; i < trips.length; i++) {
        const trip = trips[i];
        const tripIdx = currentRoute.indexOf(trip);
        const prevSite = SITES[trip.camera_prev];
        const nextSite = SITES[trip.camera_next];
        
        if (!prevSite || !nextSite || trip.camera_prev === trip.camera_next) continue;
        
        const origin = { lat: prevSite.lat, lng: prevSite.lon };
        const destination = { lat: nextSite.lat, lng: nextSite.lon };
        
        // Try to get snapped route
        const snappedPath = await getSnappedRoute(origin, destination);
        
        let path;
        if (snappedPath && snappedPath.length > 0) {
            path = snappedPath;
        } else {
            path = [origin, destination];
        }
        
        const line = new google.maps.Polyline({
            path: path,
            geodesic: true,
            strokeColor: colorMap[trip.status] || colorMap.normal,
            strokeOpacity: 0.9,
            strokeWeight: 6,
            map: map,
            zIndex: 50
        });
        
        // Add click listener
        line.addListener('click', () => selectTrip(tripIdx));
        polylines.push(line);
        
        // Add trip number label at midpoint
        const midIdx = Math.floor(path.length / 2);
        const midPoint = path[midIdx];
        const tripLabel = new google.maps.Marker({
            position: midPoint,
            map: map,
            icon: {
                path: google.maps.SymbolPath.CIRCLE,
                scale: 12,
                fillColor: colorMap[trip.status] || colorMap.normal,
                fillOpacity: 1,
                strokeColor: '#fff',
                strokeWeight: 2
            },
            label: {
                text: String(i + 1),
                color: '#fff',
                fontWeight: 'bold',
                fontSize: '10px'
            },
            title: `Trip ${i + 1}: ${trip.camera_prev}  ${trip.camera_next}\nTime: ${formatTime(trip.obs_time_seconds)}`,
            zIndex: 100
        });
        tripLabel.addListener('click', () => selectTrip(tripIdx));
        markers.push(tripLabel);
        
        // Small delay to avoid rate limiting
        if (i < trips.length - 1) {
            await new Promise(r => setTimeout(r, 100));
        }
    }
    
    // Draw the corridor for the entire path (from origin to final destination)
    drawPathCorridor(trips, pathId, pathColor);
    
    map.fitBounds(bounds, 50);
    
    // Update trip list to show only this path's trips
    renderTripList(trips);
}

// Draw corridor for entire path from matrix
function drawPathCorridor(trips, pathId, pathColor) {
    if (trips.length === 0) return;
    
    // Get origin and final destination
    const originSite = trips[0].camera_prev;
    const destSite = trips[trips.length - 1].camera_next;
    
    // Build corridor from matrix
    const corridor = buildCorridor(originSite, destSite);
    
    if (corridor.length < 2) return;
    
    // Build path
    const corridorPath = corridor.map(c => ({ lat: c.lat, lng: c.lon }));
    
    // Draw as dashed line
    corridorPolyline = new google.maps.Polyline({
        path: corridorPath,
        geodesic: true,
        strokeColor: pathColor,
        strokeOpacity: 0.5,
        strokeWeight: 8,
        icons: [{
            icon: {
                path: 'M 0,-1 0,1',
                strokeOpacity: 0.7,
                strokeWeight: 8,
                scale: 2
            },
            offset: '0',
            repeat: '20px'
        }],
        map: map,
        zIndex: 1
    });
    
    // Add corridor waypoint markers
    corridor.forEach((wp, idx) => {
        if (idx === 0 || idx === corridor.length - 1) return; // Skip origin/dest
        
        const wpMarker = new google.maps.Marker({
            position: { lat: wp.lat, lng: wp.lon },
            map: map,
            icon: {
                path: google.maps.SymbolPath.CIRCLE,
                scale: 7,
                fillColor: pathColor,
                fillOpacity: 0.6,
                strokeColor: '#fff',
                strokeWeight: 2
            },
            title: `Expected waypoint: ${wp.siteId}`,
            zIndex: 5
        });
        corridorMarkers.push(wpMarker);
    });
}

function renderTripList(trips) {
    const list = document.getElementById('tripList');
    
    if (trips.length === 0) {
        list.innerHTML = '<div class="no-data">No trips found for selection</div>';
        return;
    }
    
    let html = '';
    trips.forEach((trip, idx) => {
        const time = new Date(trip.t_prev).toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
        const statusClass = trip.status;
        
        // Check for expected waypoints
        const routeKey = trip.camera_prev + '_' + trip.camera_next;
        const expectedWaypoints = EXPECTED_WAYPOINTS[routeKey] || [];
        const expectedDist = EXPECTED_DISTANCES[routeKey];
        
        // Determine flag icons
        let flags = '';
        if (trip.status === 'break') {
            if (!trip.temporalOk) flags += '<span style="color:#ff9800;margin-left:5px;font-weight:bold;" title="Temporal failed">[T]</span>';
            if (!trip.spatialOk) flags += '<span style="color:#9c27b0;margin-left:5px;font-weight:bold;" title="Spatial failed">[S]</span>';
        } else if (trip.status === 'slow') {
            flags += '<span style="color:#fbbc05;margin-left:5px;font-weight:bold;" title="Slow">[SLOW]</span>';
        }
        
        // Waypoint indicator
        const wpIndicator = expectedWaypoints.length > 0 
            ? `<span style="color:#1565c0;font-size:0.7rem;margin-left:5px;" title="Has ${expectedWaypoints.length} waypoint(s)">[${expectedWaypoints.length}WP]</span>` 
            : '';
        
        html += `
            <div class="trip-item ${statusClass}" data-idx="${idx}" onclick="selectTrip(${idx})">
                <div class="trip-header">
                    <span class="trip-route">${trip.camera_prev}  ${trip.camera_next}${flags}${wpIndicator}</span>
                    <span class="path-badge">Path ${trip.pathId}</span>
                </div>
                <div class="trip-time">${time}</div>
                <div class="trip-meta">
                    <span>Obs: ${formatTime(trip.obs_time_seconds)}</span>
                    <span>Exp: ${trip.expectedTimeMin ? formatTime(trip.expectedTimeMin * 60) : '<span style="color:#f44336;">N/A</span>'}</span>
                    ${trip.R !== null ? `<span>R: ${trip.R.toFixed(2)} <span style="font-size:0.6rem;color:#999;">${trip.R_method || ''}</span></span>` : '<span style="color:#f44336;">R: N/A</span>'}
                    ${expectedDist ? `<span>${expectedDist.toFixed(1)}km</span>` : ''}
                </div>
                ${trip.breakReason ? `<div class="break-reason">${trip.breakReason}</div>` : ''}
            </div>
        `;
    });
    
    list.innerHTML = html;
    
    // Also render the timeline
    renderTimeline(trips);
}

// Render the path timeline showing journey with timestamps and break reasons
function renderTimeline(trips) {
    const container = document.getElementById('pathTimeline');
    
    if (!trips || trips.length === 0) {
        container.innerHTML = '<div class="no-data">No trips to display</div>';
        return;
    }
    
    let html = '<div class="timeline">';
    
    let currentPathId = null;
    
    trips.forEach((trip, idx) => {
        const isNewPath = trip.pathId !== currentPathId;
        const isLastTrip = idx === trips.length - 1;
        const prevTrip = idx > 0 ? trips[idx - 1] : null;
        
        // Start of new path
        if (isNewPath) {
            currentPathId = trip.pathId;
            const pathStartTime = new Date(trip.t_prev).toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
            
            html += `
                <div class="timeline-item path-start">
                    <div>
                        <span class="timeline-site">${trip.camera_prev}</span>
                        <span class="timeline-path-label">PATH ${trip.pathId} START</span>
                    </div>
                    <div class="timeline-time">${pathStartTime}</div>
                </div>
            `;
        }
        
        // The trip itself (arrival at camera_next)
        const arrivalTime = new Date(trip.t_next).toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        const duration = formatTime(trip.obs_time_seconds);
        const itemClass = trip.status === 'break' ? 'break' : trip.status === 'slow' ? 'slow' : '';
        
        // Check for waypoints
        const routeKey = trip.camera_prev + '_' + trip.camera_next;
        const waypoints = EXPECTED_WAYPOINTS[routeKey] || [];
        const waypointInfo = waypoints.length > 0 ? ` via ${waypoints.length} waypoint(s)` : '';
        
        html += `
            <div class="timeline-item ${itemClass}">
                <div>
                    <span class="timeline-site">${trip.camera_next}</span>
                    ${trip.status === 'break' ? '<span style="color:#ea4335;font-size:0.65rem;margin-left:5px;">[BREAK]</span>' : ''}
                    ${trip.status === 'slow' ? '<span style="color:#fbbc05;font-size:0.65rem;margin-left:5px;">[SLOW]</span>' : ''}
                </div>
                <div class="timeline-time">${arrivalTime}</div>
                <div class="timeline-info">
                    from ${trip.camera_prev} | ${duration}${waypointInfo}
                    ${trip.R !== null ? ' | R=' + trip.R.toFixed(2) + (trip.R_method ? ' <span style="color:#999;">(' + trip.R_method + ')</span>' : '') : ' | <span style="color:#f44336;">R: N/A</span>'}
                </div>
                ${trip.breakReason ? `<div class="timeline-break">${trip.breakReason}</div>` : ''}
            </div>
        `;
        
        // If this is the last trip OR next trip starts a new path, mark path end
        const nextTrip = idx < trips.length - 1 ? trips[idx + 1] : null;
        if (isLastTrip || (nextTrip && nextTrip.pathId !== trip.pathId)) {
            // Path ends here (but only add if not already showing break)
            if (trip.status !== 'break') {
                html += `
                    <div class="timeline-item path-end" style="padding-bottom:15px;">
                        <div class="timeline-info" style="color:#1565C0;">
                            Path ${trip.pathId} ends at ${trip.camera_next}
                        </div>
                    </div>
                `;
            }
        }
    });
    
    html += '</div>';
    
    // Add summary at top
    const pathCount = new Set(trips.map(t => t.pathId)).size;
    const breakCount = trips.filter(t => t.status === 'break').length;
    const totalDuration = trips.reduce((sum, t) => sum + t.obs_time_seconds, 0);
    const startTime = new Date(trips[0].t_prev).toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
    const endTime = new Date(trips[trips.length - 1].t_next).toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
    
    // Count R calculation methods
    const rPathCount = trips.filter(t => t.R_method === 'path').length;
    const rHopCount = trips.filter(t => t.R_method === 'hop').length;
    const rDistCount = trips.filter(t => t.R_method === 'dist-est').length;
    const rNullCount = trips.filter(t => t.R === null).length;
    
    const summary = `
        <div style="background:#f5f5f5;padding:8px;border-radius:4px;margin-bottom:10px;font-size:0.75rem;">
            <div><strong>${pathCount} path(s)</strong> | ${trips.length} trips | ${breakCount} break(s) | ${startTime}  ${endTime} | Total: ${formatTime(totalDuration)}</div>
            <div style="margin-top:4px;color:#666;font-size:0.7rem;">
                R calc: <span style="color:#4caf50;">${rPathCount} path</span> | 
                <span style="color:#2196f3;">${rHopCount} hop</span> | 
                <span style="color:#ff9800;">${rDistCount} dist-est</span>
                ${rNullCount > 0 ? ' | <span style="color:#f44336;">' + rNullCount + ' N/A</span>' : ''}
            </div>
        </div>
    `;
    
    container.innerHTML = summary + html;
}

function formatTime(seconds) {
    if (seconds < 60) return Math.round(seconds) + 's';
    if (seconds < 3600) return Math.round(seconds / 60) + 'm';
    const h = Math.floor(seconds / 3600);
    const m = Math.round((seconds % 3600) / 60);
    return h + 'h ' + m + 'm';
}

// Show site info when marker is clicked
function showSiteInfo(siteId, status) {
    const site = SITES[siteId];
    if (!site) return;
    
    const panel = document.getElementById('detailPanel');
    panel.classList.add('visible');
    
    const details = document.getElementById('tripDetails');
    
    // Determine status
    let statusText = 'NORMAL';
    let statusClass = 'green';
    if (!status.temporal && !status.spatial) {
        statusText = 'BOTH TEMPORAL & SPATIAL FAILED';
        statusClass = 'red';
    } else if (!status.temporal) {
        statusText = 'TEMPORAL CHECK FAILED';
        statusClass = 'yellow';
    } else if (!status.spatial) {
        statusText = 'SPATIAL CHECK FAILED';
        statusClass = 'red';
    } else if (status.reasons.length > 0) {
        statusText = 'SLOW (Warning)';
        statusClass = 'yellow';
    }
    
    details.innerHTML = `
        <div class="detail-row" style="background:#e3f2fd;margin:-15px -15px 10px -15px;padding:15px;border-radius:8px 8px 0 0;">
            <span class="detail-label" style="font-size:1.1rem;font-weight:bold;">SITE INFO</span>
            <span class="detail-value" style="font-size:1.1rem;">${siteId}</span>
        </div>
        <div class="detail-row">
            <span class="detail-label">Direction</span>
            <span class="detail-value">${site.dir}</span>
        </div>
        <div class="detail-row">
            <span class="detail-label">Latitude</span>
            <span class="detail-value">${site.lat.toFixed(6)}</span>
        </div>
        <div class="detail-row">
            <span class="detail-label">Longitude</span>
            <span class="detail-value">${site.lon.toFixed(6)}</span>
        </div>
        <div class="detail-row">
            <span class="detail-label">Status</span>
            <span class="detail-value ${statusClass}">${statusText}</span>
        </div>
        <div class="detail-row">
            <span class="detail-label">Temporal OK</span>
            <span class="detail-value ${status.temporal ? 'green' : 'red'}">${status.temporal ? 'YES' : 'NO'}</span>
        </div>
        <div class="detail-row">
            <span class="detail-label">Spatial OK</span>
            <span class="detail-value ${status.spatial ? 'green' : 'red'}">${status.spatial ? 'YES' : 'NO'}</span>
        </div>
        ${status.reasons.length > 0 ? `
        <div class="detail-row" style="flex-direction:column;align-items:flex-start;">
            <span class="detail-label" style="margin-bottom:5px;">Issues/Notes:</span>
            <div style="background:#fff3e0;padding:8px;border-radius:4px;width:100%;">
                ${status.reasons.map(r => `<div style="margin:3px 0;color:#e65100;">${r}</div>`).join('')}
            </div>
        </div>
        ` : ''}
    `;
    
    // Zoom to site
    map.setCenter({ lat: site.lat, lng: site.lon });
    map.setZoom(15);
}

function selectTrip(idx) {
    const trip = currentRoute[idx];
    if (!trip) return;
    
    // Update selection UI
    document.querySelectorAll('.trip-item').forEach(el => el.classList.remove('selected'));
    const item = document.querySelector(`.trip-item[data-idx="${idx}"]`);
    if (item) item.classList.add('selected');
    
    // Show details panel
    const panel = document.getElementById('detailPanel');
    panel.classList.add('visible');
    
    const details = document.getElementById('tripDetails');
    const statusClass = trip.status === 'normal' ? 'green' : trip.status === 'slow' ? 'yellow' : 'red';
    
    // Get expected data from Google Matrix
    const routeKey = trip.camera_prev + '_' + trip.camera_next;
    const expectedWaypoints = EXPECTED_WAYPOINTS[routeKey] || [];
    const expectedDistance = EXPECTED_DISTANCES[routeKey];
    const expectedTime = EXPECTED_TIMES[routeKey];
    
    // Build waypoints HTML
    let waypointsHtml = '';
    if (expectedWaypoints.length > 0) {
        waypointsHtml = `
        <div class="detail-row" style="flex-direction:column;align-items:flex-start;">
            <span class="detail-label" style="margin-bottom:5px;">Expected Waypoints (from Google Matrix):</span>
            <div style="background:#e3f2fd;padding:8px;border-radius:4px;width:100%;font-family:monospace;font-size:0.8rem;">
                ${trip.camera_prev}  ${expectedWaypoints.join('  ')}  ${trip.camera_next}
            </div>
        </div>`;
    } else {
        waypointsHtml = `
        <div class="detail-row">
            <span class="detail-label">Expected Waypoints</span>
            <span class="detail-value" style="color:#999;">None (direct route)</span>
        </div>`;
    }
    
    details.innerHTML = `
        <div class="detail-row" style="background:#e3f2fd;margin:-15px -15px 10px -15px;padding:15px;border-radius:8px 8px 0 0;">
            <span class="detail-label" style="font-size:1.1rem;font-weight:bold;">TRIP DETAILS</span>
            <span class="detail-value" style="font-size:1.1rem;">${trip.camera_prev}  ${trip.camera_next}</span>
        </div>
        <div class="detail-row">
            <span class="detail-label">Time Window</span>
            <span class="detail-value">${new Date(trip.t_prev).toLocaleString()}  ${new Date(trip.t_next).toLocaleString()}</span>
        </div>
        
        <div style="background:#f5f5f5;margin:10px -15px;padding:10px 15px;font-weight:bold;">OBSERVED vs EXPECTED</div>
        
        <div class="detail-row">
            <span class="detail-label">Observed Time</span>
            <span class="detail-value">${formatTime(trip.obs_time_seconds)} (${(trip.obs_time_seconds/60).toFixed(1)} min)</span>
        </div>
        <div class="detail-row">
            <span class="detail-label">Expected Time (Google)</span>
            <span class="detail-value">${expectedTime ? formatTime(expectedTime * 60) + ' (' + expectedTime.toFixed(1) + ' min)' : '<span style="color:#f44336;">Not in matrix</span>'}</span>
        </div>
        ${!expectedTime ? `
        <div class="detail-row" style="background:#fff3e0;margin:0 -15px;padding:5px 15px;font-size:0.75rem;">
            <span style="color:#e65100;">Matrix key "${routeKey}" not found. Check if route exists in uploaded matrix.</span>
        </div>
        ` : ''}
        <div class="detail-row">
            <span class="detail-label">Expected Distance (Google)</span>
            <span class="detail-value">${expectedDistance ? expectedDistance.toFixed(2) + ' km' : 'N/A'}</span>
        </div>
        <div class="detail-row">
            <span class="detail-label">Ratio R (obs/exp)</span>
            <span class="detail-value ${statusClass}">
                ${trip.R !== null ? trip.R.toFixed(3) : 'N/A'}
                ${trip.R_method ? '<span style="font-size:0.7rem;color:#666;margin-left:5px;">(' + trip.R_method + ')</span>' : ''}
            </span>
        </div>
        
        ${waypointsHtml}
        
        <div style="background:#f5f5f5;margin:10px -15px;padding:10px 15px;font-weight:bold;">SEGMENTATION RESULT</div>
        
        <div class="detail-row">
            <span class="detail-label">Path ID</span>
            <span class="detail-value">${trip.pathId}</span>
        </div>
        <div class="detail-row">
            <span class="detail-label">Path Start Site</span>
            <span class="detail-value" style="font-family:monospace;">${trip.corridorStart || trip.camera_prev}</span>
        </div>
        <div class="detail-row">
            <span class="detail-label">Status</span>
            <span class="detail-value ${statusClass}">${trip.status.toUpperCase()}</span>
        </div>
        <div class="detail-row">
            <span class="detail-label">Temporal OK</span>
            <span class="detail-value ${trip.temporalOk ? 'green' : 'red'}">${trip.temporalOk ? 'YES' : 'NO'}</span>
        </div>
        <div class="detail-row">
            <span class="detail-label">Spatial OK</span>
            <span class="detail-value ${trip.spatialOk ? 'green' : 'red'}">${trip.spatialOk ? 'YES' : 'NO'}</span>
        </div>
        <div class="detail-row">
            <span class="detail-label">Distance to Corridor</span>
            <span class="detail-value ${trip.spatialOk ? 'green' : 'red'}">${trip.spatialDistance !== null && trip.spatialDistance !== undefined ? Math.round(trip.spatialDistance) + ' m' : (trip.spatialOk ? 'On corridor' : 'N/A')}</span>
        </div>
        <div class="detail-row">
            <span class="detail-label">Epsilon (threshold)</span>
            <span class="detail-value">${document.getElementById('epsilonMeters').value} m</span>
        </div>
        ${trip.spatialCorridor && trip.spatialCorridor.length > 0 ? `
        <div class="detail-row" style="flex-direction:column;align-items:flex-start;">
            <span class="detail-label" style="margin-bottom:5px;">Expected Corridor (${trip.corridorStart || trip.camera_prev} to ${trip.camera_next}):</span>
            <div style="background:#e3f2fd;padding:8px;border-radius:4px;width:100%;font-family:monospace;font-size:0.75rem;word-break:break-all;border-left:4px solid #2196F3;">
                ${trip.spatialCorridor.join(' -> ')}
            </div>
            <div style="font-size:0.7rem;color:#666;margin-top:5px;">
                Blue dashed line on map shows this corridor. ${trip.spatialCorridor.length > 2 ? `(${trip.spatialCorridor.length - 2} intermediate waypoints)` : '(Direct route)'}
            </div>
        </div>
        ` : `
        <div class="detail-row">
            <span class="detail-label">Expected Corridor</span>
            <span class="detail-value" style="color:#f44336;">No route in matrix</span>
        </div>
        `}
        ${trip.breakReason ? `
        <div class="detail-row" style="flex-direction:column;align-items:flex-start;background:#ffebee;margin:5px -15px;padding:10px 15px;">
            <span class="detail-label" style="margin-bottom:5px;color:#c62828;">Break Reason</span>
            <span class="detail-value red" style="font-size:0.85rem;">${trip.breakReason}</span>
        </div>
        ` : ''}
    `;
    
    // Draw the expected corridor on the map
    drawCorridor(trip);
    
    // Zoom to show corridor and trip
    const prevSite = SITES[trip.camera_prev];
    const nextSite = SITES[trip.camera_next];
    if (prevSite && nextSite) {
        const bounds = new google.maps.LatLngBounds();
        bounds.extend({ lat: prevSite.lat, lng: prevSite.lon });
        bounds.extend({ lat: nextSite.lat, lng: nextSite.lon });
        
        // Include corridor sites in bounds
        if (trip.spatialCorridor) {
            trip.spatialCorridor.forEach(siteId => {
                const site = SITES[siteId];
                if (site) bounds.extend({ lat: site.lat, lng: site.lon });
            });
        }
        
        // Also include waypoints in bounds
        expectedWaypoints.forEach(wpId => {
            const wp = SITES[wpId];
            if (wp) bounds.extend({ lat: wp.lat, lng: wp.lon });
        });
        
        map.fitBounds(bounds, 100);
    }
}

// Draw the expected corridor from Google Matrix on the map
function drawCorridor(trip) {
    // Clear previous corridor
    clearCorridor();
    
    if (!trip.spatialCorridor || trip.spatialCorridor.length < 2) {
        return;
    }
    
    // Build the corridor path
    const corridorPath = [];
    trip.spatialCorridor.forEach(siteId => {
        const site = SITES[siteId];
        if (site) {
            corridorPath.push({ lat: site.lat, lng: site.lon });
        }
    });
    
    if (corridorPath.length < 2) return;
    
    // Draw corridor as a dashed line (the expected route from Google Matrix)
    corridorPolyline = new google.maps.Polyline({
        path: corridorPath,
        geodesic: true,
        strokeColor: '#2196F3',  // Blue for expected corridor
        strokeOpacity: 0.8,
        strokeWeight: 4,
        icons: [{
            icon: {
                path: 'M 0,-1 0,1',
                strokeOpacity: 1,
                strokeWeight: 4,
                scale: 3
            },
            offset: '0',
            repeat: '15px'
        }],
        map: map,
        zIndex: 5
    });
    
    // Add markers for corridor waypoints (intermediate sites on expected route)
    trip.spatialCorridor.forEach((siteId, idx) => {
        const site = SITES[siteId];
        if (!site) return;
        
        const isStart = idx === 0;
        const isEnd = idx === trip.spatialCorridor.length - 1;
        
        // Only mark intermediate waypoints (not start/end which are already marked)
        if (!isStart && !isEnd) {
            const marker = new google.maps.Marker({
                position: { lat: site.lat, lng: site.lon },
                map: map,
                icon: {
                    path: google.maps.SymbolPath.CIRCLE,
                    scale: 6,
                    fillColor: '#2196F3',
                    fillOpacity: 0.9,
                    strokeColor: '#0D47A1',
                    strokeWeight: 2
                },
                title: `Corridor waypoint: ${siteId}`,
                zIndex: 15
            });
            corridorMarkers.push(marker);
        }
    });
    
    // If spatial check failed, draw a line showing the distance from current site to corridor
    if (!trip.spatialOk && trip.spatialDistance !== null) {
        const currentSite = SITES[trip.camera_next];
        if (currentSite && corridorPath.length > 0) {
            // Find closest point on corridor to the current site
            const closestPoint = findClosestPointOnPath(currentSite.lat, currentSite.lon, corridorPath);
            
            // Draw a red line showing the distance
            const distanceLine = new google.maps.Polyline({
                path: [
                    { lat: currentSite.lat, lng: currentSite.lon },
                    closestPoint
                ],
                geodesic: true,
                strokeColor: '#F44336',  // Red for distance/error
                strokeOpacity: 1,
                strokeWeight: 3,
                map: map,
                zIndex: 20
            });
            corridorMarkers.push(distanceLine);
            
            // Add a label showing the distance
            const midLat = (currentSite.lat + closestPoint.lat) / 2;
            const midLng = (currentSite.lon + closestPoint.lng) / 2;
            
            const distLabel = new google.maps.Marker({
                position: { lat: midLat, lng: midLng },
                map: map,
                icon: {
                    path: google.maps.SymbolPath.CIRCLE,
                    scale: 0
                },
                label: {
                    text: Math.round(trip.spatialDistance) + 'm',
                    color: '#C62828',
                    fontWeight: 'bold',
                    fontSize: '12px'
                },
                zIndex: 25
            });
            corridorMarkers.push(distLabel);
        }
    }
}

// Find closest point on a path to a given point
function findClosestPointOnPath(lat, lon, path) {
    let minDist = Infinity;
    let closestPoint = path[0];
    
    for (let i = 0; i < path.length - 1; i++) {
        const p1 = path[i];
        const p2 = path[i + 1];
        
        // Find closest point on this segment
        const closest = closestPointOnSegment(lat, lon, p1.lat, p1.lng, p2.lat, p2.lng);
        const dist = haversineDistance(lat, lon, closest.lat, closest.lng);
        
        if (dist < minDist) {
            minDist = dist;
            closestPoint = closest;
        }
    }
    
    return closestPoint;
}

// Find closest point on a line segment to a given point
function closestPointOnSegment(lat, lon, lat1, lng1, lat2, lng2) {
    const dx = lat2 - lat1;
    const dy = lng2 - lng1;
    
    if (dx === 0 && dy === 0) {
        return { lat: lat1, lng: lng1 };
    }
    
    const t = Math.max(0, Math.min(1, ((lat - lat1) * dx + (lon - lng1) * dy) / (dx * dx + dy * dy)));
    
    return {
        lat: lat1 + t * dx,
        lng: lng1 + t * dy
    };
}

// Clear corridor visualization
function clearCorridor() {
    if (corridorPolyline) {
        corridorPolyline.setMap(null);
        corridorPolyline = null;
    }
    corridorMarkers.forEach(m => m.setMap(null));
    corridorMarkers = [];
}

// ============ MAIN FUNCTIONS ============
async function showRoute() {
    const vehicle = document.getElementById('vehicleSel').value;
    const startDate = document.getElementById('startDate').value;
    const endDate = document.getElementById('endDate').value;
    const startTime = document.getElementById('startTime').value;
    const endTime = document.getElementById('endTime').value;
    
    if (!vehicle) {
        alert('Please select a vehicle');
        return;
    }
    
    if (!startDate || !endDate) {
        alert('Please select start and end dates');
        return;
    }
    
    if (startDate > endDate) {
        alert('Start date must be before or equal to end date');
        return;
    }
    
    // Show active filter
    const filterDiv = document.getElementById('activeFilter');
    const filterInfo = document.getElementById('filterInfo');
    filterDiv.style.display = 'block';
    
    // Build clear filter description
    const filterStartDT = startDate + ' ' + startTime;
    const filterEndDT = endDate + ' ' + endTime;
    filterInfo.innerHTML = `
        <strong>${vehicle}</strong><br>
        <span style="font-size:0.8rem;">Trips that START and END between: <strong>${filterStartDT}</strong> and <strong>${filterEndDT}</strong></span>
    `;
    
    // Show loading state
    document.getElementById('tripList').innerHTML = '<div class="loading">Filtering trips...</div>';
    
    // Filter trips
    const filtered = filterTrips(vehicle, startDate, endDate, startTime, endTime);
    
    if (filtered.length === 0) {
        // Get some debug info
        const vehicleTrips = TRIPS.filter(t => t.plate === vehicle);
        const dates = vehicleTrips.map(t => t.t_prev.split('T')[0]);
        const uniqueDates = [...new Set(dates)].sort();
        
        let debugInfo = `<div class="no-data">
            <strong>No trips found for the selected filters.</strong><br><br>
            Vehicle <strong>${vehicle}</strong> has <strong>${vehicleTrips.length}</strong> total trips.<br>`;
        
        if (uniqueDates.length > 0) {
            debugInfo += `<br>Available dates: <strong>${uniqueDates[0]}</strong> to <strong>${uniqueDates[uniqueDates.length-1]}</strong><br>`;
        }
        
        debugInfo += `<br>Your filter: ${startDate} ${startTime} to ${endDate} ${endTime}<br>`;
        debugInfo += `<br><em>Adjust the date/time range to match available data.</em></div>`;
        
        document.getElementById('tripList').innerHTML = debugInfo;
        document.getElementById('pathTimeline').innerHTML = '<div class="no-data">No trips</div>';
        updateStats([]);
        clearMap();
        return;
    }
    
    // Segment route using precomputed Google Matrix data (instant - no API calls)
    currentRoute = segmentRoute(filtered);
    
    // Update UI
    updateStats(currentRoute);
    
    // Hide detail panel
    document.getElementById('detailPanel').classList.remove('visible');
    
    // Visualize (async - will snap to roads for display)
    await visualizeRoute(currentRoute);
    
    console.log('Showing route:', currentRoute.length, 'trips for', vehicle, 'from', startDate, 'to', endDate, 'time', startTime, '-', endTime);
}

async function showAllTrips() {
    const vehicle = document.getElementById('vehicleSel').value;
    
    // Show active filter
    const filterDiv = document.getElementById('activeFilter');
    const filterInfo = document.getElementById('filterInfo');
    filterDiv.style.display = 'block';
    if (vehicle) {
        filterInfo.innerHTML = `<strong>${vehicle}</strong> - All dates and times (no filter)`;
    } else {
        filterInfo.innerHTML = `<strong>All vehicles</strong> - All dates and times (no filter)`;
    }
    
    // Show loading state
    document.getElementById('tripList').innerHTML = '<div class="loading">Loading all trips...</div>';
    
    // Filter by vehicle only (no date/time filter)
    const filtered = filterTrips(vehicle, null, null, null, null);
    
    if (filtered.length === 0) {
        document.getElementById('tripList').innerHTML = '<div class="no-data">No trips found for this vehicle.</div>';
        updateStats([]);
        clearMap();
        return;
    }
    
    // Segment route using precomputed Google Matrix data (instant - no API calls)
    currentRoute = segmentRoute(filtered);
    
    // Update UI
    updateStats(currentRoute);
    
    // Hide detail panel
    document.getElementById('detailPanel').classList.remove('visible');
    
    // Visualize (async - will snap to roads for display)
    await visualizeRoute(currentRoute);
    
    console.log('Showing all trips:', currentRoute.length, 'trips');
}

// Initialize
document.getElementById('statVehicles').textContent = VEHICLES.length;
    </script>
    <script src="https://cdn.jsdelivr.net/gh/somanchiu/Keyless-Google-Maps-API@v7.1/mapsJavaScriptAPI.js" async defer></script>
</body>
</html>
