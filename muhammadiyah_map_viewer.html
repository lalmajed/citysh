<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Al Muhammadiyah Roads Map Viewer</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Arial, sans-serif; }
        
        #map { 
            position: absolute; 
            top: 0; 
            left: 0; 
            right: 0; 
            bottom: 0; 
            z-index: 1;
        }
        
        .controls {
            position: absolute;
            top: 10px;
            left: 60px;
            z-index: 1000;
            background: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            max-width: 350px;
        }
        
        .controls h2 {
            margin-bottom: 10px;
            color: #333;
            font-size: 16px;
        }
        
        .upload-area {
            border: 2px dashed #4CAF50;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            margin-bottom: 15px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .upload-area:hover {
            background: #e8f5e9;
            border-color: #2E7D32;
        }
        
        .upload-area.dragover {
            background: #c8e6c9;
            border-color: #1B5E20;
        }
        
        .upload-area input {
            display: none;
        }
        
        .btn {
            display: inline-block;
            padding: 10px 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px;
            transition: background 0.3s;
        }
        
        .btn:hover { background: #388E3C; }
        .btn.secondary { background: #2196F3; }
        .btn.secondary:hover { background: #1976D2; }
        .btn.danger { background: #f44336; }
        .btn.danger:hover { background: #d32f2f; }
        
        .legend {
            position: absolute;
            bottom: 30px;
            right: 10px;
            z-index: 1000;
            background: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .legend h3 {
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
            font-size: 12px;
        }
        
        .legend-color {
            width: 30px;
            height: 6px;
            margin-right: 8px;
            border-radius: 3px;
        }
        
        .stats {
            position: absolute;
            bottom: 30px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            max-width: 250px;
        }
        
        .stats h3 {
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 3px 0;
            font-size: 12px;
            border-bottom: 1px solid #eee;
        }
        
        .stat-row:last-child { border-bottom: none; }
        .stat-value { font-weight: bold; color: #4CAF50; }
        
        .file-list {
            margin-top: 10px;
            max-height: 150px;
            overflow-y: auto;
        }
        
        .file-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 10px;
            background: #f5f5f5;
            border-radius: 5px;
            margin: 5px 0;
            font-size: 12px;
        }
        
        .file-item .remove {
            color: #f44336;
            cursor: pointer;
            font-weight: bold;
        }
        
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            z-index: 2000;
            display: none;
        }
        
        .toast.show { display: block; }
        .toast.success { background: #4CAF50; }
        .toast.error { background: #f44336; }
        
        .layer-toggle {
            margin: 10px 0;
        }
        
        .layer-toggle label {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-size: 13px;
            padding: 5px 0;
        }
        
        .layer-toggle input {
            margin-right: 8px;
        }
        
        .quick-load {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #eee;
        }
        
        .quick-load h4 {
            font-size: 13px;
            margin-bottom: 8px;
            color: #666;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <div class="controls">
        <h2>üó∫Ô∏è Al Muhammadiyah Road Viewer</h2>
        
        <div class="upload-area" id="uploadArea">
            <input type="file" id="fileInput" accept=".geojson,.json,.csv" multiple>
            <p>üìÅ Drop GeoJSON/CSV files here</p>
            <p style="font-size: 12px; color: #666;">or click to browse</p>
        </div>
        
        <div class="layer-toggle">
            <label><input type="checkbox" id="showRoads" checked> Show Roads</label>
            <label><input type="checkbox" id="showLabels" checked> Show Labels</label>
            <label><input type="checkbox" id="highlightMajor" checked> Highlight Major Roads (20m+)</label>
        </div>
        
        <div class="file-list" id="fileList"></div>
        
        <div style="margin-top: 10px;">
            <button class="btn secondary" onclick="fitToData()">üìç Fit to Data</button>
            <button class="btn danger" onclick="clearAll()">üóëÔ∏è Clear All</button>
        </div>
        
        <div class="quick-load">
            <h4>Quick Load Local Files:</h4>
            <button class="btn" onclick="loadLocalFile('muhammadiyah_roads.geojson')">Roads GeoJSON</button>
            <button class="btn" onclick="loadLocalFile('muhammadiyah_roads_coords.csv')">Roads CSV</button>
        </div>
    </div>
    
    <div class="legend">
        <h3>üé® Road Width Legend</h3>
        <div class="legend-item"><div class="legend-color" style="background: #d32f2f;"></div> 36m (Major Arterial)</div>
        <div class="legend-item"><div class="legend-color" style="background: #ff5722;"></div> 30m (Arterial)</div>
        <div class="legend-item"><div class="legend-color" style="background: #ff9800;"></div> 25m (Collector)</div>
        <div class="legend-item"><div class="legend-color" style="background: #ffc107;"></div> 20m (Main Road)</div>
        <div class="legend-item"><div class="legend-color" style="background: #8bc34a;"></div> 15m (Secondary)</div>
        <div class="legend-item"><div class="legend-color" style="background: #4caf50;"></div> 12m (Local)</div>
        <div class="legend-item"><div class="legend-color" style="background: #009688;"></div> 10m (Minor)</div>
        <div class="legend-item"><div class="legend-color" style="background: #607d8b;"></div> 8m (Alley)</div>
    </div>
    
    <div class="stats" id="stats" style="display: none;">
        <h3>üìä Statistics</h3>
        <div id="statsContent"></div>
    </div>
    
    <div class="toast" id="toast"></div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // Initialize map centered on Al Muhammadiyah
        const map = L.map('map').setView([24.7245, 46.6753], 14);
        
        // Add tile layer
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap'
        }).addTo(map);
        
        // Layer groups
        let roadsLayer = L.layerGroup().addTo(map);
        let labelsLayer = L.layerGroup().addTo(map);
        let markersLayer = L.layerGroup().addTo(map);
        
        // Store loaded data
        let loadedFiles = [];
        let allFeatures = [];
        
        // Color scale for road widths
        function getColor(width) {
            if (width >= 36) return '#d32f2f';
            if (width >= 30) return '#ff5722';
            if (width >= 25) return '#ff9800';
            if (width >= 20) return '#ffc107';
            if (width >= 15) return '#8bc34a';
            if (width >= 12) return '#4caf50';
            if (width >= 10) return '#009688';
            return '#607d8b';
        }
        
        function getWeight(width) {
            if (width >= 30) return 6;
            if (width >= 20) return 5;
            if (width >= 15) return 4;
            if (width >= 10) return 3;
            return 2;
        }
        
        // Toast notification
        function showToast(msg, type = '') {
            const toast = document.getElementById('toast');
            toast.textContent = msg;
            toast.className = 'toast show ' + type;
            setTimeout(() => toast.className = 'toast', 3000);
        }
        
        // File upload handling
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        
        uploadArea.addEventListener('click', () => fileInput.click());
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        uploadArea.addEventListener('dragleave', () => uploadArea.classList.remove('dragover'));
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            handleFiles(e.dataTransfer.files);
        });
        fileInput.addEventListener('change', (e) => handleFiles(e.target.files));
        
        function handleFiles(files) {
            Array.from(files).forEach(file => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        if (file.name.endsWith('.csv')) {
                            processCSV(e.target.result, file.name);
                        } else {
                            processGeoJSON(JSON.parse(e.target.result), file.name);
                        }
                        showToast(`‚úÖ Loaded ${file.name}`, 'success');
                    } catch (err) {
                        showToast(`‚ùå Error: ${err.message}`, 'error');
                    }
                };
                reader.readAsText(file);
            });
        }
        
        function processGeoJSON(data, filename) {
            loadedFiles.push(filename);
            updateFileList();
            
            const features = data.features || [data];
            allFeatures = allFeatures.concat(features);
            
            features.forEach(feature => {
                if (feature.geometry) {
                    addFeatureToMap(feature);
                }
            });
            
            updateStats();
            fitToData();
        }
        
        function processCSV(csvText, filename) {
            loadedFiles.push(filename);
            updateFileList();
            
            const lines = csvText.trim().split('\n');
            const headers = lines[0].split(',').map(h => h.trim());
            
            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',');
                const obj = {};
                headers.forEach((h, idx) => obj[h] = values[idx]?.trim());
                
                // Check if it has coordinates
                const lat = parseFloat(obj.center_lat || obj.lat || obj.latitude);
                const lng = parseFloat(obj.center_lng || obj.lng || obj.longitude);
                
                if (!isNaN(lat) && !isNaN(lng)) {
                    const width = parseFloat(obj.width_m || obj.width || 10);
                    const name = obj.name_ar || obj.name || obj.road_name || 'Unknown';
                    
                    // Add marker
                    const marker = L.circleMarker([lat, lng], {
                        radius: Math.max(4, width / 4),
                        fillColor: getColor(width),
                        color: '#fff',
                        weight: 2,
                        fillOpacity: 0.8
                    });
                    
                    marker.bindPopup(`
                        <b>${name}</b><br>
                        Width: ${width}m<br>
                        ${obj.name_en ? 'English: ' + obj.name_en + '<br>' : ''}
                        ${obj.length_m ? 'Length: ' + obj.length_m + 'm<br>' : ''}
                        ${obj.num_lanes ? 'Lanes: ' + obj.num_lanes + '<br>' : ''}
                    `);
                    
                    markersLayer.addLayer(marker);
                    
                    allFeatures.push({
                        properties: obj,
                        geometry: { type: 'Point', coordinates: [lng, lat] }
                    });
                }
            }
            
            updateStats();
            fitToData();
        }
        
        function addFeatureToMap(feature) {
            const props = feature.properties || {};
            const width = parseFloat(props.width_m || props.width || props.WIDTH || 10);
            const name = props.name_ar || props.ROADCENTERLINENAME_AR || 'Unknown';
            const nameEn = props.name_en || props.ROADCENTERLINENAME_EN || '';
            
            const style = {
                color: getColor(width),
                weight: getWeight(width),
                opacity: 0.9
            };
            
            const highlightMajor = document.getElementById('highlightMajor').checked;
            if (highlightMajor && width >= 20) {
                style.weight = style.weight + 2;
                style.opacity = 1;
            }
            
            const layer = L.geoJSON(feature, {
                style: style,
                onEachFeature: (f, l) => {
                    l.bindPopup(`
                        <div style="direction: rtl; text-align: right;">
                            <b style="font-size: 14px;">${name}</b><br>
                            <span style="color: #666;">${nameEn}</span>
                        </div>
                        <hr style="margin: 8px 0;">
                        <b>Width:</b> ${width}m<br>
                        ${props.length_m ? '<b>Length:</b> ' + Math.round(props.length_m) + 'm<br>' : ''}
                        ${props.num_lanes ? '<b>Lanes:</b> ' + props.num_lanes + '<br>' : ''}
                        ${props.paved ? '<b>Paved:</b> ' + props.paved + '<br>' : ''}
                        ${props.category ? '<b>Category:</b> ' + props.category + '<br>' : ''}
                    `);
                    
                    l.on('mouseover', () => l.setStyle({ weight: style.weight + 3, color: '#000' }));
                    l.on('mouseout', () => l.setStyle(style));
                }
            });
            
            roadsLayer.addLayer(layer);
            
            // Add label for major roads
            if (width >= 20 && document.getElementById('showLabels').checked) {
                try {
                    const coords = feature.geometry.coordinates;
                    let midPoint;
                    if (feature.geometry.type === 'LineString') {
                        const mid = Math.floor(coords.length / 2);
                        midPoint = [coords[mid][1], coords[mid][0]];
                    } else if (feature.geometry.type === 'MultiLineString') {
                        const line = coords[0];
                        const mid = Math.floor(line.length / 2);
                        midPoint = [line[mid][1], line[mid][0]];
                    }
                    
                    if (midPoint) {
                        const label = L.marker(midPoint, {
                            icon: L.divIcon({
                                className: 'road-label',
                                html: `<div style="background: rgba(255,255,255,0.9); padding: 2px 6px; border-radius: 3px; font-size: 10px; white-space: nowrap; border: 1px solid ${getColor(width)};">${name}</div>`,
                                iconSize: null
                            })
                        });
                        labelsLayer.addLayer(label);
                    }
                } catch (e) {}
            }
        }
        
        function updateFileList() {
            const list = document.getElementById('fileList');
            list.innerHTML = loadedFiles.map((f, i) => `
                <div class="file-item">
                    <span>üìÑ ${f}</span>
                    <span class="remove" onclick="removeFile(${i})">‚úï</span>
                </div>
            `).join('');
        }
        
        function removeFile(index) {
            loadedFiles.splice(index, 1);
            updateFileList();
            // Note: This doesn't actually remove the data from map
            // Would need more complex tracking for that
        }
        
        function updateStats() {
            const stats = document.getElementById('stats');
            const content = document.getElementById('statsContent');
            
            if (allFeatures.length === 0) {
                stats.style.display = 'none';
                return;
            }
            
            stats.style.display = 'block';
            
            // Calculate stats
            const widthCounts = {};
            let totalLength = 0;
            
            allFeatures.forEach(f => {
                const props = f.properties || {};
                const width = parseFloat(props.width_m || props.width || props.WIDTH || 0);
                const length = parseFloat(props.length_m || props.LENGTH || 0);
                
                if (width > 0) {
                    widthCounts[width] = (widthCounts[width] || 0) + 1;
                }
                totalLength += length;
            });
            
            content.innerHTML = `
                <div class="stat-row">
                    <span>Total Roads:</span>
                    <span class="stat-value">${allFeatures.length}</span>
                </div>
                <div class="stat-row">
                    <span>Total Length:</span>
                    <span class="stat-value">${(totalLength / 1000).toFixed(2)} km</span>
                </div>
                <div class="stat-row">
                    <span>Major (20m+):</span>
                    <span class="stat-value">${Object.entries(widthCounts).filter(([w]) => parseFloat(w) >= 20).reduce((a, [,c]) => a + c, 0)}</span>
                </div>
                <div class="stat-row">
                    <span>Entry/Exit Est.:</span>
                    <span class="stat-value">~${allFeatures.length * 2}</span>
                </div>
            `;
        }
        
        function fitToData() {
            if (roadsLayer.getLayers().length > 0) {
                const bounds = roadsLayer.getBounds();
                if (bounds.isValid()) {
                    map.fitBounds(bounds, { padding: [50, 50] });
                }
            } else if (markersLayer.getLayers().length > 0) {
                const bounds = markersLayer.getBounds();
                if (bounds.isValid()) {
                    map.fitBounds(bounds, { padding: [50, 50] });
                }
            }
        }
        
        function clearAll() {
            roadsLayer.clearLayers();
            labelsLayer.clearLayers();
            markersLayer.clearLayers();
            loadedFiles = [];
            allFeatures = [];
            updateFileList();
            updateStats();
            showToast('üóëÔ∏è All data cleared');
        }
        
        // Toggle handlers
        document.getElementById('showRoads').addEventListener('change', (e) => {
            if (e.target.checked) {
                map.addLayer(roadsLayer);
            } else {
                map.removeLayer(roadsLayer);
            }
        });
        
        document.getElementById('showLabels').addEventListener('change', (e) => {
            if (e.target.checked) {
                map.addLayer(labelsLayer);
            } else {
                map.removeLayer(labelsLayer);
            }
        });
        
        document.getElementById('highlightMajor').addEventListener('change', () => {
            // Refresh display
            const features = [...allFeatures];
            roadsLayer.clearLayers();
            labelsLayer.clearLayers();
            features.forEach(f => {
                if (f.geometry && f.geometry.type !== 'Point') {
                    addFeatureToMap(f);
                }
            });
        });
        
        // Load local file (for quick loading)
        async function loadLocalFile(filename) {
            try {
                const response = await fetch(filename);
                if (!response.ok) throw new Error('File not found');
                
                const text = await response.text();
                
                if (filename.endsWith('.csv')) {
                    processCSV(text, filename);
                } else {
                    processGeoJSON(JSON.parse(text), filename);
                }
                
                showToast(`‚úÖ Loaded ${filename}`, 'success');
            } catch (err) {
                showToast(`‚ùå Could not load ${filename} - drag & drop the file instead`, 'error');
            }
        }
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'f' || e.key === 'F') fitToData();
            if (e.key === 'c' || e.key === 'C') clearAll();
        });
    </script>
</body>
</html>
