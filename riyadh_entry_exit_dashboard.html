<!DOCTYPE html>
<html>
<head>
    <title>Entry/Exit Dashboard</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: Arial, sans-serif; }
        
        #sidebar {
            position: fixed; left: 0; top: 0; width: 300px; height: 100vh;
            background: rgba(22, 33, 62, 0.97); padding: 12px; overflow-y: auto; z-index: 1000; color: white;
        }
        
        h1 { font-size: 14px; color: #e94560; margin-bottom: 10px; }
        h3 { font-size: 10px; background: #e94560; padding: 4px 8px; margin: 10px 0 6px 0; border-radius: 3px; }
        
        .box { background: #0f3460; padding: 10px; border-radius: 5px; margin-bottom: 8px; }
        .box-title { font-size: 11px; font-weight: bold; margin-bottom: 6px; }
        .box input[type="file"] { width: 100%; padding: 6px; background: #1a1a2e; border: 1px dashed #e94560; color: white; border-radius: 3px; font-size: 10px; }
        .status { font-size: 10px; color: #4caf50; margin-top: 4px; }
        .status.wait { color: #666; }
        
        .slider-row { margin: 6px 0; }
        .slider-row label { font-size: 10px; display: block; margin-bottom: 3px; }
        .slider-row input[type="range"] { width: 100%; }
        .slider-row .val { float: right; color: #e94560; font-weight: bold; }
        
        .color-row { margin: 8px 0; display: flex; align-items: center; gap: 8px; }
        .color-row label { font-size: 11px; flex: 1; }
        .color-row input[type="color"] { width: 50px; height: 28px; border: none; cursor: pointer; border-radius: 4px; }
        
        .stats { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; }
        .stat { background: #0f3460; padding: 8px; border-radius: 4px; text-align: center; }
        .stat .n { font-size: 20px; font-weight: bold; color: #e94560; }
        .stat .l { font-size: 9px; color: #888; }
        .stat.main { grid-column: span 2; background: #e94560; }
        .stat.main .n { color: white; font-size: 26px; }
        .stat.main .l { color: #fcc; }
        
        button { width: 100%; padding: 10px; background: #e94560; border: none; color: white; border-radius: 4px; cursor: pointer; font-weight: bold; margin: 3px 0; font-size: 11px; }
        button:disabled { background: #444; }
        
        .list { max-height: 120px; overflow-y: auto; font-size: 10px; }
        .item { display: flex; align-items: center; padding: 4px; background: #0f3460; margin: 2px 0; border-radius: 3px; cursor: pointer; }
        .item:hover { background: #1a4a7a; }
        .item .dot { width: 20px; height: 20px; background: #e94560; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 8px; font-weight: bold; margin-right: 6px; border: 2px solid white; }
        .item .name { flex: 1; direction: rtl; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-size: 10px; }
        
        #map { position: fixed; left: 300px; top: 0; right: 0; bottom: 0; z-index: 1; }
        
        .leaflet-popup-content { direction: rtl; }
        
        .drag-handle {
            background: #e94560 !important;
            border: 3px solid white !important;
            cursor: move !important;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        
        .info-box {
            background: rgba(22, 33, 62, 0.9);
            padding: 8px 12px;
            border-radius: 5px;
            color: white;
            font-size: 11px;
        }
    </style>
</head>
<body>
    <div id="sidebar">
        <h1>Entry/Exit Point Finder</h1>
        
        <div class="box">
            <div class="box-title">1. Load Roads GeoJSON</div>
            <input type="file" id="fileRoads" accept=".geojson,.json">
            <div class="status wait" id="statusRoads">No roads loaded</div>
        </div>
        
        <div class="box">
            <div class="box-title">2. Load District Boundary</div>
            <input type="file" id="fileDistrict" accept=".geojson,.json">
            <div class="status wait" id="statusDistrict">No district loaded</div>
        </div>
        
        <h3>BOUNDARY</h3>
        <div class="box">
            <div style="font-size:10px;color:#4caf50;margin-bottom:8px;">DRAG the red handles on the map to resize boundary!</div>
            <button onclick="resetBoundary()">Reset to Original</button>
            
            <div class="color-row" style="margin-top:10px;">
                <label>Color</label>
                <input type="color" id="colorDistrict" value="#e94560">
            </div>
            <div class="slider-row">
                <label>Fill Opacity <span class="val" id="valOpacity">20%</span></label>
                <input type="range" id="sliderOpacity" min="0" max="80" value="20" step="5">
            </div>
        </div>
        
        <h3>ROADS</h3>
        <div class="box">
            <div class="slider-row">
                <label>Road Extension <span class="val" id="valExt">300m</span></label>
                <input type="range" id="sliderExt" min="0" max="1500" value="300" step="50">
            </div>
            <div class="slider-row">
                <label>Min Road Width <span class="val" id="valWidth">0m</span></label>
                <input type="range" id="sliderWidth" min="0" max="40" value="0" step="2">
            </div>
            <div class="slider-row">
                <label>Dot Size <span class="val" id="valDot">12</span></label>
                <input type="range" id="sliderDot" min="6" max="25" value="12">
            </div>
        </div>
        
        <h3>RESULTS</h3>
        <div class="stats">
            <div class="stat main"><div class="n" id="sTotal">0</div><div class="l">ENTRY/EXIT POINTS</div></div>
            <div class="stat"><div class="n" id="sMajor">0</div><div class="l">Major 30m+</div></div>
            <div class="stat"><div class="n" id="sOther">0</div><div class="l">Other</div></div>
        </div>
        
        <h3>EXPORT</h3>
        <button id="btnExport" onclick="exportData()" disabled>Download Entry/Exit GeoJSON</button>
        <button onclick="exportBoundary()">Download Cropped Boundary</button>
        
        <h3>POINT LIST</h3>
        <div class="list" id="list"><div style="color:#666;text-align:center;padding:15px;">Load roads + district</div></div>
    </div>
    
    <div id="map"></div>

    <script>
        // Initialize map
        const map = L.map('map', {
            center: [24.73, 46.65],
            zoom: 14,
            zoomControl: true
        });
        
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'OpenStreetMap',
            maxZoom: 19
        }).addTo(map);
        
        // Data
        let roads = [];
        let originalBoundary = [];
        let entryExits = [];
        
        // Editable rectangle bounds
        let bounds = { north: 0, south: 0, east: 0, west: 0 };
        
        // Layers
        let roadsLayer = L.layerGroup().addTo(map);
        let boundaryLayer = L.layerGroup().addTo(map);
        let pointsLayer = L.layerGroup().addTo(map);
        
        // Draggable markers for boundary
        let dragMarkers = {
            north: null,
            south: null,
            east: null,
            west: null,
            nw: null,
            ne: null,
            sw: null,
            se: null
        };
        
        // Get boundary as rectangle coordinates
        function getBoundaryRect() {
            return [
                [bounds.west, bounds.north],
                [bounds.east, bounds.north],
                [bounds.east, bounds.south],
                [bounds.west, bounds.south],
                [bounds.west, bounds.north]
            ];
        }
        
        // Create draggable markers
        function createDragMarkers() {
            // Remove existing
            Object.values(dragMarkers).forEach(m => { if (m) map.removeLayer(m); });
            
            const handleIcon = L.divIcon({
                className: 'drag-handle',
                iconSize: [16, 16],
                iconAnchor: [8, 8]
            });
            
            const midLat = (bounds.north + bounds.south) / 2;
            const midLng = (bounds.east + bounds.west) / 2;
            
            // Edge handles
            dragMarkers.north = L.marker([bounds.north, midLng], { icon: handleIcon, draggable: true }).addTo(map);
            dragMarkers.south = L.marker([bounds.south, midLng], { icon: handleIcon, draggable: true }).addTo(map);
            dragMarkers.east = L.marker([midLat, bounds.east], { icon: handleIcon, draggable: true }).addTo(map);
            dragMarkers.west = L.marker([midLat, bounds.west], { icon: handleIcon, draggable: true }).addTo(map);
            
            // Corner handles
            dragMarkers.nw = L.marker([bounds.north, bounds.west], { icon: handleIcon, draggable: true }).addTo(map);
            dragMarkers.ne = L.marker([bounds.north, bounds.east], { icon: handleIcon, draggable: true }).addTo(map);
            dragMarkers.sw = L.marker([bounds.south, bounds.west], { icon: handleIcon, draggable: true }).addTo(map);
            dragMarkers.se = L.marker([bounds.south, bounds.east], { icon: handleIcon, draggable: true }).addTo(map);
            
            // Drag handlers
            dragMarkers.north.on('drag', function(e) {
                bounds.north = e.latlng.lat;
                updateAfterDrag();
            });
            dragMarkers.south.on('drag', function(e) {
                bounds.south = e.latlng.lat;
                updateAfterDrag();
            });
            dragMarkers.east.on('drag', function(e) {
                bounds.east = e.latlng.lng;
                updateAfterDrag();
            });
            dragMarkers.west.on('drag', function(e) {
                bounds.west = e.latlng.lng;
                updateAfterDrag();
            });
            
            // Corner drag handlers
            dragMarkers.nw.on('drag', function(e) {
                bounds.north = e.latlng.lat;
                bounds.west = e.latlng.lng;
                updateAfterDrag();
            });
            dragMarkers.ne.on('drag', function(e) {
                bounds.north = e.latlng.lat;
                bounds.east = e.latlng.lng;
                updateAfterDrag();
            });
            dragMarkers.sw.on('drag', function(e) {
                bounds.south = e.latlng.lat;
                bounds.west = e.latlng.lng;
                updateAfterDrag();
            });
            dragMarkers.se.on('drag', function(e) {
                bounds.south = e.latlng.lat;
                bounds.east = e.latlng.lng;
                updateAfterDrag();
            });
        }
        
        function updateAfterDrag() {
            // Update marker positions
            const midLat = (bounds.north + bounds.south) / 2;
            const midLng = (bounds.east + bounds.west) / 2;
            
            dragMarkers.north.setLatLng([bounds.north, midLng]);
            dragMarkers.south.setLatLng([bounds.south, midLng]);
            dragMarkers.east.setLatLng([midLat, bounds.east]);
            dragMarkers.west.setLatLng([midLat, bounds.west]);
            dragMarkers.nw.setLatLng([bounds.north, bounds.west]);
            dragMarkers.ne.setLatLng([bounds.north, bounds.east]);
            dragMarkers.sw.setLatLng([bounds.south, bounds.west]);
            dragMarkers.se.setLatLng([bounds.south, bounds.east]);
            
            findCrossings();
        }
        
        function resetBoundary() {
            if (!originalBoundary.length) return;
            const lngs = originalBoundary.map(c => c[0]);
            const lats = originalBoundary.map(c => c[1]);
            bounds = {
                north: Math.max(...lats),
                south: Math.min(...lats),
                east: Math.max(...lngs),
                west: Math.min(...lngs)
            };
            createDragMarkers();
            findCrossings();
        }
        
        // Get lines from geometry
        function getLines(geometry) {
            if (!geometry) return [];
            if (geometry.type === 'LineString') return [geometry.coordinates];
            if (geometry.type === 'MultiLineString') return geometry.coordinates;
            return [];
        }
        
        // Line intersection
        function lineIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
            const d = (y4-y3)*(x2-x1) - (x4-x3)*(y2-y1);
            if (Math.abs(d) < 1e-12) return null;
            const u = ((x4-x3)*(y1-y3) - (y4-y3)*(x1-x3)) / d;
            const v = ((x2-x1)*(y1-y3) - (y2-y1)*(x1-x3)) / d;
            if (u >= 0 && u <= 1 && v >= 0 && v <= 1) {
                return [x1 + u*(x2-x1), y1 + u*(y2-y1)];
            }
            return null;
        }
        
        // Extend line
        function extendLine(x1, y1, x2, y2, meters) {
            const deg = meters / 111000;
            const dx = x2 - x1, dy = y2 - y1;
            const len = Math.sqrt(dx*dx + dy*dy);
            if (len < 1e-8) return { x1, y1, x2, y2 };
            const ux = dx/len, uy = dy/len;
            return { x1: x1 - ux*deg, y1: y1 - uy*deg, x2: x2 + ux*deg, y2: y2 + uy*deg };
        }
        
        // Find crossings
        function findCrossings() {
            entryExits = [];
            const boundary = getBoundaryRect();
            if (!boundary.length || !roads.length) { updateUI(); render(); return; }
            
            const ext = parseInt(document.getElementById('sliderExt').value);
            const minW = parseInt(document.getElementById('sliderWidth').value);
            const seen = {};
            
            roads.forEach(road => {
                const props = road.properties || {};
                const w = parseFloat(props.width_m || props.WIDTH || props.width || 8);
                const name = props.name_ar || props.ROADCENTERLINENAME_AR || props.name_en || props.name || 'Road';
                
                if (w < minW) return;
                
                const lines = getLines(road.geometry);
                
                lines.forEach(coords => {
                    if (!coords || coords.length < 2) return;
                    
                    const extStart = extendLine(coords[1][0], coords[1][1], coords[0][0], coords[0][1], ext);
                    const last = coords.length - 1;
                    const extEnd = extendLine(coords[last-1][0], coords[last-1][1], coords[last][0], coords[last][1], ext);
                    
                    const extCoords = [[extStart.x2, extStart.y2], ...coords, [extEnd.x2, extEnd.y2]];
                    
                    for (let i = 0; i < extCoords.length - 1; i++) {
                        const [rx1, ry1] = extCoords[i];
                        const [rx2, ry2] = extCoords[i + 1];
                        
                        for (let j = 0; j < boundary.length - 1; j++) {
                            const [bx1, by1] = boundary[j];
                            const [bx2, by2] = boundary[j + 1];
                            
                            const hit = lineIntersect(rx1, ry1, rx2, ry2, bx1, by1, bx2, by2);
                            if (hit) {
                                const key = hit[0].toFixed(5) + '_' + hit[1].toFixed(5);
                                if (!seen[key]) {
                                    seen[key] = true;
                                    entryExits.push({ lng: hit[0], lat: hit[1], name, width: w });
                                }
                            }
                        }
                    }
                });
            });
            
            entryExits.sort((a, b) => b.width - a.width);
            updateUI();
            render();
        }
        
        function updateUI() {
            document.getElementById('sTotal').textContent = entryExits.length;
            document.getElementById('sMajor').textContent = entryExits.filter(p => p.width >= 30).length;
            document.getElementById('sOther').textContent = entryExits.filter(p => p.width < 30).length;
            document.getElementById('btnExport').disabled = !entryExits.length;
            
            const list = document.getElementById('list');
            if (!entryExits.length) {
                list.innerHTML = '<div style="color:#666;text-align:center;padding:15px;">Drag boundary or adjust extension</div>';
                return;
            }
            
            let html = '';
            const max = Math.min(40, entryExits.length);
            for (let i = 0; i < max; i++) {
                const p = entryExits[i];
                html += `<div class="item" onclick="gotoPoint(${i})"><div class="dot">${Math.round(p.width)}</div><div class="name">${p.name}</div></div>`;
            }
            if (entryExits.length > 40) html += `<div style="color:#888;text-align:center;padding:5px;">+${entryExits.length - 40} more</div>`;
            list.innerHTML = html;
        }
        
        function gotoPoint(i) {
            const p = entryExits[i];
            if (p) map.setView([p.lat, p.lng], 17);
        }
        
        function render() {
            roadsLayer.clearLayers();
            boundaryLayer.clearLayers();
            pointsLayer.clearLayers();
            
            const boundary = getBoundaryRect();
            const ext = parseInt(document.getElementById('sliderExt').value);
            const minW = parseInt(document.getElementById('sliderWidth').value);
            const dotSize = parseInt(document.getElementById('sliderDot').value);
            const districtColor = document.getElementById('colorDistrict').value;
            const fillOpacity = parseInt(document.getElementById('sliderOpacity').value) / 100;
            
            // Draw roads
            roads.forEach(road => {
                const props = road.properties || {};
                const w = parseFloat(props.width_m || props.WIDTH || props.width || 8);
                if (w < minW) return;
                
                const lines = getLines(road.geometry);
                const color = w >= 30 ? '#e94560' : w >= 15 ? '#ff9800' : '#4caf50';
                const weight = w >= 30 ? 4 : w >= 15 ? 3 : 2;
                
                lines.forEach(coords => {
                    if (!coords || coords.length < 2) return;
                    
                    const extStart = extendLine(coords[1][0], coords[1][1], coords[0][0], coords[0][1], ext);
                    const last = coords.length - 1;
                    const extEnd = extendLine(coords[last-1][0], coords[last-1][1], coords[last][0], coords[last][1], ext);
                    
                    const extCoords = [[extStart.x2, extStart.y2], ...coords, [extEnd.x2, extEnd.y2]];
                    const latlngs = extCoords.map(c => [c[1], c[0]]);
                    
                    const line = L.polyline(latlngs, { color, weight, opacity: 0.8 });
                    line.bindPopup(`<b>${props.name_ar || props.name_en || 'Road'}</b><br>Width: ${w}m`);
                    line.addTo(roadsLayer);
                });
            });
            
            // Draw boundary rectangle
            if (bounds.north) {
                const latlngs = boundary.map(c => [c[1], c[0]]);
                L.polygon(latlngs, {
                    color: districtColor,
                    weight: 3,
                    fillColor: districtColor,
                    fillOpacity: fillOpacity,
                    dashArray: '10, 5'
                }).addTo(boundaryLayer);
            }
            
            // Draw entry/exit points
            entryExits.forEach((p) => {
                const r = p.width >= 40 ? dotSize * 1.3 : p.width >= 20 ? dotSize : dotSize * 0.8;
                
                L.circleMarker([p.lat, p.lng], {
                    radius: r,
                    fillColor: '#e94560',
                    color: 'white',
                    weight: 2,
                    fillOpacity: 1
                }).bindPopup(`<b>${p.name}</b><br>Width: ${p.width}m`).addTo(pointsLayer);
                
                const icon = L.divIcon({
                    className: 'width-label',
                    html: `<div style="background:#e94560;color:white;border-radius:50%;width:${r*2}px;height:${r*2}px;display:flex;align-items:center;justify-content:center;font-size:${Math.max(8,r*0.7)}px;font-weight:bold;border:2px solid white;">${Math.round(p.width)}</div>`,
                    iconSize: [r*2, r*2],
                    iconAnchor: [r, r]
                });
                L.marker([p.lat, p.lng], { icon }).addTo(pointsLayer);
            });
        }
        
        // File handlers
        document.getElementById('fileRoads').addEventListener('change', async function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            try {
                const text = await file.text();
                const data = JSON.parse(text);
                roads = (data.features || [data]).filter(r => r.geometry && (r.geometry.type === 'LineString' || r.geometry.type === 'MultiLineString'));
                
                document.getElementById('statusRoads').textContent = roads.length + ' roads loaded';
                document.getElementById('statusRoads').className = 'status';
                
                if (roads.length > 0) {
                    let sumLat = 0, sumLng = 0, count = 0;
                    roads.slice(0, 100).forEach(r => {
                        getLines(r.geometry).forEach(coords => {
                            if (coords && coords.length > 0) {
                                const mid = coords[Math.floor(coords.length / 2)];
                                if (mid) { sumLng += mid[0]; sumLat += mid[1]; count++; }
                            }
                        });
                    });
                    if (count > 0) map.setView([sumLat / count, sumLng / count], 14);
                }
                
                findCrossings();
            } catch (err) {
                alert('Error: ' + err.message);
            }
        });
        
        document.getElementById('fileDistrict').addEventListener('change', async function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            try {
                const text = await file.text();
                const data = JSON.parse(text);
                const feat = data.features ? data.features[0] : data;
                const geom = feat.geometry;
                
                originalBoundary = geom.type === 'Polygon' ? geom.coordinates[0] : geom.coordinates[0][0];
                
                // Set initial bounds
                const lngs = originalBoundary.map(c => c[0]);
                const lats = originalBoundary.map(c => c[1]);
                bounds = {
                    north: Math.max(...lats),
                    south: Math.min(...lats),
                    east: Math.max(...lngs),
                    west: Math.min(...lngs)
                };
                
                document.getElementById('statusDistrict').textContent = 'Loaded - DRAG handles to resize!';
                document.getElementById('statusDistrict').className = 'status';
                
                // Center and create drag handles
                map.setView([(bounds.north + bounds.south) / 2, (bounds.east + bounds.west) / 2], 14);
                createDragMarkers();
                findCrossings();
            } catch (err) {
                alert('Error: ' + err.message);
            }
        });
        
        // Sliders
        document.getElementById('sliderExt').addEventListener('input', function() {
            document.getElementById('valExt').textContent = this.value + 'm';
            findCrossings();
        });
        document.getElementById('sliderWidth').addEventListener('input', function() {
            document.getElementById('valWidth').textContent = this.value + 'm';
            findCrossings();
        });
        document.getElementById('sliderDot').addEventListener('input', function() {
            document.getElementById('valDot').textContent = this.value;
            render();
        });
        document.getElementById('sliderOpacity').addEventListener('input', function() {
            document.getElementById('valOpacity').textContent = this.value + '%';
            render();
        });
        document.getElementById('colorDistrict').addEventListener('input', render);
        
        // Export
        function exportData() {
            if (!entryExits.length) return;
            const geojson = {
                type: 'FeatureCollection',
                features: entryExits.map(p => ({
                    type: 'Feature',
                    geometry: { type: 'Point', coordinates: [p.lng, p.lat] },
                    properties: { name_ar: p.name, width_m: p.width, road_class: p.width >= 30 ? 'Major' : 'Other' }
                }))
            };
            const a = document.createElement('a');
            a.href = URL.createObjectURL(new Blob([JSON.stringify(geojson, null, 2)], { type: 'application/json' }));
            a.download = 'entry_exit_points.geojson';
            a.click();
        }
        
        function exportBoundary() {
            const boundary = getBoundaryRect();
            const geojson = {
                type: 'FeatureCollection',
                features: [{
                    type: 'Feature',
                    geometry: { type: 'Polygon', coordinates: [boundary] },
                    properties: { name: 'Cropped Boundary' }
                }]
            };
            const a = document.createElement('a');
            a.href = URL.createObjectURL(new Blob([JSON.stringify(geojson, null, 2)], { type: 'application/json' }));
            a.download = 'cropped_boundary.geojson';
            a.click();
        }
    </script>
</body>
</html>
