<!DOCTYPE html>
<html>
<head>
    <title>Entry/Exit Dashboard</title>
    <meta charset="utf-8">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: Arial, sans-serif; }
        
        #sidebar {
            position: fixed; left: 0; top: 0; width: 300px; height: 100vh;
            background: rgba(22, 33, 62, 0.97); padding: 12px; overflow-y: auto; z-index: 1000; color: white;
        }
        
        h1 { font-size: 14px; color: #e94560; margin-bottom: 10px; }
        h3 { font-size: 10px; background: #e94560; padding: 4px 8px; margin: 10px 0 6px 0; border-radius: 3px; }
        
        .box { background: #0f3460; padding: 10px; border-radius: 5px; margin-bottom: 8px; }
        .box-title { font-size: 11px; font-weight: bold; margin-bottom: 6px; }
        .box input[type="file"] { width: 100%; padding: 6px; background: #1a1a2e; border: 1px dashed #e94560; color: white; border-radius: 3px; font-size: 10px; }
        .status { font-size: 10px; color: #4caf50; margin-top: 4px; }
        .status.wait { color: #666; }
        
        .slider-row { margin: 8px 0; }
        .slider-row label { font-size: 11px; display: block; margin-bottom: 4px; }
        .slider-row input { width: 100%; }
        .slider-row .val { float: right; color: #e94560; font-weight: bold; }
        
        .stats { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; }
        .stat { background: #0f3460; padding: 8px; border-radius: 4px; text-align: center; }
        .stat .n { font-size: 20px; font-weight: bold; color: #e94560; }
        .stat .l { font-size: 9px; color: #888; }
        .stat.main { grid-column: span 2; background: #e94560; }
        .stat.main .n { color: white; font-size: 26px; }
        .stat.main .l { color: #fcc; }
        
        button { width: 100%; padding: 10px; background: #e94560; border: none; color: white; border-radius: 4px; cursor: pointer; font-weight: bold; margin: 3px 0; }
        button:disabled { background: #444; }
        
        .list { max-height: 130px; overflow-y: auto; font-size: 10px; }
        .item { display: flex; align-items: center; padding: 4px; background: #0f3460; margin: 2px 0; border-radius: 3px; cursor: pointer; }
        .item:hover { background: #1a4a7a; }
        .item .dot { width: 20px; height: 20px; background: #e94560; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 8px; font-weight: bold; margin-right: 6px; border: 2px solid white; }
        .item .name { flex: 1; direction: rtl; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-size: 10px; }
        
        #mapContainer { position: fixed; left: 300px; top: 0; right: 0; bottom: 0; }
        #map { width: 100%; height: 100%; background: #e5e3df; }
        #overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; z-index: 100; }
        
        #loading {
            position: fixed; left: 300px; top: 0; right: 0; bottom: 0;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 500;
        }
        #loading.hidden { display: none; }
        .spinner { width: 50px; height: 50px; border: 4px solid #333; border-top-color: #e94560; border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        #loadText { color: #e94560; margin-top: 20px; font-size: 16px; }
        #loadProgress { color: #888; margin-top: 8px; font-size: 12px; }
    </style>
</head>
<body>
    <div id="sidebar">
        <h1>Entry/Exit Point Finder</h1>
        
        <div class="box">
            <div class="box-title">1. Load Roads GeoJSON</div>
            <input type="file" id="fileRoads" accept=".geojson,.json">
            <div class="status wait" id="statusRoads">No roads loaded</div>
        </div>
        
        <div class="box">
            <div class="box-title">2. Load District Boundary</div>
            <input type="file" id="fileDistrict" accept=".geojson,.json">
            <div class="status wait" id="statusDistrict">No district loaded</div>
        </div>
        
        <h3>EXTEND ROADS</h3>
        <div class="box">
            <div class="slider-row">
                <label>Road Extension <span class="val" id="valExt">300m</span></label>
                <input type="range" id="sliderExt" min="0" max="1500" value="300" step="50">
            </div>
            <div style="font-size:9px;color:#888;">Make roads longer to find where they cross boundary</div>
        </div>
        
        <div class="box">
            <div class="slider-row">
                <label>Min Road Width <span class="val" id="valWidth">10m</span></label>
                <input type="range" id="sliderWidth" min="0" max="40" value="10" step="2">
            </div>
            <div class="slider-row">
                <label>Dot Size <span class="val" id="valDot">15</span></label>
                <input type="range" id="sliderDot" min="8" max="30" value="15">
            </div>
        </div>
        
        <h3>RESULTS</h3>
        <div class="stats">
            <div class="stat main"><div class="n" id="sTotal">0</div><div class="l">ENTRY/EXIT POINTS</div></div>
            <div class="stat"><div class="n" id="sMajor">0</div><div class="l">Major 30m+</div></div>
            <div class="stat"><div class="n" id="sOther">0</div><div class="l">Other</div></div>
        </div>
        
        <h3>EXPORT</h3>
        <button id="btnExport" onclick="exportData()" disabled>Download GeoJSON</button>
        
        <h3>LIST</h3>
        <div class="list" id="list"><div style="color:#666;text-align:center;padding:15px;">Load data</div></div>
    </div>
    
    <div id="loading">
        <div class="spinner"></div>
        <div id="loadText">Loading Google Maps...</div>
        <div id="loadProgress">Initializing...</div>
    </div>
    
    <div id="mapContainer">
        <div id="map"></div>
        <canvas id="overlay"></canvas>
    </div>

    <script>
        // Global variables
        let map;
        let roads = [];
        let boundary = [];
        let entryExits = [];
        
        // Google Maps loading - same as dynamic map
        let mapsLoadAttempts = 0;
        const MAX_LOAD_ATTEMPTS = 150;
        
        // Wait for Google Maps API - exact same logic as dynamic map
        function waitForGoogleMaps() {
            mapsLoadAttempts++;
            document.getElementById('loadProgress').textContent = 'Attempt ' + mapsLoadAttempts + '/' + MAX_LOAD_ATTEMPTS;
            
            if (typeof google !== 'undefined' && google.maps && google.maps.Map) {
                console.log('Google Maps API loaded successfully after', mapsLoadAttempts, 'attempts');
                initMap();
            } else if (mapsLoadAttempts < MAX_LOAD_ATTEMPTS) {
                setTimeout(waitForGoogleMaps, 100);
            } else {
                console.error('Google Maps API failed to load after', MAX_LOAD_ATTEMPTS, 'attempts');
                document.getElementById('loadText').textContent = 'Google Maps loading slow...';
                document.getElementById('loadProgress').textContent = 'Still trying, please wait...';
                // Keep trying
                setTimeout(waitForGoogleMaps, 100);
            }
        }
        
        // Start checking for Google Maps
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', waitForGoogleMaps);
        } else {
            waitForGoogleMaps();
        }
        
        // Canvas
        const canvas = document.getElementById('overlay');
        const ctx = canvas.getContext('2d');
        
        function resizeCanvas() {
            const container = document.getElementById('mapContainer');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            render();
        }
        window.addEventListener('resize', resizeCanvas);
        
        // Initialize map
        function initMap() {
            try {
                map = new google.maps.Map(document.getElementById('map'), {
                    center: { lat: 24.73, lng: 46.65 },
                    zoom: 14,
                    gestureHandling: 'greedy',
                    zoomControl: true,
                    mapTypeControl: true,
                    scaleControl: true,
                    streetViewControl: false,
                    fullscreenControl: true
                });
                
                document.getElementById('loading').classList.add('hidden');
                resizeCanvas();
                
                map.addListener('idle', render);
                map.addListener('bounds_changed', render);
                map.addListener('zoom_changed', render);
                
                console.log('Map initialized successfully');
            } catch (e) {
                console.error('Map init error:', e);
                document.getElementById('loadText').textContent = 'Error: ' + e.message;
            }
        }
        
        // Convert lat/lng to pixel
        function toPixel(lat, lng) {
            if (!map) return { x: -9999, y: -9999 };
            const proj = map.getProjection();
            const bounds = map.getBounds();
            if (!proj || !bounds) return { x: -9999, y: -9999 };
            
            const ne = bounds.getNorthEast();
            const sw = bounds.getSouthWest();
            const topRight = proj.fromLatLngToPoint(ne);
            const bottomLeft = proj.fromLatLngToPoint(sw);
            const scale = Math.pow(2, map.getZoom());
            const worldPoint = proj.fromLatLngToPoint(new google.maps.LatLng(lat, lng));
            
            return {
                x: (worldPoint.x - bottomLeft.x) * scale,
                y: (worldPoint.y - topRight.y) * scale
            };
        }
        
        // Line intersection
        function lineIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
            const d = (y4-y3)*(x2-x1) - (x4-x3)*(y2-y1);
            if (Math.abs(d) < 1e-12) return null;
            const u = ((x4-x3)*(y1-y3) - (y4-y3)*(x1-x3)) / d;
            const v = ((x2-x1)*(y1-y3) - (y2-y1)*(x1-x3)) / d;
            if (u >= 0 && u <= 1 && v >= 0 && v <= 1) {
                return [x1 + u*(x2-x1), y1 + u*(y2-y1)];
            }
            return null;
        }
        
        // Extend road line by meters
        function extendLine(x1, y1, x2, y2, meters) {
            const deg = meters / 111000; // meters to degrees
            const dx = x2 - x1, dy = y2 - y1;
            const len = Math.sqrt(dx*dx + dy*dy);
            if (len < 1e-8) return { x1, y1, x2, y2 };
            const ux = dx/len, uy = dy/len;
            return {
                x1: x1 - ux * deg,
                y1: y1 - uy * deg,
                x2: x2 + ux * deg,
                y2: y2 + uy * deg
            };
        }
        
        // Find where extended roads cross boundary
        function findCrossings() {
            entryExits = [];
            if (!boundary.length || !roads.length) { updateUI(); return; }
            
            const ext = parseInt(document.getElementById('sliderExt').value);
            const minW = parseInt(document.getElementById('sliderWidth').value);
            const seen = {};
            
            roads.forEach(road => {
                const props = road.properties || {};
                const w = parseFloat(props.width_m || props.WIDTH || props.width || 10);
                const name = props.name_ar || props.ROADCENTERLINENAME_AR || props.name_en || 'Road';
                
                if (w < minW) return;
                
                const geom = road.geometry;
                if (!geom) return;
                
                const lines = geom.type === 'LineString' ? [geom.coordinates] : (geom.coordinates || []);
                
                lines.forEach(coords => {
                    if (!coords || coords.length < 2) return;
                    
                    // Extend at both ends
                    const extStart = extendLine(coords[1][0], coords[1][1], coords[0][0], coords[0][1], ext);
                    const last = coords.length - 1;
                    const extEnd = extendLine(coords[last-1][0], coords[last-1][1], coords[last][0], coords[last][1], ext);
                    
                    // Build extended coordinates
                    const extCoords = [[extStart.x2, extStart.y2], ...coords, [extEnd.x2, extEnd.y2]];
                    
                    // Check each segment against boundary
                    for (let i = 0; i < extCoords.length - 1; i++) {
                        const [x1, y1] = extCoords[i];
                        const [x2, y2] = extCoords[i + 1];
                        
                        for (let j = 0; j < boundary.length - 1; j++) {
                            const [bx1, by1] = boundary[j];
                            const [bx2, by2] = boundary[j + 1];
                            
                            const hit = lineIntersect(x1, y1, x2, y2, bx1, by1, bx2, by2);
                            if (hit) {
                                const key = hit[0].toFixed(5) + '_' + hit[1].toFixed(5);
                                if (!seen[key]) {
                                    seen[key] = true;
                                    entryExits.push({ lng: hit[0], lat: hit[1], name, width: w });
                                }
                            }
                        }
                    }
                });
            });
            
            entryExits.sort((a, b) => b.width - a.width);
            updateUI();
            render();
        }
        
        // Update UI
        function updateUI() {
            document.getElementById('sTotal').textContent = entryExits.length;
            document.getElementById('sMajor').textContent = entryExits.filter(p => p.width >= 30).length;
            document.getElementById('sOther').textContent = entryExits.filter(p => p.width < 30).length;
            document.getElementById('btnExport').disabled = !entryExits.length;
            
            const list = document.getElementById('list');
            if (!entryExits.length) {
                const msg = roads.length ? (boundary.length ? 'Increase extension slider' : 'Load district') : 'Load roads first';
                list.innerHTML = '<div style="color:#666;text-align:center;padding:15px;">' + msg + '</div>';
                return;
            }
            
            let html = '';
            const max = Math.min(35, entryExits.length);
            for (let i = 0; i < max; i++) {
                const p = entryExits[i];
                html += `<div class="item" onclick="gotoPoint(${i})"><div class="dot">${Math.round(p.width)}</div><div class="name">${p.name}</div></div>`;
            }
            if (entryExits.length > 35) {
                html += `<div style="color:#888;text-align:center;padding:5px;">+${entryExits.length - 35} more</div>`;
            }
            list.innerHTML = html;
        }
        
        function gotoPoint(i) {
            const p = entryExits[i];
            if (map && p) {
                map.setCenter({ lat: p.lat, lng: p.lng });
                map.setZoom(17);
            }
        }
        
        // Render on canvas
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (!map) return;
            
            const ext = parseInt(document.getElementById('sliderExt').value);
            const minW = parseInt(document.getElementById('sliderWidth').value);
            const dotSize = parseInt(document.getElementById('sliderDot').value);
            
            // Draw extended roads
            roads.forEach(road => {
                const props = road.properties || {};
                const w = parseFloat(props.width_m || props.WIDTH || props.width || 10);
                if (w < minW) return;
                
                const geom = road.geometry;
                if (!geom) return;
                
                const lines = geom.type === 'LineString' ? [geom.coordinates] : (geom.coordinates || []);
                
                lines.forEach(coords => {
                    if (!coords || coords.length < 2) return;
                    
                    // Extend
                    const extStart = extendLine(coords[1][0], coords[1][1], coords[0][0], coords[0][1], ext);
                    const last = coords.length - 1;
                    const extEnd = extendLine(coords[last-1][0], coords[last-1][1], coords[last][0], coords[last][1], ext);
                    
                    const extCoords = [[extStart.x2, extStart.y2], ...coords, [extEnd.x2, extEnd.y2]];
                    
                    ctx.beginPath();
                    extCoords.forEach((c, i) => {
                        const px = toPixel(c[1], c[0]);
                        if (i === 0) ctx.moveTo(px.x, px.y);
                        else ctx.lineTo(px.x, px.y);
                    });
                    
                    ctx.strokeStyle = w >= 30 ? '#e94560' : w >= 15 ? '#ff9800' : '#4caf50';
                    ctx.lineWidth = w >= 30 ? 5 : w >= 15 ? 3 : 2;
                    ctx.lineCap = 'round';
                    ctx.stroke();
                });
            });
            
            // Draw boundary
            if (boundary.length) {
                ctx.beginPath();
                boundary.forEach((c, i) => {
                    const px = toPixel(c[1], c[0]);
                    if (i === 0) ctx.moveTo(px.x, px.y);
                    else ctx.lineTo(px.x, px.y);
                });
                ctx.closePath();
                ctx.fillStyle = 'rgba(233, 69, 96, 0.1)';
                ctx.fill();
                ctx.strokeStyle = '#e94560';
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // Draw RED DOTS at crossings
            entryExits.forEach(p => {
                const px = toPixel(p.lat, p.lng);
                const r = p.width >= 40 ? dotSize * 1.4 : p.width >= 20 ? dotSize * 1.1 : dotSize * 0.85;
                
                // Glow
                ctx.beginPath();
                ctx.arc(px.x, px.y, r + 5, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(233, 69, 96, 0.5)';
                ctx.fill();
                
                // Red dot
                ctx.beginPath();
                ctx.arc(px.x, px.y, r, 0, Math.PI * 2);
                ctx.fillStyle = '#e94560';
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Width number
                ctx.fillStyle = 'white';
                ctx.font = `bold ${Math.max(9, r * 0.6)}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(Math.round(p.width), px.x, px.y);
            });
        }
        
        // File handlers
        document.getElementById('fileRoads').addEventListener('change', async function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            try {
                const text = await file.text();
                const data = JSON.parse(text);
                roads = data.features || [data];
                
                document.getElementById('statusRoads').textContent = roads.length + ' roads loaded';
                document.getElementById('statusRoads').className = 'status';
                
                // Center map on roads
                if (map && roads.length > 0) {
                    let sumLat = 0, sumLng = 0, count = 0;
                    roads.slice(0, 50).forEach(r => {
                        const g = r.geometry;
                        if (!g) return;
                        const lines = g.type === 'LineString' ? [g.coordinates] : (g.coordinates || []);
                        lines.forEach(cs => {
                            const mid = cs[Math.floor(cs.length / 2)];
                            sumLng += mid[0]; sumLat += mid[1]; count++;
                        });
                    });
                    if (count > 0) {
                        map.setCenter({ lat: sumLat / count, lng: sumLng / count });
                        map.setZoom(14);
                    }
                }
                
                findCrossings();
            } catch (err) {
                alert('Error loading roads: ' + err.message);
            }
        });
        
        document.getElementById('fileDistrict').addEventListener('change', async function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            try {
                const text = await file.text();
                const data = JSON.parse(text);
                const feat = data.features ? data.features[0] : data;
                const geom = feat.geometry;
                
                boundary = geom.type === 'Polygon' ? geom.coordinates[0] : geom.coordinates[0][0];
                
                document.getElementById('statusDistrict').textContent = 'Loaded (' + boundary.length + ' points)';
                document.getElementById('statusDistrict').className = 'status';
                
                // Center map on district
                if (map && boundary.length > 0) {
                    let sumLat = 0, sumLng = 0;
                    boundary.forEach(c => { sumLng += c[0]; sumLat += c[1]; });
                    map.setCenter({ lat: sumLat / boundary.length, lng: sumLng / boundary.length });
                    map.setZoom(14);
                }
                
                findCrossings();
            } catch (err) {
                alert('Error loading district: ' + err.message);
            }
        });
        
        // Sliders
        document.getElementById('sliderExt').addEventListener('input', function() {
            document.getElementById('valExt').textContent = this.value + 'm';
            findCrossings();
        });
        document.getElementById('sliderWidth').addEventListener('input', function() {
            document.getElementById('valWidth').textContent = this.value + 'm';
            findCrossings();
        });
        document.getElementById('sliderDot').addEventListener('input', function() {
            document.getElementById('valDot').textContent = this.value;
            render();
        });
        
        // Export
        function exportData() {
            if (!entryExits.length) return;
            
            const geojson = {
                type: 'FeatureCollection',
                features: entryExits.map(p => ({
                    type: 'Feature',
                    geometry: { type: 'Point', coordinates: [p.lng, p.lat] },
                    properties: { name_ar: p.name, width_m: p.width, road_class: p.width >= 30 ? 'Major' : 'Other' }
                }))
            };
            
            const a = document.createElement('a');
            a.href = URL.createObjectURL(new Blob([JSON.stringify(geojson, null, 2)], { type: 'application/json' }));
            a.download = 'entry_exit_points.geojson';
            a.click();
        }
        
        // Expose initMap globally for compatibility
        window.initMap = initMap;
    </script>
    
    <!-- Keyless Google Maps API - same as dynamic map -->
    <script src="https://somanchiu.github.io/Keyless-Google-Maps-API/mapsJavaScriptAPI.js" async defer></script>
</body>
</html>
