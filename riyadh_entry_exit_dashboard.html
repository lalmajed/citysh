<!DOCTYPE html>
<html>
<head>
    <title>Entry/Exit Dashboard</title>
    <meta charset="utf-8">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: Arial, sans-serif; }
        
        #sidebar {
            position: fixed;
            left: 0; top: 0;
            width: 300px;
            height: 100vh;
            background: rgba(22, 33, 62, 0.95);
            padding: 15px;
            overflow-y: auto;
            z-index: 1000;
            color: white;
        }
        
        h1 { font-size: 15px; color: #e94560; margin-bottom: 12px; }
        h3 { font-size: 11px; background: #e94560; padding: 4px 8px; margin: 12px 0 8px 0; border-radius: 3px; }
        
        .box { background: #0f3460; padding: 10px; border-radius: 5px; margin-bottom: 8px; }
        .box input[type="file"] { width: 100%; padding: 6px; background: #1a1a2e; border: 1px dashed #e94560; color: white; border-radius: 3px; font-size: 11px; }
        .box .status { font-size: 10px; color: #4caf50; margin-top: 4px; }
        .box .status.wait { color: #888; }
        
        .slider-row { margin: 8px 0; }
        .slider-row label { font-size: 11px; display: block; margin-bottom: 3px; }
        .slider-row input { width: 100%; }
        .slider-row .val { float: right; color: #e94560; font-weight: bold; }
        
        .stats { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
        .stat { background: #0f3460; padding: 8px; border-radius: 4px; text-align: center; }
        .stat .n { font-size: 22px; font-weight: bold; color: #e94560; }
        .stat .l { font-size: 9px; color: #888; }
        .stat.main { grid-column: span 2; background: #e94560; }
        .stat.main .n { color: white; font-size: 28px; }
        .stat.main .l { color: #fcc; }
        
        button { width: 100%; padding: 10px; background: #e94560; border: none; color: white; border-radius: 4px; cursor: pointer; font-weight: bold; font-size: 12px; }
        button:disabled { background: #444; }
        
        .list { max-height: 150px; overflow-y: auto; font-size: 10px; }
        .item { display: flex; align-items: center; padding: 5px; background: #0f3460; margin: 2px 0; border-radius: 3px; cursor: pointer; }
        .item:hover { background: #1a4a7a; }
        .item .dot { width: 22px; height: 22px; background: #e94560; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 9px; font-weight: bold; margin-right: 6px; border: 2px solid white; }
        .item .name { flex: 1; direction: rtl; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        
        #map { position: fixed; left: 300px; top: 0; right: 0; bottom: 0; }
        #canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
    </style>
</head>
<body>
    <div id="sidebar">
        <h1>Entry/Exit Point Finder</h1>
        
        <div class="box">
            <b style="font-size:11px;">1. Load Roads</b>
            <input type="file" id="fileRoads" accept=".geojson,.json">
            <div class="status wait" id="statusRoads">No roads</div>
        </div>
        
        <div class="box">
            <b style="font-size:11px;">2. Load District Boundary</b>
            <input type="file" id="fileDistrict" accept=".geojson,.json">
            <div class="status wait" id="statusDistrict">No district</div>
        </div>
        
        <h3>EXTEND ROADS</h3>
        <div class="box">
            <div class="slider-row">
                <label>Road Extension Length <span class="val" id="valExt">200m</span></label>
                <input type="range" id="sliderExt" min="0" max="1000" value="200" step="50">
            </div>
            <div style="font-size:10px;color:#888;margin-top:5px;">Extend roads to see where they cross the boundary</div>
        </div>
        
        <div class="box">
            <div class="slider-row">
                <label>Min Road Width <span class="val" id="valWidth">10m</span></label>
                <input type="range" id="sliderWidth" min="0" max="40" value="10" step="2">
            </div>
            <div class="slider-row">
                <label>Dot Size <span class="val" id="valDot">14</span></label>
                <input type="range" id="sliderDot" min="6" max="30" value="14">
            </div>
        </div>
        
        <h3>ENTRY/EXIT POINTS</h3>
        <div class="stats">
            <div class="stat main"><div class="n" id="sTotal">0</div><div class="l">BOUNDARY CROSSINGS</div></div>
            <div class="stat"><div class="n" id="sMajor">0</div><div class="l">Major 30m+</div></div>
            <div class="stat"><div class="n" id="sOther">0</div><div class="l">Other</div></div>
        </div>
        
        <h3>EXPORT</h3>
        <button id="btnExport" onclick="exportData()" disabled>Download GeoJSON</button>
        
        <h3>POINTS LIST</h3>
        <div class="list" id="list"><div style="color:#666;text-align:center;padding:15px;">Load data first</div></div>
    </div>
    
    <div id="map"></div>
    <canvas id="canvas"></canvas>

<script>
let map, roads = [], boundary = [], entryExits = [];
let mapReady = false;

// Wait for Google Maps
function initMap() {
    map = new google.maps.Map(document.getElementById('map'), {
        center: { lat: 24.73, lng: 46.65 },
        zoom: 14,
        mapTypeId: 'roadmap',
        styles: [
            { featureType: "poi", stylers: [{ visibility: "off" }] },
            { featureType: "transit", stylers: [{ visibility: "off" }] }
        ]
    });
    
    mapReady = true;
    map.addListener('bounds_changed', draw);
    map.addListener('zoom_changed', draw);
    map.addListener('center_changed', draw);
    
    resizeCanvas();
}

// Canvas
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

function resizeCanvas() {
    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;
    draw();
}
window.onresize = resizeCanvas;

// Lat/Lng to pixel
function toPixel(lat, lng) {
    if (!mapReady) return { x: 0, y: 0 };
    const proj = map.getProjection();
    if (!proj) return { x: 0, y: 0 };
    const bounds = map.getBounds();
    if (!bounds) return { x: 0, y: 0 };
    
    const ne = bounds.getNorthEast();
    const sw = bounds.getSouthWest();
    const topRight = proj.fromLatLngToPoint(ne);
    const bottomLeft = proj.fromLatLngToPoint(sw);
    const scale = Math.pow(2, map.getZoom());
    const worldPoint = proj.fromLatLngToPoint(new google.maps.LatLng(lat, lng));
    
    return {
        x: (worldPoint.x - bottomLeft.x) * scale,
        y: (worldPoint.y - topRight.y) * scale
    };
}

// Line intersection
function intersect(x1,y1,x2,y2,x3,y3,x4,y4) {
    const d = (y4-y3)*(x2-x1)-(x4-x3)*(y2-y1);
    if (Math.abs(d) < 1e-12) return null;
    const u = ((x4-x3)*(y1-y3)-(y4-y3)*(x1-x3))/d;
    const v = ((x2-x1)*(y1-y3)-(y2-y1)*(x1-x3))/d;
    if (u>=0 && u<=1 && v>=0 && v<=1) return [x1+u*(x2-x1), y1+u*(y2-y1)];
    return null;
}

// Extend a line segment
function extendLine(x1, y1, x2, y2, meters) {
    const deg = meters / 111000; // rough conversion
    const dx = x2 - x1, dy = y2 - y1;
    const len = Math.sqrt(dx*dx + dy*dy);
    if (len < 0.00001) return { x1, y1, x2, y2 };
    const ux = dx/len, uy = dy/len;
    return {
        x1: x1 - ux * deg,
        y1: y1 - uy * deg,
        x2: x2 + ux * deg,
        y2: y2 + uy * deg
    };
}

// Find crossings
function findCrossings() {
    entryExits = [];
    if (!boundary.length || !roads.length) { updateUI(); return; }
    
    const ext = parseInt(document.getElementById('sliderExt').value);
    const minW = parseInt(document.getElementById('sliderWidth').value);
    const seen = new Set();
    
    roads.forEach(road => {
        const p = road.properties || {};
        const w = parseFloat(p.width_m || p.WIDTH || p.width || 10);
        const name = p.name_ar || p.ROADCENTERLINENAME_AR || p.name_en || 'Road';
        if (w < minW) return;
        
        const g = road.geometry;
        if (!g) return;
        const lines = g.type === 'LineString' ? [g.coordinates] : (g.coordinates || []);
        
        lines.forEach(coords => {
            if (!coords || coords.length < 2) return;
            
            // Extend the road at both ends
            const first = coords[0], second = coords[1];
            const last = coords[coords.length-1], prev = coords[coords.length-2];
            
            const extStart = extendLine(second[0], second[1], first[0], first[1], ext);
            const extEnd = extendLine(prev[0], prev[1], last[0], last[1], ext);
            
            // Build extended coordinates
            const extCoords = [
                [extStart.x2, extStart.y2],
                ...coords,
                [extEnd.x2, extEnd.y2]
            ];
            
            // Check each segment
            for (let i = 0; i < extCoords.length - 1; i++) {
                const [x1, y1] = extCoords[i];
                const [x2, y2] = extCoords[i+1];
                
                for (let j = 0; j < boundary.length - 1; j++) {
                    const [bx1, by1] = boundary[j];
                    const [bx2, by2] = boundary[j+1];
                    
                    const hit = intersect(x1,y1,x2,y2,bx1,by1,bx2,by2);
                    if (hit) {
                        const key = hit[0].toFixed(5)+'_'+hit[1].toFixed(5);
                        if (!seen.has(key)) {
                            seen.add(key);
                            entryExits.push({ lng: hit[0], lat: hit[1], name, width: w });
                        }
                    }
                }
            }
        });
    });
    
    entryExits.sort((a,b) => b.width - a.width);
    updateUI();
    draw();
}

// Update UI
function updateUI() {
    document.getElementById('sTotal').textContent = entryExits.length;
    document.getElementById('sMajor').textContent = entryExits.filter(p => p.width >= 30).length;
    document.getElementById('sOther').textContent = entryExits.filter(p => p.width < 30).length;
    document.getElementById('btnExport').disabled = !entryExits.length;
    
    const list = document.getElementById('list');
    if (!entryExits.length) {
        list.innerHTML = '<div style="color:#666;text-align:center;padding:15px;">'+(roads.length?(boundary.length?'Increase extension':'Load district'):'Load roads')+'</div>';
        return;
    }
    list.innerHTML = entryExits.slice(0,40).map((p,i) => 
        `<div class="item" onclick="goto(${i})"><div class="dot">${Math.round(p.width)}</div><div class="name">${p.name}</div></div>`
    ).join('') + (entryExits.length > 40 ? '<div style="color:#888;text-align:center;padding:5px;">+more</div>' : '');
}

function goto(i) {
    const p = entryExits[i];
    map.setCenter({ lat: p.lat, lng: p.lng });
    map.setZoom(17);
}

// Draw
function draw() {
    if (!mapReady) return;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    const ext = parseInt(document.getElementById('sliderExt').value);
    const minW = parseInt(document.getElementById('sliderWidth').value);
    const dotSize = parseInt(document.getElementById('sliderDot').value);
    
    // Draw extended roads
    roads.forEach(road => {
        const p = road.properties || {};
        const w = parseFloat(p.width_m || p.WIDTH || p.width || 10);
        if (w < minW) return;
        
        const g = road.geometry;
        if (!g) return;
        const lines = g.type === 'LineString' ? [g.coordinates] : (g.coordinates || []);
        
        lines.forEach(coords => {
            if (!coords || coords.length < 2) return;
            
            // Extend
            const first = coords[0], second = coords[1];
            const last = coords[coords.length-1], prev = coords[coords.length-2];
            const extStart = extendLine(second[0], second[1], first[0], first[1], ext);
            const extEnd = extendLine(prev[0], prev[1], last[0], last[1], ext);
            
            const extCoords = [[extStart.x2, extStart.y2], ...coords, [extEnd.x2, extEnd.y2]];
            
            ctx.beginPath();
            extCoords.forEach(([lng, lat], i) => {
                const px = toPixel(lat, lng);
                if (i === 0) ctx.moveTo(px.x, px.y);
                else ctx.lineTo(px.x, px.y);
            });
            ctx.strokeStyle = w >= 30 ? '#e94560' : w >= 15 ? '#ff9800' : '#4caf50';
            ctx.lineWidth = w >= 30 ? 5 : w >= 15 ? 3.5 : 2;
            ctx.lineCap = 'round';
            ctx.stroke();
        });
    });
    
    // Draw boundary
    if (boundary.length) {
        ctx.beginPath();
        boundary.forEach(([lng, lat], i) => {
            const px = toPixel(lat, lng);
            if (i === 0) ctx.moveTo(px.x, px.y);
            else ctx.lineTo(px.x, px.y);
        });
        ctx.closePath();
        ctx.fillStyle = 'rgba(233,69,96,0.1)';
        ctx.fill();
        ctx.strokeStyle = '#e94560';
        ctx.lineWidth = 3;
        ctx.setLineDash([10, 5]);
        ctx.stroke();
        ctx.setLineDash([]);
    }
    
    // Draw entry/exit RED DOTS
    entryExits.forEach(p => {
        const px = toPixel(p.lat, p.lng);
        const r = p.width >= 40 ? dotSize * 1.4 : p.width >= 20 ? dotSize * 1.1 : dotSize * 0.9;
        
        // Glow
        ctx.beginPath();
        ctx.arc(px.x, px.y, r + 5, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(233,69,96,0.5)';
        ctx.fill();
        
        // Red dot
        ctx.beginPath();
        ctx.arc(px.x, px.y, r, 0, Math.PI * 2);
        ctx.fillStyle = '#e94560';
        ctx.fill();
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Width
        ctx.fillStyle = 'white';
        ctx.font = `bold ${Math.max(9, r*0.65)}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(Math.round(p.width), px.x, px.y);
    });
}

// File handlers
document.getElementById('fileRoads').onchange = async function(e) {
    const file = e.target.files[0];
    if (!file) return;
    try {
        const data = JSON.parse(await file.text());
        roads = data.features || [data];
        document.getElementById('statusRoads').textContent = roads.length + ' roads';
        document.getElementById('statusRoads').className = 'status';
        
        // Center map on roads
        let sumLat = 0, sumLng = 0, count = 0;
        roads.forEach(r => {
            const g = r.geometry;
            if (!g) return;
            (g.type === 'LineString' ? [g.coordinates] : g.coordinates || []).forEach(coords => {
                coords.forEach(([lng, lat]) => { sumLng += lng; sumLat += lat; count++; });
            });
        });
        if (count && mapReady) {
            map.setCenter({ lat: sumLat/count, lng: sumLng/count });
            map.setZoom(14);
        }
        
        findCrossings();
    } catch(err) { alert('Error: ' + err.message); }
};

document.getElementById('fileDistrict').onchange = async function(e) {
    const file = e.target.files[0];
    if (!file) return;
    try {
        const data = JSON.parse(await file.text());
        const feat = data.features ? data.features[0] : data;
        const geom = feat.geometry;
        boundary = geom.type === 'Polygon' ? geom.coordinates[0] : geom.coordinates[0][0];
        
        document.getElementById('statusDistrict').textContent = 'Loaded (' + boundary.length + ' pts)';
        document.getElementById('statusDistrict').className = 'status';
        
        // Center on district
        let sumLat = 0, sumLng = 0;
        boundary.forEach(([lng, lat]) => { sumLng += lng; sumLat += lat; });
        if (mapReady) {
            map.setCenter({ lat: sumLat/boundary.length, lng: sumLng/boundary.length });
        }
        
        findCrossings();
    } catch(err) { alert('Error: ' + err.message); }
};

// Sliders
document.getElementById('sliderExt').oninput = function() {
    document.getElementById('valExt').textContent = this.value + 'm';
    findCrossings();
};
document.getElementById('sliderWidth').oninput = function() {
    document.getElementById('valWidth').textContent = this.value + 'm';
    findCrossings();
};
document.getElementById('sliderDot').oninput = function() {
    document.getElementById('valDot').textContent = this.value;
    draw();
};

// Export
function exportData() {
    if (!entryExits.length) return;
    const geojson = {
        type: 'FeatureCollection',
        features: entryExits.map(p => ({
            type: 'Feature',
            geometry: { type: 'Point', coordinates: [p.lng, p.lat] },
            properties: { name_ar: p.name, width_m: p.width, road_class: p.width >= 30 ? 'Major' : 'Other' }
        }))
    };
    const a = document.createElement('a');
    a.href = URL.createObjectURL(new Blob([JSON.stringify(geojson,null,2)], {type:'application/json'}));
    a.download = 'entry_exit_points.geojson';
    a.click();
}

// Load Google Maps
function loadGoogleMaps() {
    const checkGoogle = setInterval(() => {
        if (window.google && window.google.maps) {
            clearInterval(checkGoogle);
            initMap();
        }
    }, 100);
    
    setTimeout(() => {
        clearInterval(checkGoogle);
        if (!mapReady) {
            document.getElementById('map').innerHTML = '<div style="padding:50px;color:#e94560;text-align:center;font-size:18px;">Google Maps loading... Please wait or refresh</div>';
        }
    }, 15000);
}

loadGoogleMaps();
</script>
<script src="https://somanchiu.github.io/Keyless-Google-Maps-API/mapsJavaScriptAPI.js" async defer></script>
</body>
</html>
