<!DOCTYPE html>
<html>
<head>
    <title>Riyadh Map - Dynamic Counts</title>
    <meta charset="utf-8">
    <meta name="viewport" content="initial-scale=1.0, width=device-width">
    <!-- Leaflet CSS & JS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Arial, sans-serif; }
        #map { position: absolute; top: 0; bottom: 0; left: 0; right: 0; }
        
        .panel {
            position: absolute; top: 10px; left: 10px;
            background: white; padding: 12px; border-radius: 10px;
            box-shadow: 0 2px 15px rgba(0,0,0,0.2); z-index: 1000;
            max-width: 380px; max-height: 95vh; overflow-y: auto; font-size: 12px;
        }
        .panel h2 { color: #1a73e8; margin-bottom: 8px; font-size: 15px; }
        
        .section { margin: 8px 0; border: 1px solid #e0e0e0; border-radius: 8px; overflow: hidden; }
        .section-header {
            background: #f5f5f5; padding: 8px 10px; cursor: pointer;
            display: flex; justify-content: space-between; align-items: center;
            font-weight: 600; font-size: 12px;
        }
        .section-header:hover { background: #e8e8e8; }
        .section-content { padding: 8px; display: none; }
        .section-content.open { display: block; }
        
        .stats-grid { display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 6px; margin: 8px 0; }
        .stat-box { padding: 8px; border-radius: 6px; text-align: center; color: white; }
        .stat-box .num { font-size: 1.2em; font-weight: bold; }
        .stat-box .lbl { font-size: 9px; opacity: 0.9; }
        .stat-box.apt { background: #2196F3; }
        .stat-box.villa { background: #4CAF50; }
        .stat-box.other { background: #FF9800; }
        .stat-box.poi { background: #9C27B0; }
        
        .dynamic-stats { background: #e8f5e9; border: 2px solid #4caf50; border-radius: 8px; padding: 10px; margin: 8px 0; }
        .dynamic-stats h3 { color: #2e7d32; font-size: 13px; margin-bottom: 8px; }
        .dynamic-stats .row { display: flex; justify-content: space-between; padding: 3px 0; font-size: 11px; }
        .dynamic-stats .row.total { font-weight: bold; border-top: 1px solid #a5d6a7; padding-top: 5px; margin-top: 5px; }
        
        .district-stats { background: #fff3e0; border: 2px solid #ff9800; border-radius: 8px; padding: 10px; margin: 8px 0; display: none; }
        .district-stats.active { display: block; }
        .district-stats h3 { color: #e65100; font-size: 13px; margin-bottom: 8px; }
        .district-stats .row { display: flex; justify-content: space-between; padding: 3px 0; font-size: 11px; }
        .district-stats .row.total { font-weight: bold; border-top: 1px solid #ffcc80; padding-top: 5px; margin-top: 5px; }
        
        .layer-control { padding: 8px; margin: 5px 0; background: #f9f9f9; border-radius: 6px; }
        .layer-control .header { display: flex; align-items: center; gap: 8px; margin-bottom: 5px; }
        .layer-control .dot { width: 14px; height: 14px; border-radius: 50%; }
        .layer-control .name { font-weight: 600; flex: 1; }
        .layer-control .count { font-size: 10px; color: #666; }
        .layer-control input[type="range"] { width: 100%; margin: 2px 0; }
        
        #canvas { position: absolute; top: 0; left: 0; pointer-events: none; z-index: 450; }
        
        .btn { padding: 8px 12px; margin: 3px 0; cursor: pointer; border: 1px solid #ddd; border-radius: 4px; font-size: 11px; width: 100%; }
        .btn-primary { background: #1a73e8; color: white; border: none; }
        .btn-success { background: #28a745; color: white; border: none; }
        
        .loading-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.8); z-index: 9999;
            display: flex; align-items: center; justify-content: center;
            color: white; font-size: 18px; flex-direction: column; gap: 20px;
        }
        .loading-overlay.hidden { display: none; }
        .progress-bar { width: 300px; height: 20px; background: #333; border-radius: 10px; overflow: hidden; }
        .progress-fill { height: 100%; background: #4CAF50; transition: width 0.3s; }
        
        .district-list { max-height: 120px; overflow-y: auto; }
        .district-item { padding: 4px 8px; margin: 2px 0; background: #f5f5f5; border-radius: 4px; cursor: pointer; font-size: 10px; }
        .district-item:hover { background: #e3f2fd; }
        .district-item.selected { background: #1a73e8; color: white; }
        
        .search-box { width: 100%; padding: 5px; border: 1px solid #ddd; border-radius: 4px; font-size: 11px; margin-bottom: 5px; }
        
        .file-input { margin: 5px 0; }
        .file-input label { display: block; font-weight: 600; font-size: 10px; margin-bottom: 2px; }
        .file-input input[type="file"] { font-size: 9px; width: 100%; }
        .file-status { font-size: 9px; color: #666; }
        .file-status.loaded { color: #28a745; font-weight: bold; }
        
        .poi-cats { max-height: 120px; overflow-y: auto; margin-top: 5px; }
        .poi-cat { display: flex; align-items: center; gap: 5px; padding: 3px 5px; font-size: 10px; cursor: pointer; }
        .poi-cat:hover { background: #f0f0f0; }
        .poi-cat .cnt { margin-left: auto; color: #999; }
        
        .info-popup {
            position: absolute; background: white; padding: 12px 15px; border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3); z-index: 2000; min-width: 280px; max-width: 350px;
            font-size: 12px; display: none; border-left: 4px solid #1a73e8;
        }
        .info-popup.show { display: block; }
        .info-popup h3 { margin: 0 0 8px 0; color: #1a73e8; font-size: 14px; }
        .info-popup .close { position: absolute; top: 5px; right: 8px; cursor: pointer; color: #999; font-size: 18px; }
        .info-popup .close:hover { color: #333; }
        .info-popup table { width: 100%; border-collapse: collapse; }
        .info-popup td { padding: 4px 5px; border-bottom: 1px solid #eee; font-size: 11px; }
        .info-popup td:first-child { font-weight: 600; color: #555; width: 35%; }
        .info-popup .type-badge { display: inline-block; padding: 2px 8px; border-radius: 10px; color: white; font-size: 10px; }
        .info-popup .type-apt { background: #2196F3; }
        .info-popup .type-villa { background: #4CAF50; }
        .info-popup .type-other { background: #FF9800; }
        .info-popup .type-poi { background: #9C27B0; }
        
        .click-toggle { background: #fff3e0; padding: 8px; border-radius: 6px; margin: 8px 0; }
        .click-toggle label { display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 11px; }
    </style>
</head>
<body>
    <div id="loadingOverlay" class="loading-overlay hidden">
        <div id="loadingTitle">Processing...</div>
        <div class="progress-bar"><div id="progressFill" class="progress-fill" style="width: 0%"></div></div>
        <div id="loadingStatus">Please wait...</div>
        <div style="font-size: 12px; color: #aaa; max-width: 400px; text-align: center; margin-top: 10px;">
            Large files with 900K+ rows may take 5-15 seconds to load
        </div>
    </div>
    
    <div id="map"></div>
    <canvas id="canvas"></canvas>
    
    <!-- Info Popup for clicked items -->
    <div id="infoPopup" class="info-popup">
        <span class="close" onclick="closeInfoPopup()">&times;</span>
        <h3 id="popupTitle">Details</h3>
        <div id="popupContent"></div>
    </div>
    
    <div class="panel">
        <h2>Riyadh Map <span id="mapTypeLabel" style="font-size:10px;background:#4caf50;color:white;padding:2px 6px;border-radius:3px;margin-left:5px;">Loading...</span></h2>
        
        <!-- Total Stats -->
        <div class="stats-grid">
            <div class="stat-box" style="background:#9c27b0;"><div class="num" id="totalBldg">0</div><div class="lbl">Buildings</div></div>
            <div class="stat-box apt"><div class="num" id="totalApt">0</div><div class="lbl">üè¢ Apartments</div></div>
            <div class="stat-box villa"><div class="num" id="totalVilla">0</div><div class="lbl">üè† Villas</div></div>
            <div class="stat-box other"><div class="num" id="totalOther">0</div><div class="lbl">üì¶ Other</div></div>
        </div>
        <div style="text-align:center; font-size:11px; color:#666; margin-bottom:8px;">
            Total Parcels: <b id="totalParcels">0</b> | POIs: <b id="totalPoi">0</b> | Roads: <b id="totalRoads">0</b>
        </div>
        
        <!-- Selected District Stats -->
        <div class="district-stats" id="districtStats">
            <h3 id="districtStatsTitle">DISTRICT: None</h3>
            <div class="row" style="color:#9c27b0;"><span>Buildings:</span><span id="distBldg">0</span></div>
            <div class="row" style="color:#2196F3;"><span>üè¢ Apartments:</span><span id="distApt">0</span></div>
            <div class="row" style="color:#4CAF50;"><span>üè† Villas:</span><span id="distVilla">0</span></div>
            <div class="row" style="color:#FF9800;"><span>üì¶ Other:</span><span id="distOther">0</span></div>
            <div class="row total"><span>Total Parcels:</span><span id="distTotal">0</span></div>
            <div class="row"><span>POIs:</span><span id="distPoi">0</span></div>
            <div class="row total" style="color:#4CAF50;"><span>Villa %:</span><span id="distVillaPct">0%</span></div>
            <div class="row total" style="color:#2196F3;"><span>Apt %:</span><span id="distAptPct">0%</span></div>
            
            <!-- Road Stats -->
            <div style="border-top:2px solid #2196F3;margin-top:8px;padding-top:8px;">
                <div class="row" style="color:#2196F3;font-weight:bold;"><span>üõ£Ô∏è ROADS</span><span></span></div>
                <div class="row"><span>Total Roads:</span><span id="distRoads">0</span></div>
                <div class="row"><span>Total Length:</span><span id="distRoadLength">0 km</span></div>
                <div class="row"><span>Major (20m+):</span><span id="distMajorRoads">0</span></div>
                <div class="row" style="background:#ffebee;margin:0 -10px;padding:3px 10px;color:#c62828;"><span>Entry/Exit Points:</span><span id="distEntryExit" style="font-weight:bold;">0</span></div>
                <div class="row"><span style="padding-left:10px;">Major (30m+):</span><span id="distMajorCrossings">0</span></div>
                <div class="row"><span style="padding-left:10px;">Secondary (15-30m):</span><span id="distSecCrossings">0</span></div>
                <div class="row"><span style="padding-left:10px;">Local (<15m):</span><span id="distLocalCrossings">0</span></div>
            </div>
            
            <!-- Road Width Breakdown -->
            <div id="distRoadWidths" style="font-size:9px;margin-top:5px;display:none;">
                <div style="font-weight:bold;margin-bottom:3px;">By Width:</div>
                <div id="distWidthBreakdown"></div>
            </div>
        </div>
        
        <!-- Dynamic Counts (In View) -->
        <div class="dynamic-stats">
            <h3>IN CURRENT VIEW</h3>
            <div class="row" style="color:#9c27b0;"><span>Buildings:</span><span id="viewBldg">0</span></div>
            <div class="row" style="color:#2196F3;"><span>üè¢ Apartments:</span><span id="viewApt">0</span></div>
            <div class="row" style="color:#4CAF50;"><span>üè† Villas:</span><span id="viewVilla">0</span></div>
            <div class="row" style="color:#FF9800;"><span>üì¶ Other:</span><span id="viewOther">0</span></div>
            <div class="row total"><span>Total Parcels:</span><span id="viewTotal">0</span></div>
            <div class="row"><span>POIs:</span><span id="viewPoi">0</span></div>
            <div class="row total" style="color:#4CAF50;"><span>Villa %:</span><span id="viewVillaPct">0%</span></div>
        </div>
        
        <!-- Layer Controls -->
        <div class="section">
            <div class="section-header" onclick="toggleSection(this)">
                üé® LAYERS <span>‚ñº</span>
            </div>
            <div class="section-content open">
                <div class="layer-control">
                    <div class="header">
                        <input type="checkbox" id="showBldg" checked onchange="render()">
                        <div class="dot" style="background:#9c27b0;"></div>
                        <span class="name">MS Buildings</span>
                    </div>
                    <div style="font-size:10px;">
                        Size: <span id="bldgSizeVal">2</span> <input type="range" id="bldgSize" min="0.5" max="8" value="2" step="0.5" oninput="updateSlider('bldg')">
                        Opacity: <span id="bldgOpacityVal">40</span>% <input type="range" id="bldgOpacity" min="10" max="100" value="40" step="5" oninput="updateSlider('bldg')">
                    </div>
                </div>
                <div class="layer-control">
                    <div class="header">
                        <input type="checkbox" id="showApt" checked onchange="render()">
                        <div class="dot" style="background:#2196F3;"></div>
                        <span class="name">Apartments</span>
                    </div>
                    <div style="font-size:10px;">
                        Size: <span id="aptSizeVal">3</span> <input type="range" id="aptSize" min="1" max="8" value="3" step="0.5" oninput="updateSlider('apt')">
                    </div>
                </div>
                <div class="layer-control">
                    <div class="header">
                        <input type="checkbox" id="showVilla" checked onchange="render()">
                        <div class="dot" style="background:#4CAF50;"></div>
                        <span class="name">Villas</span>
                    </div>
                    <div style="font-size:10px;">
                        Size: <span id="villaSizeVal">3</span> <input type="range" id="villaSize" min="1" max="8" value="3" step="0.5" oninput="updateSlider('villa')">
                    </div>
                </div>
                <div class="layer-control">
                    <div class="header">
                        <input type="checkbox" id="showOther" checked onchange="render()">
                        <div class="dot" style="background:#FF9800;"></div>
                        <span class="name">Other Parcels</span>
                    </div>
                    <div style="font-size:10px;">
                        Size: <span id="otherSizeVal">2</span> <input type="range" id="otherSize" min="1" max="8" value="2" step="0.5" oninput="updateSlider('other')">
                    </div>
                </div>
                <div class="layer-control" style="background:#f3e5f5;">
                    <div class="header">
                        <input type="checkbox" id="showPoi" checked onchange="render()">
                        <div class="dot" style="background:#9C27B0;"></div>
                        <span class="name">POIs</span>
                        <span class="count" id="poiCount">0</span>
                    </div>
                    <div style="font-size:10px;">
                        Size: <span id="poiSizeVal">4</span> <input type="range" id="poiSize" min="2" max="10" value="4" step="0.5" oninput="updateSlider('poi')">
                    </div>
                </div>
                <div class="layer-control">
                    <div class="header">
                        <input type="checkbox" id="showDistricts" checked onchange="render()">
                        <div class="dot" style="background:#607D8B;"></div>
                        <span class="name">Districts</span>
                    </div>
                </div>
                <div class="layer-control" style="background:#e3f2fd;">
                    <div class="header">
                        <input type="checkbox" id="showRoads" checked onchange="render()">
                        <div class="dot" style="background:#4caf50;"></div>
                        <span class="name">All Roads</span>
                        <span class="count" id="roadCount">0</span>
                    </div>
                    <div style="font-size:10px;">
                        Width Scale: <span id="roadWidthVal">1</span>x <input type="range" id="roadWidth" min="0.5" max="3" value="1" step="0.25" oninput="updateSlider('road')">
                        <label style="margin-top:5px;display:flex;align-items:center;gap:5px;">
                            <input type="checkbox" id="showRoadLabels" checked onchange="render()"> Show Labels
                        </label>
                    </div>
                </div>
                <div class="layer-control" style="background:#ffebee;border:2px solid #d32f2f;">
                    <div class="header">
                        <input type="checkbox" id="showMajorRoads" checked onchange="render()">
                        <div class="dot" style="background:#d32f2f;"></div>
                        <span class="name" style="color:#d32f2f;font-weight:bold;">MAJOR ROADS (30m+)</span>
                        <span class="count" id="majorRoadCount" style="background:#d32f2f;">0</span>
                    </div>
                    <div style="font-size:10px;">
                        Extra Thickness: <span id="majorRoadThickVal">3</span>x <input type="range" id="majorRoadThick" min="1" max="8" value="3" step="0.5" oninput="document.getElementById('majorRoadThickVal').textContent=this.value;render()">
                        <label style="margin-top:5px;display:flex;align-items:center;gap:5px;">
                            <input type="checkbox" id="onlyMajorRoads" onchange="render()"> Show ONLY Major Roads
                        </label>
                    </div>
                </div>
                <div class="layer-control" style="background:#fce4ec;">
                    <div class="header">
                        <input type="checkbox" id="showEntryExit" checked onchange="render()">
                        <div class="dot" style="background:#e91e63;"></div>
                        <span class="name">Entry/Exit Points</span>
                        <span class="count" id="entryExitCount">0</span>
                    </div>
                    <div style="font-size:10px;">
                        Size: <span id="entryExitSizeVal">12</span> <input type="range" id="entryExitSize" min="6" max="24" value="12" step="1" oninput="document.getElementById('entryExitSizeVal').textContent=this.value;render()">
                    </div>
                    <div style="font-size:9px;color:#c2185b;margin-top:3px;">
                        <button id="addEntryExitBtn" onclick="toggleAddEntryExitMode()" style="padding:4px 8px;font-size:9px;background:#e94560;color:white;border:none;border-radius:3px;cursor:pointer;margin-right:4px;">Add Point</button>
                        <button onclick="exportEntryExitPoints()" style="padding:4px 8px;font-size:9px;background:#2196F3;color:white;border:none;border-radius:3px;cursor:pointer;">Export</button>
                    </div>
                    
                    <!-- Residential Zones Section -->
                    <div class="layer-toggle" style="background:#f3e5f5;margin-top:8px;padding:8px;border-radius:6px;">
                        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">
                            <span class="name" style="color:#7b1fa2;font-weight:bold;">Residential Zones</span>
                            <span class="count" id="polygonCount" style="background:#9c27b0;">0</span>
                        </div>
                        
                        <!-- Load Zones Files (multiple) -->
                        <div style="margin-bottom:8px;padding:6px;background:#e1bee7;border-radius:4px;">
                            <label style="font-size:9px;font-weight:bold;">Load Zone Files:</label>
                            <input type="file" id="zonesFile" accept=".json,.geojson,.JSON,.GEOJSON" multiple="multiple" style="font-size:9px;width:100%;margin-top:4px;">
                            <div id="zonesFileStatus" style="font-size:8px;color:#666;margin-top:2px;">Ctrl+click to select multiple files</div>
                            <button onclick="document.getElementById('zonesFile').click()" style="width:100%;margin-top:4px;padding:6px;font-size:10px;background:#7b1fa2;color:white;border:none;border-radius:3px;cursor:pointer;font-weight:bold;">Select Zone Files</button>
                        </div>
                        
                        <!-- Zone Creation Controls -->
                        <div style="margin-bottom:8px;padding:6px;background:#ede7f6;border-radius:4px;">
                            <label style="font-size:9px;">Or create manually - Min Road Width: <span id="zoneWidthVal">30</span>m</label>
                            <input type="range" id="zoneRoadWidth" min="20" max="50" value="30" step="5" style="width:100%;" oninput="document.getElementById('zoneWidthVal').textContent=this.value">
                            <button id="createZoneBtn" onclick="toggleCreateZoneMode()" style="padding:5px 8px;font-size:9px;background:#9c27b0;color:white;border:none;border-radius:3px;cursor:pointer;width:100%;margin-top:4px;">Create Zone</button>
                        </div>
                        
                        <!-- Zones List -->
                        <div id="zonesList" style="max-height:200px;overflow-y:auto;margin-bottom:8px;">
                            <div style="font-size:9px;color:#666;padding:8px;text-align:center;">No zones created yet</div>
                        </div>
                        
                        <!-- Selected Zone Info & Stats -->
                        <div id="selectedZoneInfo" style="display:none;background:#e1bee7;padding:10px;border-radius:6px;margin-bottom:8px;border:2px solid #9c27b0;">
                            <div style="font-weight:bold;color:#7b1fa2;font-size:12px;margin-bottom:8px;border-bottom:1px solid #ce93d8;padding-bottom:6px;">
                                <span id="selectedZoneName">Zone 1</span>
                            </div>
                            
                            <!-- Dynamic Stats -->
                            <div id="zoneStats" style="background:#f3e5f5;padding:8px;border-radius:4px;margin-bottom:8px;">
                                <div style="display:grid;grid-template-columns:1fr 1fr;gap:6px;font-size:10px;">
                                    <div style="background:white;padding:6px;border-radius:4px;text-align:center;">
                                        <div style="font-size:16px;font-weight:bold;color:#e91e63;" id="statTotalEntries">0</div>
                                        <div style="color:#666;">Total Exits</div>
                                    </div>
                                    <div style="background:white;padding:6px;border-radius:4px;text-align:center;">
                                        <div style="font-size:16px;font-weight:bold;color:#d32f2f;" id="statMajorRoads">0</div>
                                        <div style="color:#666;">Major (30m+)</div>
                                    </div>
                                    <div style="background:white;padding:6px;border-radius:4px;text-align:center;">
                                        <div style="font-size:16px;font-weight:bold;color:#ff9800;" id="statSecondaryRoads">0</div>
                                        <div style="color:#666;">Secondary</div>
                                    </div>
                                    <div style="background:white;padding:6px;border-radius:4px;text-align:center;">
                                        <div style="font-size:16px;font-weight:bold;color:#2196f3;" id="statAvgWidth">0</div>
                                        <div style="color:#666;">Avg Width (m)</div>
                                    </div>
                                </div>
                                
                                <!-- Road List -->
                                <div style="margin-top:8px;max-height:100px;overflow-y:auto;background:white;border-radius:4px;padding:6px;">
                                    <div style="font-size:9px;font-weight:bold;color:#7b1fa2;margin-bottom:4px;">Entry/Exit Roads:</div>
                                    <div id="zoneRoadList" style="font-size:9px;color:#333;"></div>
                                </div>
                            </div>
                            
                            <!-- Actions -->
                            <div style="display:flex;gap:4px;flex-wrap:wrap;">
                                <button onclick="calculateZoneEntryExits()" style="padding:4px 8px;font-size:9px;background:#4caf50;color:white;border:none;border-radius:3px;cursor:pointer;">Calculate</button>
                                <button id="addZoneEntryBtn" onclick="toggleAddZoneEntryMode()" style="padding:4px 8px;font-size:9px;background:#e94560;color:white;border:none;border-radius:3px;cursor:pointer;">Add Point</button>
                                <button onclick="exportZoneEntryExits()" style="padding:4px 8px;font-size:9px;background:#2196F3;color:white;border:none;border-radius:3px;cursor:pointer;">Export</button>
                                <button onclick="clearZoneEntryExits()" style="padding:4px 8px;font-size:9px;background:#757575;color:white;border:none;border-radius:3px;cursor:pointer;">Clear</button>
                            </div>
                        </div>
                        
                        <!-- Zone Actions -->
                        <div style="display:flex;gap:4px;flex-wrap:wrap;">
                            <button onclick="mergeAllZones()" style="padding:4px 6px;font-size:8px;background:#ff9800;color:white;border:none;border-radius:3px;cursor:pointer;">Merge</button>
                            <button onclick="exportPolygons()" style="padding:4px 6px;font-size:8px;background:#2196F3;color:white;border:none;border-radius:3px;cursor:pointer;">Export All</button>
                            <button onclick="exportAllZonesWithEntries()" style="padding:4px 6px;font-size:8px;background:#673ab7;color:white;border:none;border-radius:3px;cursor:pointer;">Export + Entries</button>
                            <button onclick="clearAllPolygons()" style="padding:4px 6px;font-size:8px;background:#757575;color:white;border:none;border-radius:3px;cursor:pointer;">Clear</button>
                        </div>
                    </div>
                </div>
                <div class="click-toggle">
                    <label><input type="checkbox" id="enableClick" checked> Enable click to view details</label>
                    <div style="font-size:9px;color:#666;margin-top:3px;margin-left:20px;">
                        Click on POI/Parcel/District to see info. Disable to freely pan/zoom.
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Data Files -->
        <div class="section">
            <div class="section-header" onclick="toggleSection(this)">
                DATA FILES <span>‚ñº</span>
            </div>
            <div class="section-content open">
                <div class="file-input">
                    <label>MS Buildings JSON:</label>
                    <input type="file" id="buildingsFile" accept=".json">
                    <div id="buildingsStatus" class="file-status">Upload buildings JSON</div>
                </div>
                <div class="file-input">
                    <label>Parcels CSV:</label>
                    <input type="file" id="parcelsFile" accept=".csv">
                    <div id="parcelsStatus" class="file-status">Use <b>riyadh_parcels_classified.csv</b> for best results</div>
                </div>
                <div class="file-input">
                    <label>POI CSV (riyadh_pois.csv):</label>
                    <input type="file" id="poiFile" accept=".csv">
                    <div id="poiStatus" class="file-status">Upload POI CSV</div>
                </div>
                <div class="file-input">
                    <label>Districts GeoJSON:</label>
                    <input type="file" id="distFile" accept=".json,.geojson">
                    <div id="distStatus" class="file-status">Upload districts JSON</div>
                </div>
                <div class="file-input" style="background:#e3f2fd;padding:8px;border-radius:6px;margin-top:8px;">
                    <label>Roads GeoJSON:</label>
                    <input type="file" id="roadsFile" accept=".json,.geojson">
                    <div id="roadsStatus" class="file-status">Upload roads GeoJSON for visualization</div>
                </div>
                <div class="file-input" style="background:#ffe0e0;padding:8px;border-radius:6px;margin-top:8px;">
                    <label>Entry/Exit Points GeoJSON:</label>
                    <input type="file" id="entryExitFile" accept=".json,.geojson">
                    <div id="entryExitStatus" class="file-status">Upload entry_exit_points.geojson</div>
                </div>
            </div>
        </div>
        
        <!-- POI Categories -->
        <div class="section">
            <div class="section-header" onclick="toggleSection(this)">
                POI CATEGORIES (<span id="poiCatCount">0</span>) <span>‚ñº</span>
            </div>
            <div class="section-content">
                <div style="margin-bottom:5px;">
                    <button onclick="selectAllPoi()" style="font-size:9px;padding:2px 5px;">All</button>
                    <button onclick="clearAllPoi()" style="font-size:9px;padding:2px 5px;">None</button>
                </div>
                <div id="poiCategories" class="poi-cats"></div>
            </div>
        </div>
        
        <!-- Districts -->
        <div class="section">
            <div class="section-header" onclick="toggleSection(this)">
                üèòÔ∏è DISTRICTS (<span id="districtCount">0</span>) <span>‚ñº</span>
            </div>
            <div class="section-content">
                <input type="text" class="search-box" id="districtSearch" placeholder="Search districts..." oninput="filterDistricts()">
                <button onclick="clearDistrictSelection()" style="font-size:9px;padding:2px 5px;margin-bottom:5px;">Clear Selection</button>
                <div id="districtList" class="district-list"></div>
            </div>
        </div>
        
        <!-- Export -->
        <div class="section">
            <div class="section-header" onclick="toggleSection(this)">
                üì§ EXPORT <span>‚ñº</span>
            </div>
            <div class="section-content">
                <button class="btn btn-success" onclick="exportVisibleParcels()">Export Visible Parcels</button>
                <button class="btn btn-primary" onclick="exportDistrictParcels()">Export District Parcels</button>
            </div>
        </div>
        
        <div style="margin-top:8px;font-size:9px;color:#888;text-align:center;">
            Zoom: <span id="zoomLevel">11</span> | <a href="#" onclick="resetView();return false;">Reset View</a>
        </div>
        
        <!-- Road Legend (shown when roads loaded) -->
        <div id="roadLegend" style="display:none;margin-top:10px;padding:8px;background:#e3f2fd;border-radius:6px;">
            <div style="font-weight:600;font-size:11px;margin-bottom:5px;">üõ£Ô∏è Road Width Legend</div>
            <div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;font-size:9px;">
                <div><span style="display:inline-block;width:20px;height:4px;background:#d32f2f;border-radius:2px;"></span> 36m+</div>
                <div><span style="display:inline-block;width:20px;height:4px;background:#ff5722;border-radius:2px;"></span> 30m</div>
                <div><span style="display:inline-block;width:20px;height:4px;background:#ff9800;border-radius:2px;"></span> 25m</div>
                <div><span style="display:inline-block;width:20px;height:4px;background:#ffc107;border-radius:2px;"></span> 20m</div>
                <div><span style="display:inline-block;width:20px;height:4px;background:#8bc34a;border-radius:2px;"></span> 15m</div>
                <div><span style="display:inline-block;width:20px;height:4px;background:#4caf50;border-radius:2px;"></span> 12m</div>
                <div><span style="display:inline-block;width:20px;height:4px;background:#009688;border-radius:2px;"></span> 10m</div>
                <div><span style="display:inline-block;width:20px;height:4px;background:#607d8b;border-radius:2px;"></span> 8m</div>
            </div>
            <div style="margin-top:8px;border-top:1px solid #90caf9;padding-top:8px;">
                <div style="font-size:10px;"><span style="display:inline-block;width:12px;height:12px;background:#d32f2f;border-radius:50%;border:2px solid white;box-shadow:0 1px 3px rgba(0,0,0,0.3);vertical-align:middle;"></span> Road Entry/Exit Point</div>
            </div>
        </div>
    </div>

    <script>
        let buildings = [];    // GeoJSON features with polygon coordinates
        let parcels = [];      // {lat, lng, type: 'apt'|'villa'|'other', ...}
        let poiData = [];      // {lat, lng, layer, name_ar, name_en}
        let districts = [];    // GeoJSON features
        let roads = [];        // GeoJSON features for roads
        let entryExitPoints = []; // Entry/Exit boundary crossing points
        let selectedDistrict = null;
        let activePoiCategories = new Set();
        let infoPopup = null;
        let buildingsFileName = '';
        let mapsLoadAttempts = 0;
        const MAX_LOAD_ATTEMPTS = 300; // 30 seconds
        
        // Road colors by width
        function getRoadColor(width) {
            if (width >= 36) return '#d32f2f';  // Major arterial - red
            if (width >= 30) return '#ff5722';  // Arterial - deep orange
            if (width >= 25) return '#ff9800';  // Collector - orange
            if (width >= 20) return '#ffc107';  // Main road - amber
            if (width >= 15) return '#8bc34a';  // Secondary - light green
            if (width >= 12) return '#4caf50';  // Local - green
            if (width >= 10) return '#009688';  // Minor - teal
            return '#607d8b';                   // Alley - blue grey
        }
        
        function getRoadLineWidth(width, zoom) {
            const baseWidth = Math.max(1, (zoom - 10) * 0.8);
            if (width >= 30) return baseWidth * 4;
            if (width >= 20) return baseWidth * 3;
            if (width >= 15) return baseWidth * 2.5;
            if (width >= 10) return baseWidth * 2;
            return baseWidth * 1.5;
        }
        
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Map variable
        let googleMap = null;
        let leafletMap = null;
        
        // Initialize map immediately with Leaflet/OpenStreetMap
        function initMapNow() {
            leafletMap = L.map('map').setView([24.7136, 46.6753], 11);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 19
            }).addTo(leafletMap);
            
            googleMap = leafletMap; // Use same variable for compatibility
            document.getElementById('mapTypeLabel').textContent = 'OpenStreetMap';
            
            // Initialize layers
            zonePolygonsLayer = L.layerGroup().addTo(leafletMap);
            zoneEntryExitMarkers = L.layerGroup().addTo(leafletMap);
            
            // Add listeners
            leafletMap.on('moveend', render);
            leafletMap.on('click', function(e) {
                handleMapClick({
                    latLng: { lat: () => e.latlng.lat, lng: () => e.latlng.lng },
                    pixel: { x: e.containerPoint.x, y: e.containerPoint.y }
                });
            });
            
            window.addEventListener('resize', render);
            document.getElementById('loadingOverlay').classList.add('hidden');
            console.log('Map ready!');
        }
        
        // Start immediately
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initMapNow);
        } else {
            initMapNow();
        }
        
        // POI Colors by layer
        const poiColors = {
            'Religious': '#8B4513',
            'EatAndDrink': '#E91E63',
            'Educational': '#3F51B5',
            'HealthCare': '#F44336',
            'Commercial': '#9C27B0',
            'Financial': '#00BCD4',
            'Industry': '#795548',
            'Sports': '#4CAF50',
            'Government': '#607D8B',
            'ParksAndSquares': '#8BC34A',
            'GasStationsAndAutoServices': '#FF5722',
            'HotelsAndHospitalityServices': '#FFC107',
            'Transportation': '#2196F3',
            'Entertainment': '#E040FB',
            'Cultural': '#FF9800',
            'BusinessFirms': '#00ACC1',
            'TravelAndTourism': '#AB47BC',
            'default': '#9C27B0'
        };
        
        function toggleSection(header) {
            const content = header.nextElementSibling;
            content.classList.toggle('open');
            header.querySelector('span:last-child').textContent = content.classList.contains('open') ? '‚ñº' : '‚ñ∂';
        }
        
        function showLoading(title) {
            document.getElementById('loadingTitle').textContent = title;
            document.getElementById('loadingOverlay').classList.remove('hidden');
        }
        
        function setLoadingStatus(msg, pct) {
            document.getElementById('loadingStatus').textContent = msg;
            document.getElementById('progressFill').style.width = pct + '%';
        }
        
        function hideLoading() {
            document.getElementById('loadingOverlay').classList.add('hidden');
        }
        
        function updateSlider(layer) {
            if (layer === 'road') {
                document.getElementById('roadWidthVal').textContent = document.getElementById('roadWidth').value;
            } else {
                document.getElementById(layer + 'SizeVal').textContent = document.getElementById(layer + 'Size').value;
                const opacityEl = document.getElementById(layer + 'Opacity');
                const opacityVal = document.getElementById(layer + 'OpacityVal');
                if (opacityEl && opacityVal) opacityVal.textContent = opacityEl.value;
            }
            render();
        }
        
        function resetView() {
            setMapCenter(24.7136, 46.6753, 11);
        }
        
        // FAST CSV Parser - simple split for speed
        function parseCSVLine(line) {
            // Fast path: no quotes
            if (line.indexOf('"') === -1) {
                return line.split(',');
            }
            // Slow path: handle quotes
            const result = []; let current = ''; let inQuotes = false;
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') inQuotes = !inQuotes;
                else if (char === ',' && !inQuotes) { result.push(current); current = ''; }
                else current += char;
            }
            result.push(current);
            return result;
        }
        
        // Point in polygon
        function pointInPolygon(lat, lon, polygon) {
            if (!polygon || polygon.length < 3) return false;
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const [xi, yi] = polygon[i];
                const [xj, yj] = polygon[j];
                if (((yi > lat) !== (yj > lat)) && (lon < (xj - xi) * (lat - yi) / (yj - yi) + xi)) {
                    inside = !inside;
                }
            }
            return inside;
        }
        
        // Line intersection for entry/exit detection
        function lineIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
            const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
            if (Math.abs(denom) < 1e-10) return null;
            const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
            const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
            if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
                return { x: x1 + ua * (x2 - x1), y: y1 + ua * (y2 - y1) };
            }
            return null;
        }
        
        // Entry/exit points management
        let addEntryExitMode = false;
        
        // Auto-generated zone polygons
        let drawnPolygons = [];
        
        let zonePolygonsLayer = null;
        let createZoneMode = false;
        
        // Zone-specific entry/exit management
        let selectedZoneIndex = -1;
        let addZoneEntryMode = false;
        let zoneEntryExitMarkers = null; // Leaflet layer for zone entry/exit markers
        
        // Update zones list in panel
        function updateZonesList() {
            const container = document.getElementById('zonesList');
            if (!container) return;
            
            if (drawnPolygons.length === 0) {
                container.innerHTML = '<div style="font-size:9px;color:#666;padding:8px;text-align:center;">No zones created yet</div>';
                document.getElementById('selectedZoneInfo').style.display = 'none';
                selectedZoneIndex = -1;
                return;
            }
            
            let html = '';
            drawnPolygons.forEach((zone, idx) => {
                const entryCount = zone.entryExitPoints ? zone.entryExitPoints.length : 0;
                const isSelected = idx === selectedZoneIndex;
                html += `
                    <div onclick="selectZone(${idx})" style="
                        padding:6px 8px;
                        margin-bottom:4px;
                        background:${isSelected ? '#ce93d8' : '#ede7f6'};
                        border-radius:4px;
                        cursor:pointer;
                        display:flex;
                        justify-content:space-between;
                        align-items:center;
                        border-left:4px solid ${zone.color || '#9c27b0'};
                        ${isSelected ? 'box-shadow:0 2px 4px rgba(0,0,0,0.2);' : ''}
                    ">
                        <span style="font-size:10px;font-weight:${isSelected ? 'bold' : 'normal'};">${zone.name}</span>
                        <div style="display:flex;align-items:center;gap:4px;">
                            <span style="background:#e91e63;color:white;padding:2px 5px;border-radius:8px;font-size:8px;">${entryCount}</span>
                            <button onclick="event.stopPropagation();deleteZone(${idx})" style="background:#d32f2f;color:white;border:none;padding:2px 5px;border-radius:3px;font-size:8px;cursor:pointer;">X</button>
                        </div>
                    </div>
                `;
            });
            container.innerHTML = html;
            document.getElementById('polygonCount').textContent = drawnPolygons.length;
        }
        
        // Select a zone
        function selectZone(idx) {
            selectedZoneIndex = idx;
            const zone = drawnPolygons[idx];
            
            if (!zone) {
                document.getElementById('selectedZoneInfo').style.display = 'none';
                return;
            }
            
            // Show selected zone info panel
            document.getElementById('selectedZoneInfo').style.display = 'block';
            document.getElementById('selectedZoneName').textContent = zone.name;
            
            // Calculate stats
            const entries = zone.entryExitPoints || [];
            const totalEntries = entries.length;
            const majorRoads = entries.filter(e => e.width >= 30).length;
            const secondaryRoads = totalEntries - majorRoads;
            const avgWidth = totalEntries > 0 ? Math.round(entries.reduce((sum, e) => sum + (e.width || 0), 0) / totalEntries) : 0;
            
            // Update stats display
            document.getElementById('statTotalEntries').textContent = totalEntries;
            document.getElementById('statMajorRoads').textContent = majorRoads;
            document.getElementById('statSecondaryRoads').textContent = secondaryRoads;
            document.getElementById('statAvgWidth').textContent = avgWidth;
            
            // Build road list
            const roadListEl = document.getElementById('zoneRoadList');
            if (totalEntries === 0) {
                roadListEl.innerHTML = '<div style="color:#999;">No entry/exit points</div>';
            } else {
                // Group by road name and show widths
                const roadGroups = {};
                entries.forEach(e => {
                    const name = e.roadName || 'Unknown';
                    if (!roadGroups[name]) {
                        roadGroups[name] = { count: 0, widths: [] };
                    }
                    roadGroups[name].count++;
                    roadGroups[name].widths.push(e.width || 0);
                });
                
                let roadHtml = '';
                Object.entries(roadGroups)
                    .sort((a, b) => Math.max(...b[1].widths) - Math.max(...a[1].widths))
                    .forEach(([name, data]) => {
                        const maxWidth = Math.max(...data.widths);
                        const isMajor = maxWidth >= 30;
                        const color = isMajor ? '#d32f2f' : '#666';
                        const badge = isMajor ? '<span style="background:#d32f2f;color:white;padding:1px 4px;border-radius:3px;font-size:8px;margin-left:4px;">MAJOR</span>' : '';
                        roadHtml += `<div style="padding:2px 0;border-bottom:1px solid #eee;color:${color};">
                            ${name} - ${maxWidth}m ${data.count > 1 ? '(x' + data.count + ')' : ''} ${badge}
                        </div>`;
                    });
                roadListEl.innerHTML = roadHtml;
            }
            
            // Zoom to zone
            if (zone.coordinates && zone.coordinates.length > 0) {
                let minLat = Infinity, maxLat = -Infinity, minLng = Infinity, maxLng = -Infinity;
                zone.coordinates.forEach(c => {
                    minLng = Math.min(minLng, c[0]);
                    maxLng = Math.max(maxLng, c[0]);
                    minLat = Math.min(minLat, c[1]);
                    maxLat = Math.max(maxLat, c[1]);
                });
                fitMapBounds(maxLat, minLat, maxLng, minLng, 50);
            }
            
            // Update zones list to show selection
            updateZonesList();
            
            // Render zone entry/exit points on map
            renderZoneEntryExits();
            
            showToast(zone.name + ': ' + totalEntries + ' exits (' + majorRoads + ' major)', '#9c27b0');
        }
        
        // Calculate entry/exit points for selected zone
        function calculateZoneEntryExits() {
            if (selectedZoneIndex < 0 || !drawnPolygons[selectedZoneIndex]) {
                showToast('Select a zone first', '#ff9800');
                return;
            }
            
            const zone = drawnPolygons[selectedZoneIndex];
            if (!zone.coordinates || zone.coordinates.length < 3) {
                showToast('Invalid zone boundary', '#d32f2f');
                return;
            }
            
            if (!roads || roads.length === 0) {
                showToast('Load roads data first', '#ff9800');
                return;
            }
            
            const entries = [];
            const boundary = zone.coordinates;
            
            // For each road, check intersections with zone boundary
            roads.forEach(road => {
                if (!road.geometry || !road.geometry.coordinates) return;
                
                const coords = road.geometry.type === 'MultiLineString' 
                    ? road.geometry.coordinates.flat() 
                    : road.geometry.coordinates;
                
                for (let i = 0; i < coords.length - 1; i++) {
                    const [x1, y1] = coords[i];
                    const [x2, y2] = coords[i + 1];
                    
                    // Check against each boundary segment
                    for (let j = 0; j < boundary.length; j++) {
                        const [bx1, by1] = boundary[j];
                        const [bx2, by2] = boundary[(j + 1) % boundary.length];
                        
                        const intersection = lineIntersect(x1, y1, x2, y2, bx1, by1, bx2, by2);
                        if (intersection) {
                            // Check if this point is not too close to existing entries
                            const isDuplicate = entries.some(e => {
                                const dist = Math.sqrt(Math.pow(e.lng - intersection.x, 2) + Math.pow(e.lat - intersection.y, 2));
                                return dist < 0.0002; // ~20m
                            });
                            
                            if (!isDuplicate) {
                                entries.push({
                                    lat: intersection.y,
                                    lng: intersection.x,
                                    roadName: road.properties?.name || road.properties?.NAME || 'Unknown Road',
                                    width: parseFloat(road.properties?.width || road.properties?.WIDTH) || 10,
                                    zoneIndex: selectedZoneIndex
                                });
                            }
                        }
                    }
                }
            });
            
            zone.entryExitPoints = entries;
            showToast('Found ' + entries.length + ' entry/exit points for ' + zone.name, '#4caf50');
            
            updateZonesList();
            renderZoneEntryExits();
        }
        
        // Render zone entry/exit points on map
        function renderZoneEntryExits() {
            if (!leafletMap) return;
            
            // Clear existing markers
            if (zoneEntryExitMarkers && zoneEntryExitMarkers.clearLayers) {
                zoneEntryExitMarkers.clearLayers();
            }
            
            if (selectedZoneIndex < 0 || !drawnPolygons[selectedZoneIndex]) return;
            
            const zone = drawnPolygons[selectedZoneIndex];
            if (!zone.entryExitPoints || zone.entryExitPoints.length === 0) return;
            
            zone.entryExitPoints.forEach((point, idx) => {
                const isMajor = point.width >= 30;
                const color = isMajor ? '#d32f2f' : '#e91e63';
                const radius = isMajor ? 12 : 8;
                
                const marker = L.circleMarker([point.lat, point.lng], {
                    radius: radius,
                    fillColor: color,
                    color: '#fff',
                    weight: 3,
                    fillOpacity: 0.9
                }).addTo(zoneEntryExitMarkers);
                
                marker.bindPopup(`
                    <div style="min-width:150px;">
                        <b style="color:${color};">${point.roadName || 'Entry/Exit'}</b><br>
                        Width: ${point.width || 'N/A'}m<br>
                        Zone: ${zone.name}<br>
                        <button onclick="deleteZoneEntryPoint(${idx})" style="margin-top:8px;padding:6px 12px;background:#d32f2f;color:white;border:none;border-radius:4px;cursor:pointer;">Delete</button>
                    </div>
                `);
            });
        }
        
        // Toggle add zone entry mode
        function toggleAddZoneEntryMode() {
            if (selectedZoneIndex < 0) {
                showToast('Select a zone first', '#ff9800');
                return;
            }
            
            addZoneEntryMode = !addZoneEntryMode;
            const btn = document.getElementById('addZoneEntryBtn');
            if (addZoneEntryMode) {
                btn.style.background = '#4caf50';
                btn.textContent = 'Click on map...';
                showToast('Click on map to add entry/exit point', '#4caf50');
            } else {
                btn.style.background = '#e94560';
                btn.textContent = 'Add Point';
            }
        }
        
        // Add entry point to zone
        function addZoneEntryPoint(lat, lng) {
            if (selectedZoneIndex < 0 || !drawnPolygons[selectedZoneIndex]) return;
            
            const zone = drawnPolygons[selectedZoneIndex];
            if (!zone.entryExitPoints) zone.entryExitPoints = [];
            
            // Prompt for road name and width
            const roadName = prompt('Road name:', 'Entry/Exit') || 'Entry/Exit';
            const widthStr = prompt('Road width (m):', '15');
            const width = parseFloat(widthStr) || 15;
            
            zone.entryExitPoints.push({
                lat: lat,
                lng: lng,
                roadName: roadName,
                width: width,
                zoneIndex: selectedZoneIndex
            });
            
            addZoneEntryMode = false;
            const btn = document.getElementById('addZoneEntryBtn');
            btn.style.background = '#e94560';
            btn.textContent = 'Add Point';
            
            updateZonesList();
            renderZoneEntryExits();
            
            // Update stats display
            selectZone(selectedZoneIndex);
            
            showToast('Entry point added: ' + roadName, '#4caf50');
        }
        
        // Delete zone entry point
        function deleteZoneEntryPoint(idx) {
            if (selectedZoneIndex < 0 || !drawnPolygons[selectedZoneIndex]) return;
            
            const zone = drawnPolygons[selectedZoneIndex];
            if (zone.entryExitPoints && zone.entryExitPoints[idx]) {
                // Close info window
                if (currentInfoWindow) currentInfoWindow.close();
                
                zone.entryExitPoints.splice(idx, 1);
                updateZonesList();
                renderZoneEntryExits();
                
                // Update stats display
                selectZone(selectedZoneIndex);
                
                showToast('Entry point deleted', '#757575');
            }
        }
        
        // Clear zone entry/exit points
        function clearZoneEntryExits() {
            if (selectedZoneIndex < 0 || !drawnPolygons[selectedZoneIndex]) return;
            
            drawnPolygons[selectedZoneIndex].entryExitPoints = [];
            updateZonesList();
            renderZoneEntryExits();
            showToast('Zone entry points cleared', '#757575');
        }
        
        // Export zone entry/exit points
        function exportZoneEntryExits() {
            if (selectedZoneIndex < 0 || !drawnPolygons[selectedZoneIndex]) {
                showToast('Select a zone first', '#ff9800');
                return;
            }
            
            const zone = drawnPolygons[selectedZoneIndex];
            if (!zone.entryExitPoints || zone.entryExitPoints.length === 0) {
                showToast('No entry points to export', '#ff9800');
                return;
            }
            
            const geojson = {
                type: 'FeatureCollection',
                properties: { zoneName: zone.name },
                features: zone.entryExitPoints.map((p, i) => ({
                    type: 'Feature',
                    properties: {
                        id: i + 1,
                        roadName: p.roadName,
                        width: p.width,
                        zoneName: zone.name
                    },
                    geometry: {
                        type: 'Point',
                        coordinates: [p.lng, p.lat]
                    }
                }))
            };
            
            const a = document.createElement('a');
            a.href = URL.createObjectURL(new Blob([JSON.stringify(geojson, null, 2)], { type: 'application/json' }));
            a.download = zone.name.replace(/\s+/g, '_') + '_entry_exits.geojson';
            a.click();
            showToast('Exported ' + zone.entryExitPoints.length + ' points', '#4caf50');
        }
        
        // Export all zones with their entry points
        function exportAllZonesWithEntries() {
            if (drawnPolygons.length === 0) {
                showToast('No zones to export', '#ff9800');
                return;
            }
            
            const features = [];
            
            drawnPolygons.forEach((zone, zoneIdx) => {
                // Add zone polygon
                features.push({
                    type: 'Feature',
                    properties: {
                        type: 'zone',
                        name: zone.name,
                        id: zoneIdx + 1,
                        entryCount: zone.entryExitPoints ? zone.entryExitPoints.length : 0
                    },
                    geometry: {
                        type: 'Polygon',
                        coordinates: [[...zone.coordinates, zone.coordinates[0]]]
                    }
                });
                
                // Add entry/exit points
                if (zone.entryExitPoints) {
                    zone.entryExitPoints.forEach((p, i) => {
                        features.push({
                            type: 'Feature',
                            properties: {
                                type: 'entry_exit',
                                zoneName: zone.name,
                                zoneId: zoneIdx + 1,
                                pointId: i + 1,
                                roadName: p.roadName,
                                width: p.width
                            },
                            geometry: {
                                type: 'Point',
                                coordinates: [p.lng, p.lat]
                            }
                        });
                    });
                }
            });
            
            const geojson = {
                type: 'FeatureCollection',
                features: features
            };
            
            const a = document.createElement('a');
            a.href = URL.createObjectURL(new Blob([JSON.stringify(geojson, null, 2)], { type: 'application/json' }));
            a.download = 'zones_with_entries.geojson';
            a.click();
            
            const totalEntries = drawnPolygons.reduce((sum, z) => sum + (z.entryExitPoints ? z.entryExitPoints.length : 0), 0);
            showToast('Exported ' + drawnPolygons.length + ' zones with ' + totalEntries + ' entry points', '#4caf50');
        }
        let majorRoadSegments = []; // Cached major road segments
        
        // Toggle zone creation mode
        function toggleCreateZoneMode() {
            createZoneMode = !createZoneMode;
            const btn = document.getElementById('createZoneBtn');
            if (createZoneMode) {
                btn.style.background = '#4caf50';
                btn.textContent = 'Click inside area bounded by red roads';
                cacheMajorRoads();
                showToast('Click inside an area surrounded by major (red) roads!', '#4caf50');
            } else {
                btn.style.background = '#9c27b0';
                btn.textContent = 'Create Zone (click inside)';
            }
        }
        
        // Cache major road segments for faster lookup
        function cacheMajorRoads() {
            const minWidth = parseFloat(document.getElementById('zoneRoadWidth').value) || 25;
            majorRoadSegments = [];
            
            if (roads.length === 0) {
                showToast('Load roads GeoJSON first!', '#ff9800');
                return;
            }
            
            let roadCount = 0;
            roads.forEach(road => {
                const props = road.properties || {};
                const width = parseFloat(props.width_m || props.WIDTH || props.width || 0);
                if (width >= minWidth) {
                    roadCount++;
                    const geom = road.geometry;
                    if (!geom) return;
                    const lines = geom.type === 'LineString' ? [geom.coordinates] : geom.coordinates;
                    lines.forEach(coords => {
                        if (coords && coords.length >= 2) {
                            for (let i = 0; i < coords.length - 1; i++) {
                                majorRoadSegments.push({
                                    x1: coords[i][0], y1: coords[i][1],
                                    x2: coords[i+1][0], y2: coords[i+1][1],
                                    name: props.name_ar || props.name_en || 'Road'
                                });
                            }
                        }
                    });
                }
            });
            
            console.log('Found', roadCount, 'roads >=', minWidth, 'm with', majorRoadSegments.length, 'segments');
            
            if (majorRoadSegments.length === 0) {
                showToast('No roads >= ' + minWidth + 'm found. Try lower min width.', '#ff9800');
            } else {
                showToast('Found ' + roadCount + ' major roads. Click inside to create zone!', '#4caf50');
            }
        }
        
        // Create zone by clicking inside - ONLY if surrounded by red roads
        function createZoneAtPoint(lat, lng) {
            if (majorRoadSegments.length === 0) {
                cacheMajorRoads();
            }
            
            if (majorRoadSegments.length === 0) {
                showToast('No RED roads found! Load roads first.', '#ff9800');
                return;
            }
            
            // Check 8 directions for red roads
            const directions = [
                { name: 'N', dx: 0, dy: 1 },
                { name: 'NE', dx: 0.707, dy: 0.707 },
                { name: 'E', dx: 1, dy: 0 },
                { name: 'SE', dx: 0.707, dy: -0.707 },
                { name: 'S', dx: 0, dy: -1 },
                { name: 'SW', dx: -0.707, dy: -0.707 },
                { name: 'W', dx: -1, dy: 0 },
                { name: 'NW', dx: -0.707, dy: 0.707 }
            ];
            
            const maxDist = 0.008; // ~800m max search
            const foundRoads = [];
            const missingDirs = [];
            
            directions.forEach(dir => {
                let nearest = null;
                let nearestDist = maxDist;
                
                for (const seg of majorRoadSegments) {
                    const hit = rayLineIntersect(lng, lat, dir.dx, dir.dy, seg.x1, seg.y1, seg.x2, seg.y2);
                    if (hit && hit.t > 0.0001 && hit.t < nearestDist) {
                        nearestDist = hit.t;
                        nearest = { lng: hit.x, lat: hit.y, dir: dir.name };
                    }
                }
                
                if (nearest) {
                    foundRoads.push(nearest);
                } else {
                    missingDirs.push(dir.name);
                }
            });
            
            // Must have roads in at least 6 of 8 directions
            if (foundRoads.length < 6) {
                showToast('NOT surrounded by red roads! Missing: ' + missingDirs.join(', '), '#d32f2f');
                return;
            }
            
            // Now trace detailed boundary with more rays
            const numRays = 60;
            const boundaryPoints = [];
            
            for (let i = 0; i < numRays; i++) {
                const angle = (i / numRays) * 2 * Math.PI;
                const dx = Math.cos(angle);
                const dy = Math.sin(angle);
                
                let nearestDist = maxDist;
                let nearestPoint = null;
                
                for (const seg of majorRoadSegments) {
                    const hit = rayLineIntersect(lng, lat, dx, dy, seg.x1, seg.y1, seg.x2, seg.y2);
                    if (hit && hit.t > 0.0001 && hit.t < nearestDist) {
                        nearestDist = hit.t;
                        nearestPoint = { lng: hit.x, lat: hit.y };
                    }
                }
                
                if (nearestPoint) {
                    boundaryPoints.push(nearestPoint);
                }
            }
            
            if (boundaryPoints.length < 8) {
                showToast('Could not trace boundary. Click closer to center of area.', '#ff9800');
                return;
            }
            
            // Simplify
            const simplified = [boundaryPoints[0]];
            for (let i = 1; i < boundaryPoints.length; i++) {
                const last = simplified[simplified.length - 1];
                const curr = boundaryPoints[i];
                const dist = Math.sqrt(Math.pow(curr.lat - last.lat, 2) + Math.pow(curr.lng - last.lng, 2));
                if (dist > 0.00015) {
                    simplified.push(curr);
                }
            }
            
            const coords = simplified.map(p => [p.lng, p.lat]);
            const latlngs = simplified.map(p => [p.lat, p.lng]);
            
            const zoneNum = drawnPolygons.length + 1;
            const colors = ['#e91e63', '#9c27b0', '#673ab7', '#3f51b5', '#2196f3', '#00bcd4', '#009688', '#4caf50'];
            const color = colors[zoneNum % colors.length];
            
            drawnPolygons.push({
                name: 'Zone ' + zoneNum,
                coordinates: coords,
                color: color
            });
            
            // Draw polygon on map
            if (leafletMap && zonePolygonsLayer) {
                const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: 3,
                    fillColor: color,
                    fillOpacity: 0.25
                }).addTo(zonePolygonsLayer);
                
                polygon.on('click', function() {
                    selectZone(zoneNum - 1);
                });
            }
            
            document.getElementById('polygonCount').textContent = drawnPolygons.length;
            console.log('Zone created! Total zones:', drawnPolygons.length, drawnPolygons);
            updateZonesList();
            showToast('Zone ' + zoneNum + ' created!', '#4caf50');
        }
        
        // Ray-line segment intersection
        function rayLineIntersect(rx, ry, dx, dy, x1, y1, x2, y2) {
            const vx = x2 - x1;
            const vy = y2 - y1;
            
            const denom = dx * vy - dy * vx;
            if (Math.abs(denom) < 1e-12) return null; // Parallel
            
            const t = ((x1 - rx) * vy - (y1 - ry) * vx) / denom;
            const u = -((rx - x1) * dy - (ry - y1) * dx) / denom;
            
            if (t > 0 && u >= 0 && u <= 1) {
                return {
                    x: rx + t * dx,
                    y: ry + t * dy,
                    t: t
                };
            }
            return null;
        }
        
        function deleteZone(idx) {
            drawnPolygons.splice(idx, 1);
            
            // Reset selected zone if it was deleted
            if (selectedZoneIndex === idx) {
                selectedZoneIndex = -1;
                document.getElementById('selectedZoneInfo').style.display = 'none';
                if (zoneEntryExitMarkers && zoneEntryExitMarkers.clearLayers) {
                    zoneEntryExitMarkers.clearLayers();
                }
            } else if (selectedZoneIndex > idx) {
                selectedZoneIndex--;
            }
            
            // Clear and redraw all zones
            redrawAllZonePolygons();
            
            updateZonesList();
            showToast('Zone deleted', '#757575');
        }
        
        function clearAllPolygons() {
            if (drawnPolygons.length && !confirm('Delete all zones?')) return;
            
            // Clear zone polygons
            if (zonePolygonsLayer && zonePolygonsLayer.clearLayers) {
                zonePolygonsLayer.clearLayers();
            }
            
            // Clear zone entry markers
            if (zoneEntryExitMarkers && zoneEntryExitMarkers.clearLayers) {
                zoneEntryExitMarkers.clearLayers();
            }
            
            drawnPolygons = [];
            selectedZoneIndex = -1;
            document.getElementById('selectedZoneInfo').style.display = 'none';
            updateZonesList();
            showToast('All zones cleared', '#757575');
        }
        
        function mergeAllZones() {
            console.log('Merge called. drawnPolygons:', drawnPolygons.length);
            
            if (!drawnPolygons || drawnPolygons.length < 2) {
                showToast('Need at least 2 zones to merge (you have ' + (drawnPolygons ? drawnPolygons.length : 0) + ' zones)', '#ff9800');
                return;
            }
            
            try {
                // Collect all points from all polygons
                const allPoints = [];
                drawnPolygons.forEach((zone, idx) => {
                    console.log('Zone ' + idx + ' has ' + (zone.coordinates ? zone.coordinates.length : 0) + ' points');
                    if (zone.coordinates && zone.coordinates.length > 0) {
                        zone.coordinates.forEach(coord => {
                            allPoints.push({ lng: coord[0], lat: coord[1] });
                        });
                    }
                });
                
                console.log('Total points collected:', allPoints.length);
                
                if (allPoints.length < 3) {
                    showToast('Not enough points to merge (' + allPoints.length + ' found)', '#ff9800');
                    return;
                }
                
                // Calculate centroid
                let sumLat = 0, sumLng = 0;
                allPoints.forEach(p => { sumLat += p.lat; sumLng += p.lng; });
                const centerLat = sumLat / allPoints.length;
                const centerLng = sumLng / allPoints.length;
                
                // Sort by angle from centroid (creates outer boundary)
                allPoints.sort((a, b) => {
                    const angleA = Math.atan2(a.lat - centerLat, a.lng - centerLng);
                    const angleB = Math.atan2(b.lat - centerLat, b.lng - centerLng);
                    return angleA - angleB;
                });
                
                // Convex Hull algorithm (Gift wrapping)
                function cross(o, a, b) {
                    return (a.lng - o.lng) * (b.lat - o.lat) - (a.lat - o.lat) * (b.lng - o.lng);
                }
                
                // Find leftmost point
                let leftmost = allPoints[0];
                for (const p of allPoints) {
                    if (p.lng < leftmost.lng) leftmost = p;
                }
                
                const hull = [];
                let current = leftmost;
                let iterations = 0;
                const maxIter = allPoints.length * 2;
                
                do {
                    hull.push(current);
                    let next = allPoints[0];
                    
                    for (const candidate of allPoints) {
                        if (next === current || cross(current, next, candidate) < 0) {
                            next = candidate;
                        }
                    }
                    
                    current = next;
                    iterations++;
                    if (iterations > maxIter) break;
                } while (current !== leftmost && hull.length < allPoints.length);
                
                console.log('Hull points:', hull.length);
                
                if (hull.length < 3) {
                    showToast('Could not create merged polygon', '#d32f2f');
                    return;
                }
                
                // Store original count
                const originalCount = drawnPolygons.length;
                
                // Clear existing zones from map
                if (zonePolygonsLayer && zonePolygonsLayer.clearLayers) {
                    zonePolygonsLayer.clearLayers();
                }
                drawnPolygons = [];
                
                // Create merged zone
                const coords = hull.map(p => [p.lng, p.lat]);
                const latlngs = hull.map(p => [p.lat, p.lng]);
                
                drawnPolygons.push({
                    name: 'Merged Zone',
                    coordinates: coords,
                    color: '#9c27b0'
                });
                
                // Draw on map
                if (leafletMap && zonePolygonsLayer) {
                    const polygon = L.polygon(latlngs, {
                        color: '#9c27b0',
                        weight: 3,
                        fillColor: '#9c27b0',
                        fillOpacity: 0.3
                    }).addTo(zonePolygonsLayer);
                    
                    polygon.on('click', function() {
                        selectZone(0);
                    });
                    
                    // Zoom to merged zone
                    let minLat = Infinity, maxLat = -Infinity, minLng = Infinity, maxLng = -Infinity;
                    hull.forEach(p => {
                        minLat = Math.min(minLat, p.lat);
                        maxLat = Math.max(maxLat, p.lat);
                        minLng = Math.min(minLng, p.lng);
                        maxLng = Math.max(maxLng, p.lng);
                    });
                    fitMapBounds(maxLat, minLat, maxLng, minLng, 50);
                    
                    console.log('Merged polygon drawn with ' + hull.length + ' vertices');
                }
                
                document.getElementById('polygonCount').textContent = 1;
                selectedZoneIndex = -1;
                document.getElementById('selectedZoneInfo').style.display = 'none';
                if (zoneEntryExitMarkers && zoneEntryExitMarkers.clearLayers) {
                    zoneEntryExitMarkers.clearLayers();
                }
                updateZonesList();
                showToast('Merged ' + originalCount + ' zones into 1!', '#9c27b0');
            } catch (err) {
                console.error('Merge error:', err);
                showToast('Error: ' + err.message, '#d32f2f');
            }
        }
        
        function exportPolygons() {
            if (!drawnPolygons.length) {
                showToast('No zones to export', '#ff9800');
                return;
            }
            const geojson = {
                type: 'FeatureCollection',
                features: drawnPolygons.map((p, i) => ({
                    type: 'Feature',
                    properties: { name: p.name, id: i + 1 },
                    geometry: {
                        type: 'Polygon',
                        coordinates: [[...p.coordinates, p.coordinates[0]]]
                    }
                }))
            };
            const a = document.createElement('a');
            a.href = URL.createObjectURL(new Blob([JSON.stringify(geojson, null, 2)], { type: 'application/json' }));
            a.download = 'residential_zones.geojson';
            a.click();
            showToast('Exported ' + drawnPolygons.length + ' zones!', '#4caf50');
        }
        
        function getEntryExitStats() {
            const major = entryExitPoints.filter(p => p.width >= 30).length;
            const secondary = entryExitPoints.filter(p => p.width >= 15 && p.width < 30).length;
            const local = entryExitPoints.filter(p => p.width < 15).length;
            return { total: entryExitPoints.length, major, secondary, local };
        }
        
        function deleteEntryExitPoint(idx) {
            if (idx >= 0 && idx < entryExitPoints.length) {
                entryExitPoints.splice(idx, 1);
                document.getElementById('entryExitCount').textContent = entryExitPoints.length;
                closeInfoPopup();
                render();
                showToast('Entry/exit point deleted', '#d32f2f');
            }
        }
        
        function toggleAddEntryExitMode() {
            addEntryExitMode = !addEntryExitMode;
            const btn = document.getElementById('addEntryExitBtn');
            if (addEntryExitMode) {
                btn.style.background = '#4caf50';
                btn.textContent = 'Click map to add point (ESC to cancel)';
                showToast('Click on map to add entry/exit point', '#4caf50');
            } else {
                btn.style.background = '#e94560';
                btn.textContent = 'Add Entry/Exit Point';
            }
        }
        
        function addEntryExitPoint(lat, lng) {
            const name = prompt('Enter road name (Arabic or English):', 'Road');
            if (!name) return;
            
            const widthStr = prompt('Enter road width in meters:', '15');
            const width = parseFloat(widthStr) || 15;
            
            entryExitPoints.push({
                lat: lat,
                lng: lng,
                name: name,
                width: width,
                roadClass: width >= 30 ? 'Major' : 'Other'
            });
            
            document.getElementById('entryExitCount').textContent = entryExitPoints.length;
            addEntryExitMode = false;
            document.getElementById('addEntryExitBtn').style.background = '#e94560';
            document.getElementById('addEntryExitBtn').textContent = 'Add Entry/Exit Point';
            render();
            showToast('Entry/exit point added!', '#4caf50');
        }
        
        function exportEntryExitPoints() {
            if (!entryExitPoints.length) {
                showToast('No entry/exit points to export', '#ff9800');
                return;
            }
            const geojson = {
                type: 'FeatureCollection',
                features: entryExitPoints.map(p => ({
                    type: 'Feature',
                    geometry: { type: 'Point', coordinates: [p.lng, p.lat] },
                    properties: { name_ar: p.name, width_m: p.width, road_class: p.width >= 30 ? 'Major' : 'Other' }
                }))
            };
            const a = document.createElement('a');
            a.href = URL.createObjectURL(new Blob([JSON.stringify(geojson, null, 2)], { type: 'application/json' }));
            a.download = 'entry_exit_points.geojson';
            a.click();
            showToast('Exported ' + entryExitPoints.length + ' points!', '#4caf50');
        }
        
        // ESC key to cancel add mode
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && addEntryExitMode) {
                addEntryExitMode = false;
                document.getElementById('addEntryExitBtn').style.background = '#e94560';
                document.getElementById('addEntryExitBtn').textContent = 'Add Entry/Exit Point';
                showToast('Add mode cancelled', '#ff9800');
            }
        });
        
        let renderPending = false;
        // Helper functions that work with both Google Maps and Leaflet
        // Map helper functions (Leaflet)
        function getMapBounds() {
            if (!leafletMap) return null;
            const b = leafletMap.getBounds();
            return {
                north: b.getNorth(),
                south: b.getSouth(),
                east: b.getEast(),
                west: b.getWest()
            };
        }
        
        function getMapZoom() {
            if (!leafletMap) return 11;
            return leafletMap.getZoom();
        }
        
        function latLngToPixel(lat, lng) {
            if (!leafletMap) return { x: 0, y: 0 };
            const point = leafletMap.latLngToContainerPoint([lat, lng]);
            return { x: point.x, y: point.y };
        }
        
        function setMapCenter(lat, lng, zoom) {
            if (!leafletMap) return;
            leafletMap.setView([lat, lng], zoom || leafletMap.getZoom());
        }
        
        function fitMapBounds(north, south, east, west, padding) {
            if (!leafletMap) return;
            leafletMap.fitBounds([[south, west], [north, east]], { padding: [padding || 30, padding || 30] });
        }
        
        function render() {
            if (renderPending) return;
            renderPending = true;
            requestAnimationFrame(doRender);
        }
        
        function doRender() {
            renderPending = false;
            
            const bounds = getMapBounds();
            if (!bounds) return;
            
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const zoom = getMapZoom();
            document.getElementById('zoomLevel').textContent = zoom.toFixed(1);
            
            const scale = Math.pow(2, zoom);
            const baseSize = Math.max(1, zoom - 10);
            
            const showBldg = document.getElementById('showBldg').checked;
            const showApt = document.getElementById('showApt').checked;
            const showVilla = document.getElementById('showVilla').checked;
            const showOther = document.getElementById('showOther').checked;
            const showPoi = document.getElementById('showPoi').checked;
            const showDist = document.getElementById('showDistricts').checked;
            
            const bldgSize = parseFloat(document.getElementById('bldgSize').value) * baseSize / 2;
            const bldgOpacity = parseInt(document.getElementById('bldgOpacity').value) / 100;
            const aptSize = parseFloat(document.getElementById('aptSize').value) * baseSize / 2;
            const villaSize = parseFloat(document.getElementById('villaSize').value) * baseSize / 2;
            const otherSize = parseFloat(document.getElementById('otherSize').value) * baseSize / 2;
            const poiSize = parseFloat(document.getElementById('poiSize').value) * baseSize / 2;
            
            let viewBldg = 0, viewApt = 0, viewVilla = 0, viewOther = 0, viewPoi = 0;
            
            // Draw districts
            if (showDist && districts.length) {
                // First pass: draw non-selected districts (faint)
                if (!selectedDistrict) {
                    districts.forEach(d => {
                        const geom = getDistrictGeometry(d);
                        if (!geom) return;
                        
                        const coords = geom.type === 'Polygon' ? geom.coordinates[0] : 
                                       geom.type === 'MultiPolygon' ? geom.coordinates[0][0] : null;
                        if (!coords || coords.length < 3) return;
                        
                        ctx.strokeStyle = '#607D8B';
                        ctx.lineWidth = 1;
                        ctx.globalAlpha = 0.4;
                        ctx.beginPath();
                        coords.forEach(([lon, lat], i) => {
                            const {x, y} = latLngToPixel(lat, lon);
                            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
                        });
                        ctx.closePath();
                        ctx.stroke();
                    });
                    ctx.globalAlpha = 1;
                }
                
                // Second pass: draw selected district prominently
                if (selectedDistrict && selectedDistrictObj) {
                    const geom = getDistrictGeometry(selectedDistrictObj);
                    if (geom) {
                        const coords = geom.type === 'Polygon' ? geom.coordinates[0] : 
                                       geom.type === 'MultiPolygon' ? geom.coordinates[0][0] : null;
                        if (coords && coords.length >= 3) {
                            // Fill
                            ctx.fillStyle = 'rgba(255, 87, 34, 0.15)';
                            ctx.beginPath();
                            coords.forEach(([lon, lat], i) => {
                                const {x, y} = latLngToPixel(lat, lon);
                                i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
                            });
                            ctx.closePath();
                            ctx.fill();
                            
                            // Thick orange border
                            ctx.strokeStyle = '#FF5722';
                            ctx.lineWidth = 4;
                            ctx.setLineDash([]);
                            ctx.beginPath();
                            coords.forEach(([lon, lat], i) => {
                                const {x, y} = latLngToPixel(lat, lon);
                                i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
                            });
                            ctx.closePath();
                            ctx.stroke();
                            
                            // Inner white border for visibility
                            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            coords.forEach(([lon, lat], i) => {
                                const {x, y} = latLngToPixel(lat, lon);
                                i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
                            });
                            ctx.closePath();
                            ctx.stroke();
                        }
                    }
                }
            }
            
            // Draw roads (lines)
            const showRoads = document.getElementById('showRoads').checked;
            const showMajorRoads = document.getElementById('showMajorRoads')?.checked ?? true;
            const onlyMajorRoads = document.getElementById('onlyMajorRoads')?.checked ?? false;
            const majorRoadThick = parseFloat(document.getElementById('majorRoadThick')?.value || 3);
            const showRoadLabels = document.getElementById('showRoadLabels').checked;
            const roadWidthScale = parseFloat(document.getElementById('roadWidth')?.value || 1);
            
            let majorRoadCount = 0;
            
            if ((showRoads || showMajorRoads) && roads.length) {
                const drawnLabels = new Set(); // Track drawn labels to avoid duplicates
                
                roads.forEach(road => {
                    const geom = road.geometry;
                    if (!geom) return;
                    
                    const props = road.properties || {};
                    const width = parseFloat(props.width_m || props.WIDTH || props.width || 10);
                    const isMajor = width >= 30;
                    
                    // Count major roads
                    if (isMajor) majorRoadCount++;
                    
                    // Skip based on filters
                    if (onlyMajorRoads && !isMajor) return;
                    if (!showRoads && !isMajor) return;
                    if (!showMajorRoads && isMajor) return;
                    
                    const color = getRoadColor(width);
                    // Major roads get extra thickness
                    let lineWidth = getRoadLineWidth(width, zoom) * roadWidthScale;
                    if (isMajor) {
                        lineWidth = lineWidth * majorRoadThick;
                    }
                    
                    ctx.strokeStyle = color;
                    ctx.lineWidth = lineWidth;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    
                    // Handle LineString and MultiLineString
                    const lines = geom.type === 'LineString' ? [geom.coordinates] : geom.coordinates;
                    
                    lines.forEach(coords => {
                        if (!coords || coords.length < 2) return;
                        
                        // Check if any point is in view
                        let inView = false;
                        for (let i = 0; i < coords.length; i++) {
                            const [lon, lat] = coords[i];
                            if (lat >= bounds.south - 0.01 && lat <= bounds.north + 0.01 && lon >= bounds.west - 0.01 && lon <= bounds.east + 0.01) {
                                inView = true;
                                break;
                            }
                        }
                        if (!inView) return;
                        
                        // Draw the line
                        ctx.beginPath();
                        let midIdx = Math.floor(coords.length / 2);
                        let midX, midY;
                        
                        coords.forEach(([lon, lat], i) => {
                            const {x, y} = latLngToPixel(lat, lon);
                            
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                            
                            if (i === midIdx) { midX = x; midY = y; }
                        });
                        ctx.stroke();
                        
                        // Draw outline for major roads
                        if (width >= 20) {
                            ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                            ctx.lineWidth = lineWidth + 2;
                            ctx.beginPath();
                            coords.forEach(([lon, lat], i) => {
                                const {x, y} = latLngToPixel(lat, lon);
                                if (i === 0) ctx.moveTo(x, y);
                                else ctx.lineTo(x, y);
                            });
                            ctx.stroke();
                            
                            // Redraw the road on top
                            ctx.strokeStyle = color;
                            ctx.lineWidth = lineWidth;
                            ctx.beginPath();
                            coords.forEach(([lon, lat], i) => {
                                const {x, y} = latLngToPixel(lat, lon);
                                if (i === 0) ctx.moveTo(x, y);
                                else ctx.lineTo(x, y);
                            });
                            ctx.stroke();
                        }
                        
                        // Draw label for major roads
                        if (showRoadLabels && width >= 15 && zoom >= 14 && midX && midY) {
                            const name = props.name_ar || props.ROADCENTERLINENAME_AR || props.name_en || '';
                            if (name && !drawnLabels.has(name)) {
                                drawnLabels.add(name);
                                
                                ctx.font = width >= 20 ? 'bold 11px Arial' : '10px Arial';
                                ctx.fillStyle = '#333';
                                ctx.strokeStyle = 'white';
                                ctx.lineWidth = 3;
                                ctx.textAlign = 'center';
                                ctx.strokeText(name, midX, midY - 5);
                                ctx.fillText(name, midX, midY - 5);
                                
                                // Width badge
                                ctx.font = '9px Arial';
                                ctx.fillStyle = color;
                                ctx.fillText(width + 'm', midX, midY + 8);
                            }
                        }
                    });
                });
                
                // Update major road count
                const majorCountEl = document.getElementById('majorRoadCount');
                if (majorCountEl) majorCountEl.textContent = majorRoadCount;
            }
            
            // Draw Entry/Exit points - RED DOTS at boundary crossings
            const showEntryExit = document.getElementById('showEntryExit').checked;
            const entryExitSize = parseFloat(document.getElementById('entryExitSize').value);
            
            if (showEntryExit && entryExitPoints.length) {
                entryExitPoints.forEach((point, idx) => {
                    if (point.lat < bounds.south - 0.01 || point.lat > bounds.north + 0.01 || 
                        point.lng < bounds.west - 0.01 || point.lng > bounds.east + 0.01) return;
                    
                    const {x, y} = latLngToPixel(point.lat, point.lng);
                    
                    // Size based on road width
                    const size = point.width >= 60 ? entryExitSize * 1.8 :
                                 point.width >= 40 ? entryExitSize * 1.5 : 
                                 point.width >= 30 ? entryExitSize * 1.3 : 
                                 point.width >= 20 ? entryExitSize * 1.1 : entryExitSize * 0.9;
                    
                    // Outer glow (pink)
                    ctx.beginPath();
                    ctx.arc(x, y, size + 4, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(244, 67, 54, 0.3)';
                    ctx.fill();
                    
                    // RED DOT
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fillStyle = '#d32f2f';
                    ctx.fill();
                    
                    // White border
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    
                    // Width number inside
                    if (size >= 8) {
                        ctx.font = 'bold ' + Math.max(9, size * 0.75) + 'px Arial';
                        ctx.fillStyle = 'white';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(Math.round(point.width), x, y);
                    }
                    
                    // Road name label at higher zoom
                    if (zoom >= 15 && point.width >= 20) {
                        ctx.font = 'bold 9px Arial';
                        ctx.fillStyle = '#333';
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 2;
                        ctx.textAlign = 'center';
                        
                        let displayName = point.name;
                        if (displayName.length > 15) {
                            displayName = displayName.substring(0, 13) + '...';
                        }
                        
                        ctx.strokeText(displayName, x, y + size + 10);
                        ctx.fillText(displayName, x, y + size + 10);
                    }
                });
            }
            
            // Draw buildings (polygons or points) - OPTIMIZED
            if (showBldg && buildings.length) {
                ctx.globalAlpha = bldgOpacity;
                ctx.fillStyle = 'rgba(156, 39, 176, 0.5)';
                ctx.strokeStyle = '#9c27b0';
                ctx.lineWidth = Math.max(1, bldgSize / 2);
                
                for (let i = 0; i < buildings.length; i++) {
                    const b = buildings[i];
                    
                    // Fast check: is it a simple [lat, lng] array?
                    if (Array.isArray(b) && typeof b[0] === 'number') {
                        const lat = b[0], lng = b[1];
                        if (lat < bounds.south || lat > bounds.north || lng < bounds.west || lng > bounds.east) continue;
                        
                        viewBldg++;
                        const {x, y} = latLngToPixel(lat, lng);
                        ctx.beginPath();
                        ctx.arc(x, y, bldgSize, 0, 6.28);
                        ctx.fill();
                        continue;
                    }
                    
                    // Polygon format
                    const coords = b.geometry?.coordinates?.[0];
                    if (!coords || coords.length < 3) continue;
                    
                    const firstLat = coords[0][1];
                    if (firstLat < bounds.south - 0.01 || firstLat > bounds.north + 0.01) continue;
                    
                    viewBldg++;
                    ctx.beginPath();
                    for (let j = 0; j < coords.length; j++) {
                        const {x, y} = latLngToPixel(coords[j][1], coords[j][0]);
                        j === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;
            }
            
            // Draw parcels - OPTIMIZED (batch by color to minimize state changes)
            const aptPts = [], villaPts = [], otherPts = [];
            const pi2 = 6.28;
            
            for (let i = 0; i < parcels.length; i++) {
                const p = parcels[i];
                if (p.lat < bounds.south || p.lat > bounds.north || p.lng < bounds.west || p.lng > bounds.east) continue;
                
                const {x, y} = latLngToPixel(p.lat, p.lng);
                
                if (p.type === 'apt' && showApt) { aptPts.push(x, y); viewApt++; }
                else if (p.type === 'villa' && showVilla) { villaPts.push(x, y); viewVilla++; }
                else if (p.type === 'other' && showOther) { otherPts.push(x, y); viewOther++; }
            }
            
            // Batch draw by color
            ctx.fillStyle = 'rgba(255, 152, 0, 0.4)';
            for (let i = 0; i < otherPts.length; i += 2) { ctx.beginPath(); ctx.arc(otherPts[i], otherPts[i+1], otherSize, 0, pi2); ctx.fill(); }
            ctx.fillStyle = 'rgba(76, 175, 80, 0.6)';
            for (let i = 0; i < villaPts.length; i += 2) { ctx.beginPath(); ctx.arc(villaPts[i], villaPts[i+1], villaSize, 0, pi2); ctx.fill(); }
            ctx.fillStyle = 'rgba(33, 150, 243, 0.6)';
            for (let i = 0; i < aptPts.length; i += 2) { ctx.beginPath(); ctx.arc(aptPts[i], aptPts[i+1], aptSize, 0, pi2); ctx.fill(); }
            
            // Draw POIs - OPTIMIZED (group by layer color)
            if (showPoi && poiData.length) {
                const poiByColor = {};
                for (let i = 0; i < poiData.length; i++) {
                    const p = poiData[i];
                    if (p.lat < bounds.south || p.lat > bounds.north || p.lng < bounds.west || p.lng > bounds.east) continue;
                    if (activePoiCategories.size > 0 && !activePoiCategories.has(p.layer)) continue;
                    
                    const color = poiColors[p.layer] || poiColors['default'];
                    if (!poiByColor[color]) poiByColor[color] = [];
                    
                    const {x, y} = latLngToPixel(p.lat, p.lng);
                    poiByColor[color].push(x, y);
                    viewPoi++;
                }
                
                ctx.strokeStyle = 'rgba(255,255,255,0.8)';
                ctx.lineWidth = 1;
                for (const color in poiByColor) {
                    ctx.fillStyle = color;
                    const pts = poiByColor[color];
                    for (let i = 0; i < pts.length; i += 2) {
                        ctx.beginPath(); ctx.arc(pts[i], pts[i+1], poiSize, 0, pi2); ctx.fill(); ctx.stroke();
                    }
                }
            }
            
            // Update view counts
            const viewTotal = viewApt + viewVilla + viewOther;
            const villaPct = viewTotal > 0 ? (viewVilla / viewTotal * 100).toFixed(1) : 0;
            
            document.getElementById('viewBldg').textContent = viewBldg.toLocaleString();
            document.getElementById('viewApt').textContent = viewApt.toLocaleString();
            document.getElementById('viewVilla').textContent = viewVilla.toLocaleString();
            document.getElementById('viewOther').textContent = viewOther.toLocaleString();
            document.getElementById('viewTotal').textContent = viewTotal.toLocaleString();
            document.getElementById('viewPoi').textContent = viewPoi.toLocaleString();
            document.getElementById('viewVillaPct').textContent = villaPct + '%';
        }
        
        // Calculate district stats
        function calculateDistrictStats() {
            if (!selectedDistrict) {
                document.getElementById('districtStats').classList.remove('active');
                return;
            }
            
            const d = selectedDistrictObj || districts.find(x => getDistrictName(x) === selectedDistrict);
            if (!d) {
                console.log('District not found:', selectedDistrict);
                return;
            }
            
            const geom = getDistrictGeometry(d);
            if (!geom) {
                console.log('No geometry for district:', selectedDistrict);
                return;
            }
            
            const coords = geom.type === 'Polygon' ? geom.coordinates[0] : 
                           geom.type === 'MultiPolygon' ? geom.coordinates[0][0] : null;
            if (!coords) return;
            
            // Convert to [lon, lat] for pointInPolygon
            const poly = coords.map(([lon, lat]) => [lon, lat]);
            
            // Get district bounds for faster filtering
            let minLat = 90, maxLat = -90, minLng = 180, maxLng = -180;
            coords.forEach(([lon, lat]) => {
                if (lat < minLat) minLat = lat;
                if (lat > maxLat) maxLat = lat;
                if (lon < minLng) minLng = lon;
                if (lon > maxLng) maxLng = lon;
            });
            
            let bldg = 0, apt = 0, villa = 0, other = 0, poi = 0;
            
            buildings.forEach(b => {
                const bCoords = b.geometry?.coordinates?.[0];
                if (!bCoords || bCoords.length === 0) return;
                const [lon, lat] = bCoords[0];
                if (lat < minLat || lat > maxLat || lon < minLng || lon > maxLng) return;
                if (pointInPolygon(lat, lon, poly)) bldg++;
            });
            
            parcels.forEach(p => {
                if (p.lat < minLat || p.lat > maxLat || p.lng < minLng || p.lng > maxLng) return;
                if (pointInPolygon(p.lat, p.lng, poly)) {
                    if (p.type === 'apt') apt++;
                    else if (p.type === 'villa') villa++;
                    else other++;
                }
            });
            
            poiData.forEach(p => {
                if (p.lat < minLat || p.lat > maxLat || p.lng < minLng || p.lng > maxLng) return;
                if (pointInPolygon(p.lat, p.lng, poly)) poi++;
            });
            
            // Calculate road stats
            let roadCount = 0, totalRoadLength = 0, majorRoads = 0;
            const widthCounts = {};
            const uniqueRoadNames = new Set();
            
            roads.forEach(road => {
                const roadGeom = road.geometry;
                if (!roadGeom) return;
                
                const props = road.properties || {};
                const width = parseFloat(props.width_m || props.WIDTH || props.width || 0);
                const length = parseFloat(props.length_m || props.LENGTH || props.length || 0);
                const nameAr = props.name_ar || props.ROADCENTERLINENAME_AR || '';
                
                // Check if road intersects with district
                const lines = roadGeom.type === 'LineString' ? [roadGeom.coordinates] : roadGeom.coordinates;
                
                let roadInDistrict = false;
                for (const lineCoords of lines) {
                    if (!lineCoords || lineCoords.length === 0) continue;
                    
                    // Check if any point of the road is in the district
                    for (const [lon, lat] of lineCoords) {
                        if (lat >= minLat && lat <= maxLat && lon >= minLng && lon <= maxLng) {
                            if (pointInPolygon(lat, lon, poly)) {
                                roadInDistrict = true;
                                break;
                            }
                        }
                    }
                    if (roadInDistrict) break;
                }
                
                if (roadInDistrict) {
                    roadCount++;
                    totalRoadLength += length;
                    if (width >= 20) majorRoads++;
                    if (width > 0) {
                        widthCounts[width] = (widthCounts[width] || 0) + 1;
                    }
                    if (nameAr) uniqueRoadNames.add(nameAr);
                }
            });
            
            // Get entry/exit stats (points loaded from file)
            const entryExitStats = getEntryExitStats();
            
            const total = apt + villa + other;
            const villaPct = total > 0 ? (villa / total * 100).toFixed(1) : 0;
            const aptPct = total > 0 ? (apt / total * 100).toFixed(1) : 0;
            
            document.getElementById('districtStatsTitle').textContent = 'DISTRICT: ' + selectedDistrict;
            document.getElementById('distBldg').textContent = bldg.toLocaleString();
            document.getElementById('distApt').textContent = apt.toLocaleString();
            document.getElementById('distVilla').textContent = villa.toLocaleString();
            document.getElementById('distOther').textContent = other.toLocaleString();
            document.getElementById('distTotal').textContent = total.toLocaleString();
            document.getElementById('distPoi').textContent = poi.toLocaleString();
            document.getElementById('distVillaPct').textContent = villaPct + '%';
            document.getElementById('distAptPct').textContent = aptPct + '%';
            
            // Update road stats
            document.getElementById('distRoads').textContent = roadCount.toLocaleString();
            document.getElementById('distRoadLength').textContent = (totalRoadLength / 1000).toFixed(2) + ' km';
            document.getElementById('distMajorRoads').textContent = majorRoads.toLocaleString();
            document.getElementById('distEntryExit').textContent = entryExitStats.total;
            document.getElementById('distMajorCrossings').textContent = entryExitStats.major;
            document.getElementById('distSecCrossings').textContent = entryExitStats.secondary;
            document.getElementById('distLocalCrossings').textContent = entryExitStats.local;
            
            // Show road width breakdown
            const widthBreakdown = document.getElementById('distWidthBreakdown');
            const widthContainer = document.getElementById('distRoadWidths');
            
            if (Object.keys(widthCounts).length > 0) {
                widthContainer.style.display = 'block';
                widthBreakdown.innerHTML = Object.entries(widthCounts)
                    .sort((a, b) => parseFloat(b[0]) - parseFloat(a[0]))
                    .map(([w, c]) => {
                        const color = getRoadColor(parseFloat(w));
                        return `<span style="display:inline-block;margin:1px 3px;padding:1px 5px;background:${color};color:white;border-radius:3px;">${w}m: ${c}</span>`;
                    }).join('');
            } else {
                widthContainer.style.display = 'none';
            }
            
            document.getElementById('districtStats').classList.add('active');
        }
        
        // File loaders
        document.getElementById('buildingsFile').addEventListener('change', function(e) {
            const file = e.target.files[0]; if (!file) return;
            showLoading('Loading Buildings...');
            setLoadingStatus(`Reading ${(file.size/1024/1024).toFixed(1)} MB...`, 10);
            buildingsFileName = file.name;
            
            const reader = new FileReader();
            reader.onload = function(evt) {
                setLoadingStatus('Parsing JSON (this may take a moment)...', 30);
                
                setTimeout(() => {
                    try {
                        const startTime = performance.now();
                        const data = JSON.parse(evt.target.result);
                        console.log(`JSON parsed in ${(performance.now() - startTime).toFixed(0)}ms`);
                        
                        setLoadingStatus('Processing...', 70);
                        
                        // Handle different formats - direct assignment (faster)
                        if (data.type === 'FeatureCollection' && data.features) {
                            buildings = data.features;
                        } else if (Array.isArray(data) && data.length > 0) {
                            if (data[0]?.geometry) {
                                buildings = data;
                            } else if (Array.isArray(data[0])) {
                                // Array of [lat, lng] - store directly
                                buildings = data;
                            } else {
                                buildings = data;
                            }
                        } else {
                            buildings = [];
                        }
                        
                        document.getElementById('totalBldg').textContent = buildings.length.toLocaleString();
                        document.getElementById('buildingsStatus').innerHTML = `‚úì <b>${file.name}</b><br>${buildings.length.toLocaleString()} buildings`;
                        document.getElementById('buildingsStatus').classList.add('loaded');
                        
                        hideLoading();
                        showToast(`${buildings.length.toLocaleString()} buildings!`, '#9c27b0');
                        render();
                    } catch(err) {
                        hideLoading();
                        document.getElementById('buildingsStatus').innerHTML = `‚ùå Error: ${err.message}`;
                        console.error('Buildings load error:', err);
                    }
                }, 10);
            };
            reader.readAsText(file);
        });
        
        function showToast(msg, color) {
            const toast = document.createElement('div');
            toast.style.cssText = `position:fixed;top:20px;left:50%;transform:translateX(-50%);background:${color};color:white;padding:15px 30px;border-radius:8px;font-weight:bold;z-index:9999;box-shadow:0 4px 20px rgba(0,0,0,0.3);`;
            toast.textContent = msg;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 2000);
        }
        
        document.getElementById('parcelsFile').addEventListener('change', function(e) {
            const file = e.target.files[0]; if (!file) return;
            showLoading('Loading Parcels...');
            setLoadingStatus(`Reading ${(file.size/1024/1024).toFixed(1)} MB...`, 5);
            
            const reader = new FileReader();
            reader.onload = function(evt) {
                setLoadingStatus('Parsing...', 10);
                
                setTimeout(() => {
                    const text = evt.target.result;
                    const lines = text.split('\n');
                    const headerLine = lines[0].toLowerCase();
                    const headers = headerLine.split(',');
                    
                    // Find column indices once
                    const latIdx = headers.findIndex(h => h.includes('lat') && !h.includes('parcel'));
                    const lngIdx = headers.findIndex(h => h.includes('lon') || h === 'lng');
                    const typeIdx = headers.findIndex(h => h.includes('parcel_type'));
                    const aptIdx = headers.findIndex(h => h.includes('is_apartment'));
                    const luIdx = headers.findIndex(h => h.includes('mainlanduse') || h.includes('land_use'));
                    
                    console.log('CSV Headers:', headers);
                    console.log('Column indices - lat:', latIdx, 'lng:', lngIdx, 'type:', typeIdx, 'apt:', aptIdx, 'lu:', luIdx);
                    
                    // Pre-allocate array
                    parcels = new Array(lines.length - 1);
                    let aptCount = 0, villaCount = 0, otherCount = 0;
                    let validCount = 0;
                    
                    setLoadingStatus('Processing rows...', 20);
                    
                    // Process ALL at once (faster than chunks for this size)
                    for (let i = 1; i < lines.length; i++) {
                        const line = lines[i];
                        if (!line || line.length < 10) continue;
                        
                        const values = line.split(',');
                        const lat = +values[latIdx];
                        const lng = +values[lngIdx];
                        if (lat !== lat || lng !== lng) continue; // NaN check
                        
                        // Fast type classification
                        let type = 2; // 0=villa, 1=apt, 2=other
                        
                        if (typeIdx >= 0) {
                            // Use pre-classified parcel_type column
                            const t = (values[typeIdx] || '').trim().toLowerCase();
                            if (t === 'villa') type = 0;
                            else if (t === 'apartment') type = 1;
                            // Debug first few rows
                            if (i < 5) console.log('Row', i, 'parcel_type:', t, '-> type:', type);
                        } else if (aptIdx >= 0 && luIdx >= 0) {
                            // Fallback: only residential (100000/1000000) can be villa/apt
                            const isApt = values[aptIdx];
                            const lu = values[luIdx];
                            const isResidential = (lu === '100000' || lu === '1000000');
                            
                            if (isResidential) {
                                if (isApt === 'True') type = 1; // apartment
                                else type = 0; // villa
                            }
                            // else: stays as other (type=2)
                        }
                        
                        if (type === 0) villaCount++;
                        else if (type === 1) aptCount++;
                        else otherCount++;
                        
                        parcels[validCount++] = { lat, lng, type: type === 0 ? 'villa' : type === 1 ? 'apt' : 'other' };
                    }
                    
                    // Trim array to actual size
                    parcels.length = validCount;
                    
                    document.getElementById('parcelsStatus').innerHTML = `‚úì <b>${file.name}</b><br>${parcels.length.toLocaleString()} parcels`;
                    document.getElementById('parcelsStatus').classList.add('loaded');
                    document.getElementById('totalParcels').textContent = parcels.length.toLocaleString();
                    document.getElementById('totalApt').textContent = aptCount.toLocaleString();
                    document.getElementById('totalVilla').textContent = villaCount.toLocaleString();
                    document.getElementById('totalOther').textContent = otherCount.toLocaleString();
                    
                    hideLoading();
                    showToast(`${parcels.length.toLocaleString()} parcels loaded!`, '#4CAF50');
                    render();
                }, 10);
            };
            reader.readAsText(file);
        });
        
        document.getElementById('poiFile').addEventListener('change', function(e) {
            const file = e.target.files[0]; if (!file) return;
            showLoading('Loading POIs...');
            setLoadingStatus(`Reading ${(file.size/1024/1024).toFixed(1)} MB...`, 10);
            
            const reader = new FileReader();
            reader.onload = function(evt) {
                setLoadingStatus('Processing...', 30);
                
                setTimeout(() => {
                    const lines = evt.target.result.split('\n');
                    const headers = lines[0].toLowerCase().split(',');
                    
                    // Find indices once
                    const latIdx = headers.findIndex(h => h.includes('lat'));
                    const lngIdx = headers.findIndex(h => h.includes('lon') || h === 'lng');
                    const layerIdx = headers.findIndex(h => h === 'layer');
                    const nameArIdx = headers.findIndex(h => h === 'name_ar');
                    const nameEnIdx = headers.findIndex(h => h === 'name_en');
                    
                    poiData = new Array(lines.length);
                    const categories = {};
                    let count = 0;
                    
                    for (let i = 1; i < lines.length; i++) {
                        const line = lines[i];
                        if (!line || line.length < 5) continue;
                        
                        const values = line.split(',');
                        const lat = +values[latIdx];
                        const lng = +values[lngIdx];
                        if (lat !== lat || lng !== lng) continue;
                        
                        const layer = values[layerIdx] || 'Unknown';
                        categories[layer] = (categories[layer] || 0) + 1;
                        
                        poiData[count++] = { lat, lng, layer, name_ar: values[nameArIdx] || '', name_en: values[nameEnIdx] || '' };
                    }
                    poiData.length = count;
                    
                    document.getElementById('poiStatus').innerHTML = `‚úì <b>${file.name}</b><br>${poiData.length.toLocaleString()} POIs`;
                    document.getElementById('poiStatus').classList.add('loaded');
                    document.getElementById('totalPoi').textContent = poiData.length.toLocaleString();
                    document.getElementById('poiCount').textContent = poiData.length.toLocaleString();
                    document.getElementById('poiCatCount').textContent = Object.keys(categories).length;
                    
                    activePoiCategories = new Set(Object.keys(categories));
                    const catContainer = document.getElementById('poiCategories');
                    catContainer.innerHTML = Object.entries(categories).sort((a,b) => b[1]-a[1]).map(([cat, cnt]) => {
                        const color = poiColors[cat] || poiColors['default'];
                        return `<div class="poi-cat"><input type="checkbox" checked data-cat="${cat}">
                            <div class="dot" style="background:${color};width:10px;height:10px;border-radius:50%;"></div>
                            <span>${cat}</span><span class="cnt">${cnt.toLocaleString()}</span></div>`;
                    }).join('');
                    
                    catContainer.querySelectorAll('input').forEach(cb => {
                        cb.addEventListener('change', function() {
                            const cat = this.dataset.cat;
                            this.checked ? activePoiCategories.add(cat) : activePoiCategories.delete(cat);
                            render();
                        });
                    });
                    
                    hideLoading();
                    showToast(`${poiData.length.toLocaleString()} POIs!`, '#9C27B0');
                    render();
                }, 10);
            };
            reader.readAsText(file);
        });
        
        document.getElementById('distFile').addEventListener('change', function(e) {
            const file = e.target.files[0]; if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(evt) {
                try {
                    const data = JSON.parse(evt.target.result);
                    
                    // Handle different formats
                    if (data.type === 'FeatureCollection' && data.features) {
                        // Standard GeoJSON FeatureCollection
                        districts = data.features;
                    } else if (Array.isArray(data) && data[0]?.geometry) {
                        // Array of GeoJSON features
                        districts = data;
                    } else if (Array.isArray(data) && data[0]?.boundaries) {
                        // Custom format with boundaries array (like your labeler)
                        districts = data.map(d => ({
                            type: 'Feature',
                            properties: { 
                                name: d.name_en || d.name || d.name_ar,
                                name_ar: d.name_ar,
                                name_en: d.name_en
                            },
                            geometry: {
                                type: 'Polygon',
                                coordinates: [d.boundaries[0].map(([lat, lon]) => [lon, lat])]
                            }
                        }));
                    } else if (Array.isArray(data)) {
                        // Try to use as-is
                        districts = data;
                    } else {
                        districts = [];
                    }
                    
                    console.log('Districts loaded:', districts.length, 'Sample:', districts[0]);
                    
                    if (districts.length === 0) {
                        document.getElementById('distStatus').innerHTML = `‚ö†Ô∏è <b>${file.name}</b><br>No districts found. Check format.`;
                    } else {
                        document.getElementById('distStatus').innerHTML = `‚úì <b>${file.name}</b><br>${districts.length} districts loaded`;
                        document.getElementById('distStatus').classList.add('loaded');
                        showToast(`Loaded ${districts.length} districts`, '#607D8B');
                    }
                    document.getElementById('districtCount').textContent = districts.length;
                    
                    updateDistrictList();
                    render();
                } catch(err) {
                    console.error('District load error:', err);
                    document.getElementById('distStatus').innerHTML = `‚ùå <b>${file.name}</b><br>Error: ${err.message}`;
                }
            };
            reader.readAsText(file);
        });
        
        // Roads GeoJSON file handler
        document.getElementById('roadsFile').addEventListener('change', function(e) {
            const file = e.target.files[0]; if (!file) return;
            showLoading('Loading Roads...');
            setLoadingStatus(`Reading ${(file.size/1024/1024).toFixed(1)} MB...`, 10);
            
            const reader = new FileReader();
            reader.onload = function(evt) {
                setLoadingStatus('Parsing JSON...', 30);
                
                setTimeout(() => {
                    try {
                        const data = JSON.parse(evt.target.result);
                        
                        // Handle different formats
                        if (data.type === 'FeatureCollection' && data.features) {
                            roads = data.features;
                        } else if (Array.isArray(data) && data[0]?.geometry) {
                            roads = data;
                        } else if (Array.isArray(data)) {
                            roads = data;
                        } else {
                            roads = [];
                        }
                        
                        console.log('Roads loaded:', roads.length, 'Sample:', roads[0]);
                        
                        // Calculate total length and width distribution
                        let totalLength = 0;
                        const widthDist = {};
                        roads.forEach(r => {
                            const props = r.properties || {};
                            const width = parseFloat(props.width_m || props.WIDTH || props.width || 0);
                            const length = parseFloat(props.length_m || props.LENGTH || props.length || 0);
                            totalLength += length;
                            if (width > 0) {
                                widthDist[width] = (widthDist[width] || 0) + 1;
                            }
                        });
                        
                        document.getElementById('roadsStatus').innerHTML = `‚úì <b>${file.name}</b><br>${roads.length} roads (${(totalLength/1000).toFixed(2)} km)`;
                        document.getElementById('roadsStatus').classList.add('loaded');
                        document.getElementById('roadCount').textContent = roads.length;
                        document.getElementById('totalRoads').textContent = roads.length;
                        document.getElementById('roadLegend').style.display = 'block';
                        
                        // Entry/exit points are loaded from file, not calculated
                        
                        // Zoom to roads if they exist
                        if (roads.length > 0) {
                            const firstRoad = roads[0];
                            if (firstRoad.geometry && firstRoad.geometry.coordinates) {
                                const coords = firstRoad.geometry.type === 'LineString' 
                                    ? firstRoad.geometry.coordinates 
                                    : firstRoad.geometry.coordinates[0];
                                if (coords && coords.length > 0) {
                                    const [lng, lat] = coords[0];
                                    setMapCenter(lat, lng, 14);
                                }
                            }
                        }
                        
                        hideLoading();
                        showToast(`üõ£Ô∏è ${roads.length} roads loaded!`, '#2196F3');
                        render();
                    } catch(err) {
                        hideLoading();
                        console.error('Roads load error:', err);
                        document.getElementById('roadsStatus').innerHTML = `‚ùå Error: ${err.message}`;
                    }
                }, 10);
            };
            reader.readAsText(file);
        });
        
        // Entry/Exit Points GeoJSON file handler
        document.getElementById('entryExitFile').addEventListener('change', function(e) {
            const file = e.target.files[0]; if (!file) return;
            showLoading('Loading Entry/Exit Points...');
            
            const reader = new FileReader();
            reader.onload = function(evt) {
                try {
                    const data = JSON.parse(evt.target.result);
                    const features = data.features || [data];
                    
                    // Convert to entryExitPoints format
                    entryExitPoints = features.map(f => {
                        const props = f.properties || {};
                        const coords = f.geometry.coordinates;
                        return {
                            lat: coords[1],
                            lng: coords[0],
                            name: props.name_ar || props.name || props.name_en || 'Entry/Exit',
                            width: parseFloat(props.width_m || props.width || 10),
                            roadClass: props.road_class || (props.width_m >= 30 ? 'Major' : 'Other')
                        };
                    });
                    
                    // Count by type
                    const major = entryExitPoints.filter(p => p.width >= 30).length;
                    const other = entryExitPoints.length - major;
                    
                    document.getElementById('entryExitStatus').innerHTML = `<b>${entryExitPoints.length}</b> points loaded (${major} major, ${other} other)`;
                    document.getElementById('entryExitStatus').classList.add('loaded');
                    document.getElementById('entryExitCount').textContent = entryExitPoints.length;
                    
                    // Center on first point if exists
                    if (entryExitPoints.length > 0) {
                        const p = entryExitPoints[0];
                        setMapCenter(p.lat, p.lng, 15);
                    }
                    
                    // Enable entry/exit display
                    const toggle = document.getElementById('toggleEntryExit');
                    if (toggle) toggle.checked = true;
                    showEntryExit = true;
                    
                    hideLoading();
                    showToast(`Loaded ${entryExitPoints.length} entry/exit points!`, '#e94560');
                    render();
                } catch(err) {
                    hideLoading();
                    console.error('Entry/Exit load error:', err);
                    document.getElementById('entryExitStatus').innerHTML = `Error: ${err.message}`;
                }
            };
            reader.readAsText(file);
        });
        
        // Residential Zones GeoJSON file handler (handles combined file or single zone files)
        document.getElementById('zonesFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            console.log('Loading zone file:', file.name);
            showLoading('Loading zones...');
            
            const reader = new FileReader();
            reader.onload = function(evt) {
                try {
                    const data = JSON.parse(evt.target.result);
                    const features = data.features || [data];
                    
                    // Clear existing zones
                    if (zonePolygonsLayer) {
                        if (zonePolygonsLayer.clearLayers) {
                            zonePolygonsLayer.clearLayers();
                        } else if (zonePolygonsLayer.polygons) {
                            zonePolygonsLayer.polygons.forEach(p => p.setMap(null));
                            zonePolygonsLayer.polygons = [];
                        }
                    }
                    if (zoneEntryExitMarkers) {
                        if (zoneEntryExitMarkers.clearLayers) {
                            zoneEntryExitMarkers.clearLayers();
                        } else if (zoneEntryExitMarkers.markers) {
                            zoneEntryExitMarkers.markers.forEach(m => m.setMap(null));
                            zoneEntryExitMarkers.markers = [];
                        }
                    }
                    drawnPolygons = [];
                    selectedZoneIndex = -1;
                    
                    // Colors for zones
                    const colors = ['#e91e63', '#9c27b0', '#673ab7', '#3f51b5', '#2196f3', '#00bcd4', '#009688', '#4caf50', '#ff9800', '#ff5722', '#795548', '#607d8b'];
                    
                    // Check if this is a COMBINED file (has type: 'zone' and type: 'entry_exit')
                    const isCombinedFormat = features.some(f => f.properties?.type === 'zone' || f.properties?.type === 'entry_exit');
                    
                    if (isCombinedFormat) {
                        console.log('Detected COMBINED format');
                        
                        // First pass: collect all zones
                        const zonesMap = {};
                        features.forEach(f => {
                            if (f.properties?.type === 'zone' && f.geometry) {
                                let coords = [];
                                if (f.geometry.type === 'Polygon') {
                                    coords = f.geometry.coordinates[0].map(c => [c[0], c[1]]);
                                } else if (f.geometry.type === 'MultiPolygon') {
                                    coords = f.geometry.coordinates[0][0].map(c => [c[0], c[1]]);
                                }
                                
                                // Remove closing point
                                if (coords.length > 1) {
                                    const first = coords[0];
                                    const last = coords[coords.length - 1];
                                    if (Math.abs(first[0] - last[0]) < 0.0001 && Math.abs(first[1] - last[1]) < 0.0001) {
                                        coords.pop();
                                    }
                                }
                                
                                const zoneId = f.properties.id || f.properties.zoneId || Object.keys(zonesMap).length + 1;
                                zonesMap[zoneId] = {
                                    name: f.properties.name || `Zone ${zoneId}`,
                                    coordinates: coords,
                                    color: f.properties.color || colors[(zoneId - 1) % colors.length],
                                    entryExitPoints: []
                                };
                            }
                        });
                        
                        // Second pass: collect entry/exit points and assign to zones
                        features.forEach(f => {
                            if (f.properties?.type === 'entry_exit' && f.geometry?.type === 'Point') {
                                const zoneId = f.properties.zoneId || 1;
                                const point = {
                                    lat: f.geometry.coordinates[1],
                                    lng: f.geometry.coordinates[0],
                                    roadName: f.properties.roadName || f.properties.name || 'Entry/Exit',
                                    width: parseFloat(f.properties.width || 15)
                                };
                                
                                if (zonesMap[zoneId]) {
                                    zonesMap[zoneId].entryExitPoints.push(point);
                                }
                            }
                        });
                        
                        // Convert to array
                        drawnPolygons = Object.values(zonesMap);
                        
                    } else {
                        console.log('Detected SINGLE zone format');
                        
                        // Single zone file with polygon + points
                        let zonePolygon = null;
                        let entryExits = [];
                        
                        features.forEach(f => {
                            if (!f.geometry) return;
                            
                            if (f.geometry.type === 'Polygon' || f.geometry.type === 'MultiPolygon') {
                                let coords = [];
                                if (f.geometry.type === 'Polygon') {
                                    coords = f.geometry.coordinates[0].map(c => [c[0], c[1]]);
                                } else {
                                    coords = f.geometry.coordinates[0][0].map(c => [c[0], c[1]]);
                                }
                                
                                if (coords.length > 1) {
                                    const first = coords[0];
                                    const last = coords[coords.length - 1];
                                    if (Math.abs(first[0] - last[0]) < 0.0001 && Math.abs(first[1] - last[1]) < 0.0001) {
                                        coords.pop();
                                    }
                                }
                                
                                zonePolygon = {
                                    coords: coords,
                                    name: f.properties?.name || f.properties?.NAME || null
                                };
                            } else if (f.geometry.type === 'Point') {
                                const props = f.properties || {};
                                entryExits.push({
                                    lat: f.geometry.coordinates[1],
                                    lng: f.geometry.coordinates[0],
                                    roadName: props.roadName || props.road_name || props.name || 'Entry/Exit',
                                    width: parseFloat(props.width || props.width_m || 15)
                                });
                            }
                        });
                        
                        if (zonePolygon) {
                            drawnPolygons.push({
                                name: zonePolygon.name || file.name.replace(/\.(geo)?json$/i, '') || 'Zone 1',
                                coordinates: zonePolygon.coords,
                                color: colors[0],
                                entryExitPoints: entryExits
                            });
                        }
                    }
                    
                    // Count totals
                    const totalEntryPoints = drawnPolygons.reduce((sum, z) => sum + (z.entryExitPoints?.length || 0), 0);
                    
                    // Draw all zones
                    redrawAllZonePolygons();
                    
                    // Update UI
                    document.getElementById('zonesFileStatus').innerHTML = `<b>${drawnPolygons.length}</b> zones, <b>${totalEntryPoints}</b> entry points`;
                    document.getElementById('zonesFileStatus').style.color = '#4caf50';
                    document.getElementById('polygonCount').textContent = drawnPolygons.length;
                    updateZonesList();
                    
                    // Zoom to zones
                    if (drawnPolygons.length > 0) {
                        let minLat = Infinity, maxLat = -Infinity, minLng = Infinity, maxLng = -Infinity;
                        drawnPolygons.forEach(z => {
                            z.coordinates.forEach(c => {
                                minLng = Math.min(minLng, c[0]);
                                maxLng = Math.max(maxLng, c[0]);
                                minLat = Math.min(minLat, c[1]);
                                maxLat = Math.max(maxLat, c[1]);
                            });
                        });
                        fitMapBounds(maxLat, minLat, maxLng, minLng, 30);
                    }
                    
                    hideLoading();
                    showToast(`Loaded ${drawnPolygons.length} zones with ${totalEntryPoints} entry points!`, '#9c27b0');
                    
                } catch(err) {
                    hideLoading();
                    console.error('Zones load error:', err);
                    document.getElementById('zonesFileStatus').innerHTML = `Error: ${err.message}`;
                    document.getElementById('zonesFileStatus').style.color = '#d32f2f';
                }
            };
            reader.readAsText(file);
        });
        
        // Redraw all zone polygons (needed after loading multiple files)
        function redrawAllZonePolygons() {
            if (!leafletMap) return;
            
            const colors = ['#e91e63', '#9c27b0', '#673ab7', '#3f51b5', '#2196f3', '#00bcd4', '#009688', '#4caf50', '#ff9800', '#ff5722', '#795548', '#607d8b'];
            
            // Clear existing polygons
            if (zonePolygonsLayer && zonePolygonsLayer.clearLayers) {
                zonePolygonsLayer.clearLayers();
            }
            
            drawnPolygons.forEach((zone, idx) => {
                zone.color = colors[idx % colors.length];
                const latlngs = zone.coordinates.map(c => [c[1], c[0]]);
                
                const polygon = L.polygon(latlngs, {
                    color: zone.color,
                    weight: 3,
                    fillColor: zone.color,
                    fillOpacity: 0.25
                }).addTo(zonePolygonsLayer);
                
                polygon.on('click', function() {
                    selectZone(idx);
                });
            });
        }
        
        function getDistrictName(d) {
            if (d.properties) {
                return d.properties.name || d.properties.NAME || d.properties.name_en || 
                       d.properties.name_ar || d.properties.DISTRICT_NAME || d.properties.district_name;
            }
            return d.name || d.name_en || d.name_ar || 'Unknown';
        }
        
        function updateDistrictList() {
            const search = document.getElementById('districtSearch').value.toLowerCase();
            const container = document.getElementById('districtList');
            container.innerHTML = '';
            
            if (districts.length === 0) {
                container.innerHTML = '<div style="color:#999;font-size:10px;padding:10px;">No districts loaded</div>';
                return;
            }
            
            districts.forEach((d, idx) => {
                const name = getDistrictName(d) || `District ${idx + 1}`;
                if (search && !name.toLowerCase().includes(search)) return;
                
                const div = document.createElement('div');
                div.className = 'district-item' + (selectedDistrict === name ? ' selected' : '');
                div.textContent = name;
                div.onclick = () => selectDistrict(name, d);
                container.appendChild(div);
            });
        }
        
        function getDistrictGeometry(d) {
            // Handle different geometry formats
            if (d.geometry) {
                return d.geometry;
            }
            if (d.boundaries && d.boundaries[0]) {
                return {
                    type: 'Polygon',
                    coordinates: [d.boundaries[0].map(([lat, lon]) => [lon, lat])]
                };
            }
            return null;
        }
        
        function filterDistricts() { updateDistrictList(); }
        
        function selectDistrict(name, districtObj) {
            if (selectedDistrict === name) {
                selectedDistrict = null;
                selectedDistrictObj = null;
            } else {
                selectedDistrict = name;
                selectedDistrictObj = districtObj || districts.find(d => getDistrictName(d) === name);
                
                // Zoom to district
                if (selectedDistrictObj) {
                    zoomToDistrict(selectedDistrictObj);
                }
            }
            // Entry/exit points only come from file upload - never auto-generated
            updateDistrictList();
            calculateDistrictStats();
            render();
        }
        
        function zoomToDistrict(d) {
            const geom = getDistrictGeometry(d);
            if (!geom) return;
            
            const coords = geom.type === 'Polygon' ? geom.coordinates[0] : 
                           geom.type === 'MultiPolygon' ? geom.coordinates[0][0] : null;
            if (!coords || coords.length < 3) return;
            
            // Calculate bounds
            let minLat = 90, maxLat = -90, minLng = 180, maxLng = -180;
            coords.forEach(([lon, lat]) => {
                if (lat < minLat) minLat = lat;
                if (lat > maxLat) maxLat = lat;
                if (lon < minLng) minLng = lon;
                if (lon > maxLng) maxLng = lon;
            });
            
            // Fit bounds with padding
            fitMapBounds(maxLat, minLat, maxLng, minLng, 50);
        }
        
        let selectedDistrictObj = null;
        
        function clearDistrictSelection() {
            selectedDistrict = null;
            selectedDistrictObj = null;
            updateDistrictList();
            calculateDistrictStats();
            render();
            // Reset view to all Riyadh
            setMapCenter(24.7136, 46.6753, 11);
        }
        
        function selectAllPoi() {
            document.querySelectorAll('#poiCategories input').forEach(cb => { cb.checked = true; activePoiCategories.add(cb.dataset.cat); });
            render();
        }
        
        function clearAllPoi() {
            document.querySelectorAll('#poiCategories input').forEach(cb => { cb.checked = false; });
            activePoiCategories.clear();
            render();
        }
        
        function exportVisibleParcels() {
            const bounds = getMapBounds();
            if (!bounds) return;
            const visible = parcels.filter(p => p.lat >= bounds.south && p.lat <= bounds.north && p.lng >= bounds.west && p.lng <= bounds.east);
            downloadCSV(visible, 'visible_parcels.csv');
        }
        
        function exportDistrictParcels() {
            if (!selectedDistrict) { alert('Select a district first'); return; }
            const d = districts.find(x => x.properties.name === selectedDistrict);
            if (!d) return;
            const coords = d.geometry.type === 'Polygon' ? d.geometry.coordinates[0] : d.geometry.coordinates[0][0];
            const poly = coords.map(([lon, lat]) => [lon, lat]);
            const inDist = parcels.filter(p => pointInPolygon(p.lat, p.lng, poly));
            downloadCSV(inDist, `${selectedDistrict}_parcels.csv`);
        }
        
        function downloadCSV(data, filename) {
            const csv = 'latitude,longitude,type\n' + data.map(p => `${p.lat},${p.lng},${p.type}`).join('\n');
            const blob = new Blob([csv], {type: 'text/csv'});
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = filename;
            a.click();
        }
        
        // Info popup functions
        function showInfoPopup(x, y, title, content) {
            const popup = document.getElementById('infoPopup');
            document.getElementById('popupTitle').innerHTML = title;
            document.getElementById('popupContent').innerHTML = content;
            
            // Position popup
            let left = x + 15;
            let top = y + 15;
            if (left + 300 > window.innerWidth) left = x - 315;
            if (top + 200 > window.innerHeight) top = y - 215;
            
            popup.style.left = left + 'px';
            popup.style.top = top + 'px';
            popup.classList.add('show');
        }
        
        function closeInfoPopup() {
            document.getElementById('infoPopup').classList.remove('show');
        }
        
        // Check if a point is near a line segment
        function pointToLineDistance(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;
            
            if (lenSq !== 0) param = dot / lenSq;
            
            let xx, yy;
            if (param < 0) { xx = x1; yy = y1; }
            else if (param > 1) { xx = x2; yy = y2; }
            else { xx = x1 + param * C; yy = y1 + param * D; }
            
            const dx = px - xx;
            const dy = py - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        function findClickedItem(lat, lng, pixelTolerance) {
            if (!leafletMap) return null;
            
            const zoom = leafletMap.getZoom();
            // Tolerance in degrees (smaller at higher zoom)
            const tolerance = 0.0005 * Math.pow(2, 15 - zoom);
            
            // Check Entry/Exit points first (highest priority)
            for (const p of entryExitPoints) {
                const dist = Math.sqrt(Math.pow(p.lat - lat, 2) + Math.pow(p.lng - lng, 2));
                if (dist < tolerance * 2) {
                    return { type: 'entryexit', data: p };
                }
            }
            
            // Check POIs
            for (const p of poiData) {
                if (activePoiCategories.size > 0 && !activePoiCategories.has(p.layer)) continue;
                const dist = Math.sqrt(Math.pow(p.lat - lat, 2) + Math.pow(p.lng - lng, 2));
                if (dist < tolerance) {
                    return { type: 'poi', data: p };
                }
            }
            
            // Check roads (lines)
            if (roads.length > 0) {
                for (const road of roads) {
                    const geom = road.geometry;
                    if (!geom) continue;
                    
                    const lines = geom.type === 'LineString' ? [geom.coordinates] : geom.coordinates;
                    
                    for (const coords of lines) {
                        if (!coords || coords.length < 2) continue;
                        
                        for (let i = 0; i < coords.length - 1; i++) {
                            const [lon1, lat1] = coords[i];
                            const [lon2, lat2] = coords[i + 1];
                            
                            const dist = pointToLineDistance(lng, lat, lon1, lat1, lon2, lat2);
                            if (dist < tolerance * 3) {
                                return { type: 'road', data: road };
                            }
                        }
                    }
                }
            }
            
            // Check parcels
            for (const p of parcels) {
                const dist = Math.sqrt(Math.pow(p.lat - lat, 2) + Math.pow(p.lng - lng, 2));
                if (dist < tolerance) {
                    return { type: 'parcel', data: p };
                }
            }
            
            // Check buildings
            for (const b of buildings) {
                const coords = b.geometry?.coordinates?.[0];
                if (!coords || coords.length < 3) continue;
                const [lon, bLat] = coords[0];
                const dist = Math.sqrt(Math.pow(bLat - lat, 2) + Math.pow(lon - lng, 2));
                if (dist < tolerance * 3) {
                    return { type: 'building', data: { lat: bLat, lng: lon } };
                }
            }
            
            // Check districts
            for (const d of districts) {
                const geom = getDistrictGeometry(d);
                if (!geom) continue;
                const coords = geom.type === 'Polygon' ? geom.coordinates[0] : 
                               geom.type === 'MultiPolygon' ? geom.coordinates[0][0] : null;
                if (!coords) continue;
                const poly = coords.map(([lon, lat]) => [lon, lat]);
                if (pointInPolygon(lat, lng, poly)) {
                    return { type: 'district', data: d };
                }
            }
            
            return null;
        }
        
        function handleMapClick(e) {
            const lat = e.latLng.lat();
            const lng = e.latLng.lng();
            
            // Check if in create zone mode
            if (createZoneMode) {
                createZoneAtPoint(lat, lng);
                return;
            }
            
            // Check if in add zone entry/exit mode
            if (addZoneEntryMode) {
                addZoneEntryPoint(lat, lng);
                return;
            }
            
            // Check if in add entry/exit mode
            if (addEntryExitMode) {
                addEntryExitPoint(lat, lng);
                return;
            }
            
            if (!document.getElementById('enableClick').checked) return;
            
            closeInfoPopup();
            
            const item = findClickedItem(lat, lng, 15);
            
            if (!item) return;
            
            const pixelX = e.pixel.x;
            const pixelY = e.pixel.y;
            
            if (item.type === 'entryexit') {
                const p = item.data;
                const idx = entryExitPoints.indexOf(p);
                showInfoPopup(pixelX, pixelY,
                    `<span class="type-badge" style="background:#d32f2f;">Entry/Exit</span> Road Crossing Point`,
                    `<div style="direction:rtl;text-align:right;font-size:14px;font-weight:bold;margin-bottom:8px;">${p.name}</div>
                    <table>
                        <tr><td>Road Width</td><td><b>${p.width}m</b></td></tr>
                        <tr><td>Road Class</td><td>${p.width >= 30 ? 'Major Highway' : p.width >= 15 ? 'Arterial' : 'Local Road'}</td></tr>
                        <tr><td>Location</td><td>${p.lat.toFixed(5)}, ${p.lng.toFixed(5)}</td></tr>
                    </table>
                    <button onclick="deleteEntryExitPoint(${idx})" style="width:100%;margin-top:10px;padding:8px;background:#d32f2f;color:white;border:none;border-radius:4px;cursor:pointer;font-weight:bold;">Delete This Point</button>`
                );
            } else if (item.type === 'road') {
                const r = item.data;
                const props = r.properties || {};
                const width = props.width_m || props.WIDTH || props.width || 'N/A';
                const length = props.length_m || props.LENGTH || props.length || 'N/A';
                const nameAr = props.name_ar || props.ROADCENTERLINENAME_AR || '-';
                const nameEn = props.name_en || props.ROADCENTERLINENAME_EN || '-';
                const lanes = props.num_lanes || props.NOOFLANES || props.lanes || '-';
                const paved = props.paved || props.PAVED || '-';
                const category = props.category || props.ROADCATEGORY || '-';
                const condition = props.condition || props.ROADCONDITION || '-';
                const surfaceType = props.surface_type || props.SURFACETYPE || '-';
                const speedLimit = props.speed_limit || props.SPEEDLIMIT || '-';
                const direction = props.road_direction || props.ROADDIRECTION || '-';
                const streetId = props.street_id || props.STREET_ID || '-';
                
                const color = getRoadColor(parseFloat(width) || 10);
                
                showInfoPopup(pixelX, pixelY,
                    `<span class="type-badge" style="background:${color};">üõ£Ô∏è Road</span> ${width}m`,
                    `<div style="direction:rtl;text-align:right;font-size:16px;font-weight:bold;margin-bottom:8px;">${nameAr}</div>
                    <div style="color:#666;margin-bottom:10px;">${nameEn}</div>
                    <table>
                        <tr><td>üìè Width</td><td><b>${width}m</b></td></tr>
                        <tr><td>üìê Length</td><td>${typeof length === 'number' ? length.toFixed(0) + 'm' : length}</td></tr>
                        <tr><td>üöó Lanes</td><td>${lanes}</td></tr>
                        <tr><td>üõ§Ô∏è Paved</td><td>${paved}</td></tr>
                        <tr><td>Category</td><td>${category}</td></tr>
                        <tr><td>üîß Condition</td><td>${condition}</td></tr>
                        <tr><td>Surface</td><td>${surfaceType}</td></tr>
                        <tr><td>‚ö° Speed Limit</td><td>${speedLimit}</td></tr>
                        <tr><td>‚ÜîÔ∏è Direction</td><td>${direction}</td></tr>
                        <tr><td>üÜî Street ID</td><td style="font-size:9px;">${streetId}</td></tr>
                    </table>`
                );
            } else if (item.type === 'poi') {
                const p = item.data;
                const color = poiColors[p.layer] || poiColors['default'];
                showInfoPopup(pixelX, pixelY, 
                    `<span class="type-badge type-poi">${p.layer}</span> POI`,
                    `<table>
                        <tr><td>Name (AR)</td><td>${p.name_ar || '-'}</td></tr>
                        <tr><td>Name (EN)</td><td>${p.name_en || '-'}</td></tr>
                        <tr><td>Category</td><td>${p.layer}</td></tr>
                        <tr><td>Location</td><td>${p.lat.toFixed(6)}, ${p.lng.toFixed(6)}</td></tr>
                    </table>`
                );
            } else if (item.type === 'parcel') {
                const p = item.data;
                const typeClass = p.type === 'apt' ? 'type-apt' : p.type === 'villa' ? 'type-villa' : 'type-other';
                const typeName = p.type === 'apt' ? 'Apartment' : p.type === 'villa' ? 'Villa' : 'Other';
                showInfoPopup(pixelX, pixelY,
                    `<span class="type-badge ${typeClass}">${typeName}</span> Parcel`,
                    `<table>
                        <tr><td>Type</td><td>${typeName}</td></tr>
                        <tr><td>Location</td><td>${p.lat.toFixed(6)}, ${p.lng.toFixed(6)}</td></tr>
                        ${p.landuse ? `<tr><td>Land Use</td><td>${p.landuse}</td></tr>` : ''}
                        ${p.district_id ? `<tr><td>District ID</td><td>${p.district_id}</td></tr>` : ''}
                    </table>`
                );
            } else if (item.type === 'building') {
                const b = item.data;
                showInfoPopup(pixelX, pixelY,
                    `<span class="type-badge" style="background:#9c27b0;">Building</span> MS Building`,
                    `<table>
                        <tr><td>Location</td><td>${b.lat.toFixed(6)}, ${b.lng.toFixed(6)}</td></tr>
                    </table>`
                );
            } else if (item.type === 'district') {
                const d = item.data;
                const name = getDistrictName(d);
                
                // Calculate quick stats for popup
                const geom = getDistrictGeometry(d);
                let distStats = { parcels: 0, apt: 0, villa: 0, other: 0, roads: 0, roadLength: 0, majorRoads: 0, poi: 0, entryExit: 0, majorCrossings: 0, secCrossings: 0, localCrossings: 0 };
                
                if (geom) {
                    const coords = geom.type === 'Polygon' ? geom.coordinates[0] : 
                                   geom.type === 'MultiPolygon' ? geom.coordinates[0][0] : null;
                    if (coords) {
                        const poly = coords.map(([lon, lat]) => [lon, lat]);
                        let minLat = 90, maxLat = -90, minLng = 180, maxLng = -180;
                        coords.forEach(([lon, lat]) => {
                            if (lat < minLat) minLat = lat;
                            if (lat > maxLat) maxLat = lat;
                            if (lon < minLng) minLng = lon;
                            if (lon > maxLng) maxLng = lon;
                        });
                        
                        // Count parcels
                        parcels.forEach(p => {
                            if (p.lat < minLat || p.lat > maxLat || p.lng < minLng || p.lng > maxLng) return;
                            if (pointInPolygon(p.lat, p.lng, poly)) {
                                distStats.parcels++;
                                if (p.type === 'apt') distStats.apt++;
                                else if (p.type === 'villa') distStats.villa++;
                                else distStats.other++;
                            }
                        });
                        
                        // Count POIs
                        poiData.forEach(p => {
                            if (p.lat < minLat || p.lat > maxLat || p.lng < minLng || p.lng > maxLng) return;
                            if (pointInPolygon(p.lat, p.lng, poly)) distStats.poi++;
                        });
                        
                        // Count roads
                        const uniqueRoads = new Set();
                        roads.forEach(road => {
                            const roadGeom = road.geometry;
                            if (!roadGeom) return;
                            const props = road.properties || {};
                            const width = parseFloat(props.width_m || props.WIDTH || 0);
                            const length = parseFloat(props.length_m || props.LENGTH || 0);
                            const nameAr = props.name_ar || props.ROADCENTERLINENAME_AR || '';
                            
                            const lines = roadGeom.type === 'LineString' ? [roadGeom.coordinates] : roadGeom.coordinates;
                            for (const lineCoords of lines) {
                                for (const [lon, rLat] of lineCoords) {
                                    if (rLat >= minLat && rLat <= maxLat && lon >= minLng && lon <= maxLng) {
                                        if (pointInPolygon(rLat, lon, poly)) {
                                            distStats.roads++;
                                            distStats.roadLength += length;
                                            if (width >= 20) distStats.majorRoads++;
                                            if (nameAr) uniqueRoads.add(nameAr);
                                            break;
                                        }
                                    }
                                }
                            }
                        });
                        distStats.uniqueRoads = uniqueRoads.size;
                        
                        // Calculate actual entry/exit boundary crossings
                        const boundary = coords;
                        let majorCrossings = 0, secCrossings = 0, localCrossings = 0;
                        roads.forEach(road => {
                            const props = road.properties || {};
                            const width = parseFloat(props.width_m || props.WIDTH || 0);
                            const roadGeom = road.geometry;
                            if (!roadGeom) return;
                            
                            const lines = roadGeom.type === 'LineString' ? [roadGeom.coordinates] : roadGeom.coordinates;
                            lines.forEach(rCoords => {
                                if (!rCoords || rCoords.length < 2) return;
                                for (let i = 0; i < rCoords.length - 1; i++) {
                                    const [x1, y1] = rCoords[i];
                                    const [x2, y2] = rCoords[i + 1];
                                    for (let j = 0; j < boundary.length - 1; j++) {
                                        const [x3, y3] = boundary[j];
                                        const [x4, y4] = boundary[j + 1];
                                        const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
                                        if (Math.abs(denom) < 1e-10) continue;
                                        const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
                                        const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
                                        if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
                                            distStats.entryExit++;
                                            if (width >= 20) majorCrossings++;
                                            else if (width >= 15) secCrossings++;
                                            else localCrossings++;
                                        }
                                    }
                                }
                            });
                        });
                        distStats.majorCrossings = majorCrossings;
                        distStats.secCrossings = secCrossings;
                        distStats.localCrossings = localCrossings;
                    }
                }
                
                showInfoPopup(pixelX, pixelY,
                    `<span class="type-badge" style="background:#607D8B;">üèòÔ∏è District</span>`,
                    `<div style="font-size:16px;font-weight:bold;margin-bottom:10px;">${name}</div>
                    <table>
                        <tr style="background:#e3f2fd;"><td colspan="2" style="font-weight:bold;color:#1976D2;">PARCELS</td></tr>
                        <tr><td>Total Parcels</td><td><b>${distStats.parcels.toLocaleString()}</b></td></tr>
                        <tr><td>üè¢ Apartments</td><td>${distStats.apt.toLocaleString()}</td></tr>
                        <tr><td>üè† Villas</td><td>${distStats.villa.toLocaleString()}</td></tr>
                        <tr><td>üì¶ Other</td><td>${distStats.other.toLocaleString()}</td></tr>
                        <tr><td>POIs</td><td>${distStats.poi.toLocaleString()}</td></tr>
                        
                        <tr style="background:#e8f5e9;"><td colspan="2" style="font-weight:bold;color:#2E7D32;">üõ£Ô∏è ROADS</td></tr>
                        <tr><td>Road Segments</td><td><b>${distStats.roads.toLocaleString()}</b></td></tr>
                        <tr><td>Total Length</td><td>${(distStats.roadLength/1000).toFixed(2)} km</td></tr>
                        <tr><td>Major Roads (20m+)</td><td>${distStats.majorRoads}</td></tr>
                        <tr><td>Unique Roads</td><td>${distStats.uniqueRoads || 0}</td></tr>
                        
                        <tr style="background:#fce4ec;"><td colspan="2" style="font-weight:bold;color:#C2185B;">ENTRY/EXIT (Boundary Crossings)</td></tr>
                        <tr><td>Total Crossings</td><td><b>${distStats.entryExit || 0}</b></td></tr>
                        <tr><td>Major (20m+)</td><td>${distStats.majorCrossings || 0}</td></tr>
                        <tr><td>Secondary (15-20m)</td><td>${distStats.secCrossings || 0}</td></tr>
                        <tr><td>Local (<15m)</td><td>${distStats.localCrossings || 0}</td></tr>
                    </table>
                    <div style="margin-top:10px;text-align:center;">
                        <button onclick="selectDistrict('${name.replace(/'/g, "\\'")}');closeInfoPopup();" style="padding:5px 15px;background:#1a73e8;color:white;border:none;border-radius:4px;cursor:pointer;">Select District & Show Entry/Exit</button>
                    </div>`
                );
            }
        }
        
        function initMap() {
            if (map) return; // Prevent double initialization
            
            try {
                map = new google.maps.Map(document.getElementById('map'), {
                    center: { lat: 24.7136, lng: 46.6753 },
                    zoom: 11,
                    mapTypeControl: true,
                    gestureHandling: 'greedy'
                });
                
                map.addListener('idle', render);
                map.addListener('click', handleMapClick);
                
                window.addEventListener('resize', () => {
                    render();
                });
                
                console.log('Map ready. Upload your data files.');
            } catch (err) {
                console.error('Error initializing map:', err);
                document.getElementById('loadingTitle').textContent = 'Map initialization error';
                document.getElementById('loadingStatus').textContent = err.message;
                document.getElementById('loadingOverlay').classList.remove('hidden');
            }
        }
        
    </script>
</body>
</html>
